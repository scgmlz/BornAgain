# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

import _libBornAgainSample

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainSample.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainSample.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _libBornAgainSample.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _libBornAgainSample.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _libBornAgainSample.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainSample.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _libBornAgainSample.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainSample.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainSample.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainSample.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainSample.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainSample.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainSample.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainSample.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainSample.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainSample.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _libBornAgainSample.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _libBornAgainSample:
_libBornAgainSample.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _libBornAgainSample.SHARED_PTR_DISOWN


import warnings
def deprecated(message):
  def deprecated_decorator(func):
      def deprecated_func(*args, **kwargs):
          warnings.simplefilter('always', DeprecationWarning)  # turn off filter
          warnings.warn("{} is a deprecated function. {}".format(func.__name__, message),
                        category=DeprecationWarning,
                        stacklevel=2)
          warnings.simplefilter('default', DeprecationWarning)  # reset filter
          return func(*args, **kwargs)
      return deprecated_func
  return deprecated_decorator

class vdouble1d_t(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vdouble1d_t self) -> SwigPyIterator"""
        return _libBornAgainSample.vdouble1d_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vdouble1d_t self) -> bool"""
        return _libBornAgainSample.vdouble1d_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vdouble1d_t self) -> bool"""
        return _libBornAgainSample.vdouble1d_t___bool__(self)

    def __len__(self):
        r"""__len__(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainSample.vdouble1d_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> vdouble1d_t"""
        return _libBornAgainSample.vdouble1d_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, vdouble1d_t v)
        """
        return _libBornAgainSample.vdouble1d_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _libBornAgainSample.vdouble1d_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vdouble1d_t self, std::vector< double >::difference_type i)
        __delitem__(vdouble1d_t self, PySliceObject * slice)
        """
        return _libBornAgainSample.vdouble1d_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vdouble1d_t self, PySliceObject * slice) -> vdouble1d_t
        __getitem__(vdouble1d_t self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _libBornAgainSample.vdouble1d_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vdouble1d_t self, PySliceObject * slice, vdouble1d_t v)
        __setitem__(vdouble1d_t self, PySliceObject * slice)
        __setitem__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _libBornAgainSample.vdouble1d_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vdouble1d_t self) -> std::vector< double >::value_type"""
        return _libBornAgainSample.vdouble1d_t_pop(self)

    def append(self, x):
        r"""append(vdouble1d_t self, std::vector< double >::value_type const & x)"""
        return _libBornAgainSample.vdouble1d_t_append(self, x)

    def empty(self):
        r"""empty(vdouble1d_t self) -> bool"""
        return _libBornAgainSample.vdouble1d_t_empty(self)

    def size(self):
        r"""size(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainSample.vdouble1d_t_size(self)

    def swap(self, v):
        r"""swap(vdouble1d_t self, vdouble1d_t v)"""
        return _libBornAgainSample.vdouble1d_t_swap(self, v)

    def begin(self):
        r"""begin(vdouble1d_t self) -> std::vector< double >::iterator"""
        return _libBornAgainSample.vdouble1d_t_begin(self)

    def end(self):
        r"""end(vdouble1d_t self) -> std::vector< double >::iterator"""
        return _libBornAgainSample.vdouble1d_t_end(self)

    def rbegin(self):
        r"""rbegin(vdouble1d_t self) -> std::vector< double >::reverse_iterator"""
        return _libBornAgainSample.vdouble1d_t_rbegin(self)

    def rend(self):
        r"""rend(vdouble1d_t self) -> std::vector< double >::reverse_iterator"""
        return _libBornAgainSample.vdouble1d_t_rend(self)

    def clear(self):
        r"""clear(vdouble1d_t self)"""
        return _libBornAgainSample.vdouble1d_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vdouble1d_t self) -> std::vector< double >::allocator_type"""
        return _libBornAgainSample.vdouble1d_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vdouble1d_t self)"""
        return _libBornAgainSample.vdouble1d_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vdouble1d_t self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(vdouble1d_t self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _libBornAgainSample.vdouble1d_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vdouble1d_t self) -> vdouble1d_t
        __init__(vdouble1d_t self, vdouble1d_t other) -> vdouble1d_t
        __init__(vdouble1d_t self, std::vector< double >::size_type size) -> vdouble1d_t
        __init__(vdouble1d_t self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> vdouble1d_t
        """
        _libBornAgainSample.vdouble1d_t_swiginit(self, _libBornAgainSample.new_vdouble1d_t(*args))

    def push_back(self, x):
        r"""push_back(vdouble1d_t self, std::vector< double >::value_type const & x)"""
        return _libBornAgainSample.vdouble1d_t_push_back(self, x)

    def front(self):
        r"""front(vdouble1d_t self) -> std::vector< double >::value_type const &"""
        return _libBornAgainSample.vdouble1d_t_front(self)

    def back(self):
        r"""back(vdouble1d_t self) -> std::vector< double >::value_type const &"""
        return _libBornAgainSample.vdouble1d_t_back(self)

    def assign(self, n, x):
        r"""assign(vdouble1d_t self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _libBornAgainSample.vdouble1d_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vdouble1d_t self, std::vector< double >::size_type new_size)
        resize(vdouble1d_t self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _libBornAgainSample.vdouble1d_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vdouble1d_t self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(vdouble1d_t self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _libBornAgainSample.vdouble1d_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vdouble1d_t self, std::vector< double >::size_type n)"""
        return _libBornAgainSample.vdouble1d_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainSample.vdouble1d_t_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_vdouble1d_t

# Register vdouble1d_t in _libBornAgainSample:
_libBornAgainSample.vdouble1d_t_swigregister(vdouble1d_t)

class vdouble2d_t(object):
    r"""Proxy of C++ std::vector< std::vector< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vdouble2d_t self) -> SwigPyIterator"""
        return _libBornAgainSample.vdouble2d_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vdouble2d_t self) -> bool"""
        return _libBornAgainSample.vdouble2d_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vdouble2d_t self) -> bool"""
        return _libBornAgainSample.vdouble2d_t___bool__(self)

    def __len__(self):
        r"""__len__(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainSample.vdouble2d_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> vdouble2d_t"""
        return _libBornAgainSample.vdouble2d_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        __setslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, vdouble2d_t v)
        """
        return _libBornAgainSample.vdouble2d_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _libBornAgainSample.vdouble2d_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(vdouble2d_t self, PySliceObject * slice)
        """
        return _libBornAgainSample.vdouble2d_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vdouble2d_t self, PySliceObject * slice) -> vdouble2d_t
        __getitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i) -> vdouble1d_t
        """
        return _libBornAgainSample.vdouble2d_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vdouble2d_t self, PySliceObject * slice, vdouble2d_t v)
        __setitem__(vdouble2d_t self, PySliceObject * slice)
        __setitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, vdouble1d_t x)
        """
        return _libBornAgainSample.vdouble2d_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainSample.vdouble2d_t_pop(self)

    def append(self, x):
        r"""append(vdouble2d_t self, vdouble1d_t x)"""
        return _libBornAgainSample.vdouble2d_t_append(self, x)

    def empty(self):
        r"""empty(vdouble2d_t self) -> bool"""
        return _libBornAgainSample.vdouble2d_t_empty(self)

    def size(self):
        r"""size(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainSample.vdouble2d_t_size(self)

    def swap(self, v):
        r"""swap(vdouble2d_t self, vdouble2d_t v)"""
        return _libBornAgainSample.vdouble2d_t_swap(self, v)

    def begin(self):
        r"""begin(vdouble2d_t self) -> std::vector< std::vector< double > >::iterator"""
        return _libBornAgainSample.vdouble2d_t_begin(self)

    def end(self):
        r"""end(vdouble2d_t self) -> std::vector< std::vector< double > >::iterator"""
        return _libBornAgainSample.vdouble2d_t_end(self)

    def rbegin(self):
        r"""rbegin(vdouble2d_t self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _libBornAgainSample.vdouble2d_t_rbegin(self)

    def rend(self):
        r"""rend(vdouble2d_t self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _libBornAgainSample.vdouble2d_t_rend(self)

    def clear(self):
        r"""clear(vdouble2d_t self)"""
        return _libBornAgainSample.vdouble2d_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vdouble2d_t self) -> std::vector< std::vector< double > >::allocator_type"""
        return _libBornAgainSample.vdouble2d_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vdouble2d_t self)"""
        return _libBornAgainSample.vdouble2d_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos) -> std::vector< std::vector< double > >::iterator
        erase(vdouble2d_t self, std::vector< std::vector< double > >::iterator first, std::vector< std::vector< double > >::iterator last) -> std::vector< std::vector< double > >::iterator
        """
        return _libBornAgainSample.vdouble2d_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vdouble2d_t self) -> vdouble2d_t
        __init__(vdouble2d_t self, vdouble2d_t other) -> vdouble2d_t
        __init__(vdouble2d_t self, std::vector< std::vector< double > >::size_type size) -> vdouble2d_t
        __init__(vdouble2d_t self, std::vector< std::vector< double > >::size_type size, vdouble1d_t value) -> vdouble2d_t
        """
        _libBornAgainSample.vdouble2d_t_swiginit(self, _libBornAgainSample.new_vdouble2d_t(*args))

    def push_back(self, x):
        r"""push_back(vdouble2d_t self, vdouble1d_t x)"""
        return _libBornAgainSample.vdouble2d_t_push_back(self, x)

    def front(self):
        r"""front(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainSample.vdouble2d_t_front(self)

    def back(self):
        r"""back(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainSample.vdouble2d_t_back(self)

    def assign(self, n, x):
        r"""assign(vdouble2d_t self, std::vector< std::vector< double > >::size_type n, vdouble1d_t x)"""
        return _libBornAgainSample.vdouble2d_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vdouble2d_t self, std::vector< std::vector< double > >::size_type new_size)
        resize(vdouble2d_t self, std::vector< std::vector< double > >::size_type new_size, vdouble1d_t x)
        """
        return _libBornAgainSample.vdouble2d_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos, vdouble1d_t x) -> std::vector< std::vector< double > >::iterator
        insert(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos, std::vector< std::vector< double > >::size_type n, vdouble1d_t x)
        """
        return _libBornAgainSample.vdouble2d_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vdouble2d_t self, std::vector< std::vector< double > >::size_type n)"""
        return _libBornAgainSample.vdouble2d_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainSample.vdouble2d_t_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_vdouble2d_t

# Register vdouble2d_t in _libBornAgainSample:
_libBornAgainSample.vdouble2d_t_swigregister(vdouble2d_t)

class vector_integer_t(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_integer_t self) -> SwigPyIterator"""
        return _libBornAgainSample.vector_integer_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_integer_t self) -> bool"""
        return _libBornAgainSample.vector_integer_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_integer_t self) -> bool"""
        return _libBornAgainSample.vector_integer_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainSample.vector_integer_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> vector_integer_t"""
        return _libBornAgainSample.vector_integer_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, vector_integer_t v)
        """
        return _libBornAgainSample.vector_integer_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _libBornAgainSample.vector_integer_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_integer_t self, std::vector< int >::difference_type i)
        __delitem__(vector_integer_t self, PySliceObject * slice)
        """
        return _libBornAgainSample.vector_integer_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_integer_t self, PySliceObject * slice) -> vector_integer_t
        __getitem__(vector_integer_t self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _libBornAgainSample.vector_integer_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_integer_t self, PySliceObject * slice, vector_integer_t v)
        __setitem__(vector_integer_t self, PySliceObject * slice)
        __setitem__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _libBornAgainSample.vector_integer_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_integer_t self) -> std::vector< int >::value_type"""
        return _libBornAgainSample.vector_integer_t_pop(self)

    def append(self, x):
        r"""append(vector_integer_t self, std::vector< int >::value_type const & x)"""
        return _libBornAgainSample.vector_integer_t_append(self, x)

    def empty(self):
        r"""empty(vector_integer_t self) -> bool"""
        return _libBornAgainSample.vector_integer_t_empty(self)

    def size(self):
        r"""size(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainSample.vector_integer_t_size(self)

    def swap(self, v):
        r"""swap(vector_integer_t self, vector_integer_t v)"""
        return _libBornAgainSample.vector_integer_t_swap(self, v)

    def begin(self):
        r"""begin(vector_integer_t self) -> std::vector< int >::iterator"""
        return _libBornAgainSample.vector_integer_t_begin(self)

    def end(self):
        r"""end(vector_integer_t self) -> std::vector< int >::iterator"""
        return _libBornAgainSample.vector_integer_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_integer_t self) -> std::vector< int >::reverse_iterator"""
        return _libBornAgainSample.vector_integer_t_rbegin(self)

    def rend(self):
        r"""rend(vector_integer_t self) -> std::vector< int >::reverse_iterator"""
        return _libBornAgainSample.vector_integer_t_rend(self)

    def clear(self):
        r"""clear(vector_integer_t self)"""
        return _libBornAgainSample.vector_integer_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_integer_t self) -> std::vector< int >::allocator_type"""
        return _libBornAgainSample.vector_integer_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_integer_t self)"""
        return _libBornAgainSample.vector_integer_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_integer_t self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(vector_integer_t self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _libBornAgainSample.vector_integer_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_integer_t self) -> vector_integer_t
        __init__(vector_integer_t self, vector_integer_t other) -> vector_integer_t
        __init__(vector_integer_t self, std::vector< int >::size_type size) -> vector_integer_t
        __init__(vector_integer_t self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> vector_integer_t
        """
        _libBornAgainSample.vector_integer_t_swiginit(self, _libBornAgainSample.new_vector_integer_t(*args))

    def push_back(self, x):
        r"""push_back(vector_integer_t self, std::vector< int >::value_type const & x)"""
        return _libBornAgainSample.vector_integer_t_push_back(self, x)

    def front(self):
        r"""front(vector_integer_t self) -> std::vector< int >::value_type const &"""
        return _libBornAgainSample.vector_integer_t_front(self)

    def back(self):
        r"""back(vector_integer_t self) -> std::vector< int >::value_type const &"""
        return _libBornAgainSample.vector_integer_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_integer_t self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _libBornAgainSample.vector_integer_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_integer_t self, std::vector< int >::size_type new_size)
        resize(vector_integer_t self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _libBornAgainSample.vector_integer_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_integer_t self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(vector_integer_t self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _libBornAgainSample.vector_integer_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_integer_t self, std::vector< int >::size_type n)"""
        return _libBornAgainSample.vector_integer_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainSample.vector_integer_t_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_vector_integer_t

# Register vector_integer_t in _libBornAgainSample:
_libBornAgainSample.vector_integer_t_swigregister(vector_integer_t)

class vinteger2d_t(object):
    r"""Proxy of C++ std::vector< std::vector< int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vinteger2d_t self) -> SwigPyIterator"""
        return _libBornAgainSample.vinteger2d_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vinteger2d_t self) -> bool"""
        return _libBornAgainSample.vinteger2d_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vinteger2d_t self) -> bool"""
        return _libBornAgainSample.vinteger2d_t___bool__(self)

    def __len__(self):
        r"""__len__(vinteger2d_t self) -> std::vector< std::vector< int > >::size_type"""
        return _libBornAgainSample.vinteger2d_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j) -> vinteger2d_t"""
        return _libBornAgainSample.vinteger2d_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j)
        __setslice__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j, vinteger2d_t v)
        """
        return _libBornAgainSample.vinteger2d_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j)"""
        return _libBornAgainSample.vinteger2d_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i)
        __delitem__(vinteger2d_t self, PySliceObject * slice)
        """
        return _libBornAgainSample.vinteger2d_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vinteger2d_t self, PySliceObject * slice) -> vinteger2d_t
        __getitem__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i) -> vector_integer_t
        """
        return _libBornAgainSample.vinteger2d_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vinteger2d_t self, PySliceObject * slice, vinteger2d_t v)
        __setitem__(vinteger2d_t self, PySliceObject * slice)
        __setitem__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i, vector_integer_t x)
        """
        return _libBornAgainSample.vinteger2d_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vinteger2d_t self) -> vector_integer_t"""
        return _libBornAgainSample.vinteger2d_t_pop(self)

    def append(self, x):
        r"""append(vinteger2d_t self, vector_integer_t x)"""
        return _libBornAgainSample.vinteger2d_t_append(self, x)

    def empty(self):
        r"""empty(vinteger2d_t self) -> bool"""
        return _libBornAgainSample.vinteger2d_t_empty(self)

    def size(self):
        r"""size(vinteger2d_t self) -> std::vector< std::vector< int > >::size_type"""
        return _libBornAgainSample.vinteger2d_t_size(self)

    def swap(self, v):
        r"""swap(vinteger2d_t self, vinteger2d_t v)"""
        return _libBornAgainSample.vinteger2d_t_swap(self, v)

    def begin(self):
        r"""begin(vinteger2d_t self) -> std::vector< std::vector< int > >::iterator"""
        return _libBornAgainSample.vinteger2d_t_begin(self)

    def end(self):
        r"""end(vinteger2d_t self) -> std::vector< std::vector< int > >::iterator"""
        return _libBornAgainSample.vinteger2d_t_end(self)

    def rbegin(self):
        r"""rbegin(vinteger2d_t self) -> std::vector< std::vector< int > >::reverse_iterator"""
        return _libBornAgainSample.vinteger2d_t_rbegin(self)

    def rend(self):
        r"""rend(vinteger2d_t self) -> std::vector< std::vector< int > >::reverse_iterator"""
        return _libBornAgainSample.vinteger2d_t_rend(self)

    def clear(self):
        r"""clear(vinteger2d_t self)"""
        return _libBornAgainSample.vinteger2d_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vinteger2d_t self) -> std::vector< std::vector< int > >::allocator_type"""
        return _libBornAgainSample.vinteger2d_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vinteger2d_t self)"""
        return _libBornAgainSample.vinteger2d_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vinteger2d_t self, std::vector< std::vector< int > >::iterator pos) -> std::vector< std::vector< int > >::iterator
        erase(vinteger2d_t self, std::vector< std::vector< int > >::iterator first, std::vector< std::vector< int > >::iterator last) -> std::vector< std::vector< int > >::iterator
        """
        return _libBornAgainSample.vinteger2d_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vinteger2d_t self) -> vinteger2d_t
        __init__(vinteger2d_t self, vinteger2d_t other) -> vinteger2d_t
        __init__(vinteger2d_t self, std::vector< std::vector< int > >::size_type size) -> vinteger2d_t
        __init__(vinteger2d_t self, std::vector< std::vector< int > >::size_type size, vector_integer_t value) -> vinteger2d_t
        """
        _libBornAgainSample.vinteger2d_t_swiginit(self, _libBornAgainSample.new_vinteger2d_t(*args))

    def push_back(self, x):
        r"""push_back(vinteger2d_t self, vector_integer_t x)"""
        return _libBornAgainSample.vinteger2d_t_push_back(self, x)

    def front(self):
        r"""front(vinteger2d_t self) -> vector_integer_t"""
        return _libBornAgainSample.vinteger2d_t_front(self)

    def back(self):
        r"""back(vinteger2d_t self) -> vector_integer_t"""
        return _libBornAgainSample.vinteger2d_t_back(self)

    def assign(self, n, x):
        r"""assign(vinteger2d_t self, std::vector< std::vector< int > >::size_type n, vector_integer_t x)"""
        return _libBornAgainSample.vinteger2d_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vinteger2d_t self, std::vector< std::vector< int > >::size_type new_size)
        resize(vinteger2d_t self, std::vector< std::vector< int > >::size_type new_size, vector_integer_t x)
        """
        return _libBornAgainSample.vinteger2d_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vinteger2d_t self, std::vector< std::vector< int > >::iterator pos, vector_integer_t x) -> std::vector< std::vector< int > >::iterator
        insert(vinteger2d_t self, std::vector< std::vector< int > >::iterator pos, std::vector< std::vector< int > >::size_type n, vector_integer_t x)
        """
        return _libBornAgainSample.vinteger2d_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vinteger2d_t self, std::vector< std::vector< int > >::size_type n)"""
        return _libBornAgainSample.vinteger2d_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vinteger2d_t self) -> std::vector< std::vector< int > >::size_type"""
        return _libBornAgainSample.vinteger2d_t_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_vinteger2d_t

# Register vinteger2d_t in _libBornAgainSample:
_libBornAgainSample.vinteger2d_t_swigregister(vinteger2d_t)

class vector_longinteger_t(object):
    r"""Proxy of C++ std::vector< unsigned long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_longinteger_t self) -> SwigPyIterator"""
        return _libBornAgainSample.vector_longinteger_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_longinteger_t self) -> bool"""
        return _libBornAgainSample.vector_longinteger_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_longinteger_t self) -> bool"""
        return _libBornAgainSample.vector_longinteger_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainSample.vector_longinteger_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> vector_longinteger_t"""
        return _libBornAgainSample.vector_longinteger_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)
        __setslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, vector_longinteger_t v)
        """
        return _libBornAgainSample.vector_longinteger_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)"""
        return _libBornAgainSample.vector_longinteger_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i)
        __delitem__(vector_longinteger_t self, PySliceObject * slice)
        """
        return _libBornAgainSample.vector_longinteger_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_longinteger_t self, PySliceObject * slice) -> vector_longinteger_t
        __getitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &
        """
        return _libBornAgainSample.vector_longinteger_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_longinteger_t self, PySliceObject * slice, vector_longinteger_t v)
        __setitem__(vector_longinteger_t self, PySliceObject * slice)
        __setitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainSample.vector_longinteger_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_longinteger_t self) -> std::vector< unsigned long >::value_type"""
        return _libBornAgainSample.vector_longinteger_t_pop(self)

    def append(self, x):
        r"""append(vector_longinteger_t self, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainSample.vector_longinteger_t_append(self, x)

    def empty(self):
        r"""empty(vector_longinteger_t self) -> bool"""
        return _libBornAgainSample.vector_longinteger_t_empty(self)

    def size(self):
        r"""size(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainSample.vector_longinteger_t_size(self)

    def swap(self, v):
        r"""swap(vector_longinteger_t self, vector_longinteger_t v)"""
        return _libBornAgainSample.vector_longinteger_t_swap(self, v)

    def begin(self):
        r"""begin(vector_longinteger_t self) -> std::vector< unsigned long >::iterator"""
        return _libBornAgainSample.vector_longinteger_t_begin(self)

    def end(self):
        r"""end(vector_longinteger_t self) -> std::vector< unsigned long >::iterator"""
        return _libBornAgainSample.vector_longinteger_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_longinteger_t self) -> std::vector< unsigned long >::reverse_iterator"""
        return _libBornAgainSample.vector_longinteger_t_rbegin(self)

    def rend(self):
        r"""rend(vector_longinteger_t self) -> std::vector< unsigned long >::reverse_iterator"""
        return _libBornAgainSample.vector_longinteger_t_rend(self)

    def clear(self):
        r"""clear(vector_longinteger_t self)"""
        return _libBornAgainSample.vector_longinteger_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_longinteger_t self) -> std::vector< unsigned long >::allocator_type"""
        return _libBornAgainSample.vector_longinteger_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_longinteger_t self)"""
        return _libBornAgainSample.vector_longinteger_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_longinteger_t self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(vector_longinteger_t self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator
        """
        return _libBornAgainSample.vector_longinteger_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_longinteger_t self) -> vector_longinteger_t
        __init__(vector_longinteger_t self, vector_longinteger_t other) -> vector_longinteger_t
        __init__(vector_longinteger_t self, std::vector< unsigned long >::size_type size) -> vector_longinteger_t
        __init__(vector_longinteger_t self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> vector_longinteger_t
        """
        _libBornAgainSample.vector_longinteger_t_swiginit(self, _libBornAgainSample.new_vector_longinteger_t(*args))

    def push_back(self, x):
        r"""push_back(vector_longinteger_t self, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainSample.vector_longinteger_t_push_back(self, x)

    def front(self):
        r"""front(vector_longinteger_t self) -> std::vector< unsigned long >::value_type const &"""
        return _libBornAgainSample.vector_longinteger_t_front(self)

    def back(self):
        r"""back(vector_longinteger_t self) -> std::vector< unsigned long >::value_type const &"""
        return _libBornAgainSample.vector_longinteger_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_longinteger_t self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainSample.vector_longinteger_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_longinteger_t self, std::vector< unsigned long >::size_type new_size)
        resize(vector_longinteger_t self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainSample.vector_longinteger_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_longinteger_t self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(vector_longinteger_t self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainSample.vector_longinteger_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_longinteger_t self, std::vector< unsigned long >::size_type n)"""
        return _libBornAgainSample.vector_longinteger_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainSample.vector_longinteger_t_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_vector_longinteger_t

# Register vector_longinteger_t in _libBornAgainSample:
_libBornAgainSample.vector_longinteger_t_swigregister(vector_longinteger_t)

class vector_complex_t(object):
    r"""Proxy of C++ std::vector< std::complex< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_complex_t self) -> SwigPyIterator"""
        return _libBornAgainSample.vector_complex_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_complex_t self) -> bool"""
        return _libBornAgainSample.vector_complex_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_complex_t self) -> bool"""
        return _libBornAgainSample.vector_complex_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainSample.vector_complex_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j) -> vector_complex_t"""
        return _libBornAgainSample.vector_complex_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)
        __setslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j, vector_complex_t v)
        """
        return _libBornAgainSample.vector_complex_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)"""
        return _libBornAgainSample.vector_complex_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i)
        __delitem__(vector_complex_t self, PySliceObject * slice)
        """
        return _libBornAgainSample.vector_complex_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_complex_t self, PySliceObject * slice) -> vector_complex_t
        __getitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i) -> std::vector< std::complex< double > >::value_type const &
        """
        return _libBornAgainSample.vector_complex_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_complex_t self, PySliceObject * slice, vector_complex_t v)
        __setitem__(vector_complex_t self, PySliceObject * slice)
        __setitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainSample.vector_complex_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_complex_t self) -> std::vector< std::complex< double > >::value_type"""
        return _libBornAgainSample.vector_complex_t_pop(self)

    def append(self, x):
        r"""append(vector_complex_t self, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainSample.vector_complex_t_append(self, x)

    def empty(self):
        r"""empty(vector_complex_t self) -> bool"""
        return _libBornAgainSample.vector_complex_t_empty(self)

    def size(self):
        r"""size(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainSample.vector_complex_t_size(self)

    def swap(self, v):
        r"""swap(vector_complex_t self, vector_complex_t v)"""
        return _libBornAgainSample.vector_complex_t_swap(self, v)

    def begin(self):
        r"""begin(vector_complex_t self) -> std::vector< std::complex< double > >::iterator"""
        return _libBornAgainSample.vector_complex_t_begin(self)

    def end(self):
        r"""end(vector_complex_t self) -> std::vector< std::complex< double > >::iterator"""
        return _libBornAgainSample.vector_complex_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_complex_t self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _libBornAgainSample.vector_complex_t_rbegin(self)

    def rend(self):
        r"""rend(vector_complex_t self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _libBornAgainSample.vector_complex_t_rend(self)

    def clear(self):
        r"""clear(vector_complex_t self)"""
        return _libBornAgainSample.vector_complex_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_complex_t self) -> std::vector< std::complex< double > >::allocator_type"""
        return _libBornAgainSample.vector_complex_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_complex_t self)"""
        return _libBornAgainSample.vector_complex_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_complex_t self, std::vector< std::complex< double > >::iterator pos) -> std::vector< std::complex< double > >::iterator
        erase(vector_complex_t self, std::vector< std::complex< double > >::iterator first, std::vector< std::complex< double > >::iterator last) -> std::vector< std::complex< double > >::iterator
        """
        return _libBornAgainSample.vector_complex_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_complex_t self) -> vector_complex_t
        __init__(vector_complex_t self, vector_complex_t other) -> vector_complex_t
        __init__(vector_complex_t self, std::vector< std::complex< double > >::size_type size) -> vector_complex_t
        __init__(vector_complex_t self, std::vector< std::complex< double > >::size_type size, std::vector< std::complex< double > >::value_type const & value) -> vector_complex_t
        """
        _libBornAgainSample.vector_complex_t_swiginit(self, _libBornAgainSample.new_vector_complex_t(*args))

    def push_back(self, x):
        r"""push_back(vector_complex_t self, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainSample.vector_complex_t_push_back(self, x)

    def front(self):
        r"""front(vector_complex_t self) -> std::vector< std::complex< double > >::value_type const &"""
        return _libBornAgainSample.vector_complex_t_front(self)

    def back(self):
        r"""back(vector_complex_t self) -> std::vector< std::complex< double > >::value_type const &"""
        return _libBornAgainSample.vector_complex_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_complex_t self, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainSample.vector_complex_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_complex_t self, std::vector< std::complex< double > >::size_type new_size)
        resize(vector_complex_t self, std::vector< std::complex< double > >::size_type new_size, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainSample.vector_complex_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_complex_t self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::value_type const & x) -> std::vector< std::complex< double > >::iterator
        insert(vector_complex_t self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainSample.vector_complex_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_complex_t self, std::vector< std::complex< double > >::size_type n)"""
        return _libBornAgainSample.vector_complex_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainSample.vector_complex_t_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_vector_complex_t

# Register vector_complex_t in _libBornAgainSample:
_libBornAgainSample.vector_complex_t_swigregister(vector_complex_t)

class vector_string_t(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_string_t self) -> SwigPyIterator"""
        return _libBornAgainSample.vector_string_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_string_t self) -> bool"""
        return _libBornAgainSample.vector_string_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_string_t self) -> bool"""
        return _libBornAgainSample.vector_string_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainSample.vector_string_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> vector_string_t"""
        return _libBornAgainSample.vector_string_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, vector_string_t v)
        """
        return _libBornAgainSample.vector_string_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _libBornAgainSample.vector_string_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_string_t self, std::vector< std::string >::difference_type i)
        __delitem__(vector_string_t self, PySliceObject * slice)
        """
        return _libBornAgainSample.vector_string_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_string_t self, PySliceObject * slice) -> vector_string_t
        __getitem__(vector_string_t self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _libBornAgainSample.vector_string_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_string_t self, PySliceObject * slice, vector_string_t v)
        __setitem__(vector_string_t self, PySliceObject * slice)
        __setitem__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainSample.vector_string_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_string_t self) -> std::vector< std::string >::value_type"""
        return _libBornAgainSample.vector_string_t_pop(self)

    def append(self, x):
        r"""append(vector_string_t self, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainSample.vector_string_t_append(self, x)

    def empty(self):
        r"""empty(vector_string_t self) -> bool"""
        return _libBornAgainSample.vector_string_t_empty(self)

    def size(self):
        r"""size(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainSample.vector_string_t_size(self)

    def swap(self, v):
        r"""swap(vector_string_t self, vector_string_t v)"""
        return _libBornAgainSample.vector_string_t_swap(self, v)

    def begin(self):
        r"""begin(vector_string_t self) -> std::vector< std::string >::iterator"""
        return _libBornAgainSample.vector_string_t_begin(self)

    def end(self):
        r"""end(vector_string_t self) -> std::vector< std::string >::iterator"""
        return _libBornAgainSample.vector_string_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_string_t self) -> std::vector< std::string >::reverse_iterator"""
        return _libBornAgainSample.vector_string_t_rbegin(self)

    def rend(self):
        r"""rend(vector_string_t self) -> std::vector< std::string >::reverse_iterator"""
        return _libBornAgainSample.vector_string_t_rend(self)

    def clear(self):
        r"""clear(vector_string_t self)"""
        return _libBornAgainSample.vector_string_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_string_t self) -> std::vector< std::string >::allocator_type"""
        return _libBornAgainSample.vector_string_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_string_t self)"""
        return _libBornAgainSample.vector_string_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_string_t self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(vector_string_t self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _libBornAgainSample.vector_string_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_string_t self) -> vector_string_t
        __init__(vector_string_t self, vector_string_t other) -> vector_string_t
        __init__(vector_string_t self, std::vector< std::string >::size_type size) -> vector_string_t
        __init__(vector_string_t self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vector_string_t
        """
        _libBornAgainSample.vector_string_t_swiginit(self, _libBornAgainSample.new_vector_string_t(*args))

    def push_back(self, x):
        r"""push_back(vector_string_t self, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainSample.vector_string_t_push_back(self, x)

    def front(self):
        r"""front(vector_string_t self) -> std::vector< std::string >::value_type const &"""
        return _libBornAgainSample.vector_string_t_front(self)

    def back(self):
        r"""back(vector_string_t self) -> std::vector< std::string >::value_type const &"""
        return _libBornAgainSample.vector_string_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_string_t self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainSample.vector_string_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_string_t self, std::vector< std::string >::size_type new_size)
        resize(vector_string_t self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainSample.vector_string_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_string_t self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(vector_string_t self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainSample.vector_string_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_string_t self, std::vector< std::string >::size_type n)"""
        return _libBornAgainSample.vector_string_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainSample.vector_string_t_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_vector_string_t

# Register vector_string_t in _libBornAgainSample:
_libBornAgainSample.vector_string_t_swigregister(vector_string_t)

class map_string_double_t(object):
    r"""Proxy of C++ std::map< std::string,double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(map_string_double_t self) -> SwigPyIterator"""
        return _libBornAgainSample.map_string_double_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(map_string_double_t self) -> bool"""
        return _libBornAgainSample.map_string_double_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(map_string_double_t self) -> bool"""
        return _libBornAgainSample.map_string_double_t___bool__(self)

    def __len__(self):
        r"""__len__(map_string_double_t self) -> std::map< std::string,double >::size_type"""
        return _libBornAgainSample.map_string_double_t___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""__getitem__(map_string_double_t self, std::map< std::string,double >::key_type const & key) -> std::map< std::string,double >::mapped_type const &"""
        return _libBornAgainSample.map_string_double_t___getitem__(self, key)

    def __delitem__(self, key):
        r"""__delitem__(map_string_double_t self, std::map< std::string,double >::key_type const & key)"""
        return _libBornAgainSample.map_string_double_t___delitem__(self, key)

    def has_key(self, key):
        r"""has_key(map_string_double_t self, std::map< std::string,double >::key_type const & key) -> bool"""
        return _libBornAgainSample.map_string_double_t_has_key(self, key)

    def keys(self):
        r"""keys(map_string_double_t self) -> PyObject *"""
        return _libBornAgainSample.map_string_double_t_keys(self)

    def values(self):
        r"""values(map_string_double_t self) -> PyObject *"""
        return _libBornAgainSample.map_string_double_t_values(self)

    def items(self):
        r"""items(map_string_double_t self) -> PyObject *"""
        return _libBornAgainSample.map_string_double_t_items(self)

    def __contains__(self, key):
        r"""__contains__(map_string_double_t self, std::map< std::string,double >::key_type const & key) -> bool"""
        return _libBornAgainSample.map_string_double_t___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(map_string_double_t self) -> SwigPyIterator"""
        return _libBornAgainSample.map_string_double_t_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(map_string_double_t self) -> SwigPyIterator"""
        return _libBornAgainSample.map_string_double_t_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(map_string_double_t self, std::map< std::string,double >::key_type const & key)
        __setitem__(map_string_double_t self, std::map< std::string,double >::key_type const & key, std::map< std::string,double >::mapped_type const & x)
        """
        return _libBornAgainSample.map_string_double_t___setitem__(self, *args)

    def asdict(self):
        r"""asdict(map_string_double_t self) -> PyObject *"""
        return _libBornAgainSample.map_string_double_t_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(map_string_double_t self, std::less< std::string > const & other) -> map_string_double_t
        __init__(map_string_double_t self) -> map_string_double_t
        __init__(map_string_double_t self, map_string_double_t other) -> map_string_double_t
        """
        _libBornAgainSample.map_string_double_t_swiginit(self, _libBornAgainSample.new_map_string_double_t(*args))

    def empty(self):
        r"""empty(map_string_double_t self) -> bool"""
        return _libBornAgainSample.map_string_double_t_empty(self)

    def size(self):
        r"""size(map_string_double_t self) -> std::map< std::string,double >::size_type"""
        return _libBornAgainSample.map_string_double_t_size(self)

    def swap(self, v):
        r"""swap(map_string_double_t self, map_string_double_t v)"""
        return _libBornAgainSample.map_string_double_t_swap(self, v)

    def begin(self):
        r"""begin(map_string_double_t self) -> std::map< std::string,double >::iterator"""
        return _libBornAgainSample.map_string_double_t_begin(self)

    def end(self):
        r"""end(map_string_double_t self) -> std::map< std::string,double >::iterator"""
        return _libBornAgainSample.map_string_double_t_end(self)

    def rbegin(self):
        r"""rbegin(map_string_double_t self) -> std::map< std::string,double >::reverse_iterator"""
        return _libBornAgainSample.map_string_double_t_rbegin(self)

    def rend(self):
        r"""rend(map_string_double_t self) -> std::map< std::string,double >::reverse_iterator"""
        return _libBornAgainSample.map_string_double_t_rend(self)

    def clear(self):
        r"""clear(map_string_double_t self)"""
        return _libBornAgainSample.map_string_double_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(map_string_double_t self) -> std::map< std::string,double >::allocator_type"""
        return _libBornAgainSample.map_string_double_t_get_allocator(self)

    def count(self, x):
        r"""count(map_string_double_t self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::size_type"""
        return _libBornAgainSample.map_string_double_t_count(self, x)

    def erase(self, *args):
        r"""
        erase(map_string_double_t self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::size_type
        erase(map_string_double_t self, std::map< std::string,double >::iterator position)
        erase(map_string_double_t self, std::map< std::string,double >::iterator first, std::map< std::string,double >::iterator last)
        """
        return _libBornAgainSample.map_string_double_t_erase(self, *args)

    def find(self, x):
        r"""find(map_string_double_t self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _libBornAgainSample.map_string_double_t_find(self, x)

    def lower_bound(self, x):
        r"""lower_bound(map_string_double_t self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _libBornAgainSample.map_string_double_t_lower_bound(self, x)

    def upper_bound(self, x):
        r"""upper_bound(map_string_double_t self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _libBornAgainSample.map_string_double_t_upper_bound(self, x)
    __swig_destroy__ = _libBornAgainSample.delete_map_string_double_t

# Register map_string_double_t in _libBornAgainSample:
_libBornAgainSample.map_string_double_t_swigregister(map_string_double_t)

class pvacuum_double_t(object):
    r"""Proxy of C++ std::pair< double,double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(pvacuum_double_t self) -> pvacuum_double_t
        __init__(pvacuum_double_t self, double first, double second) -> pvacuum_double_t
        __init__(pvacuum_double_t self, pvacuum_double_t other) -> pvacuum_double_t
        """
        _libBornAgainSample.pvacuum_double_t_swiginit(self, _libBornAgainSample.new_pvacuum_double_t(*args))
    first = property(_libBornAgainSample.pvacuum_double_t_first_get, _libBornAgainSample.pvacuum_double_t_first_set, doc=r"""first : double""")
    second = property(_libBornAgainSample.pvacuum_double_t_second_get, _libBornAgainSample.pvacuum_double_t_second_set, doc=r"""second : double""")
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libBornAgainSample.delete_pvacuum_double_t

# Register pvacuum_double_t in _libBornAgainSample:
_libBornAgainSample.pvacuum_double_t_swigregister(pvacuum_double_t)

class vector_pvacuum_double_t(object):
    r"""Proxy of C++ std::vector< std::pair< double,double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_pvacuum_double_t self) -> SwigPyIterator"""
        return _libBornAgainSample.vector_pvacuum_double_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_pvacuum_double_t self) -> bool"""
        return _libBornAgainSample.vector_pvacuum_double_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_pvacuum_double_t self) -> bool"""
        return _libBornAgainSample.vector_pvacuum_double_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::size_type"""
        return _libBornAgainSample.vector_pvacuum_double_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i, std::vector< std::pair< double,double > >::difference_type j) -> vector_pvacuum_double_t"""
        return _libBornAgainSample.vector_pvacuum_double_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i, std::vector< std::pair< double,double > >::difference_type j)
        __setslice__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i, std::vector< std::pair< double,double > >::difference_type j, vector_pvacuum_double_t v)
        """
        return _libBornAgainSample.vector_pvacuum_double_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i, std::vector< std::pair< double,double > >::difference_type j)"""
        return _libBornAgainSample.vector_pvacuum_double_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i)
        __delitem__(vector_pvacuum_double_t self, PySliceObject * slice)
        """
        return _libBornAgainSample.vector_pvacuum_double_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_pvacuum_double_t self, PySliceObject * slice) -> vector_pvacuum_double_t
        __getitem__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i) -> pvacuum_double_t
        """
        return _libBornAgainSample.vector_pvacuum_double_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_pvacuum_double_t self, PySliceObject * slice, vector_pvacuum_double_t v)
        __setitem__(vector_pvacuum_double_t self, PySliceObject * slice)
        __setitem__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i, pvacuum_double_t x)
        """
        return _libBornAgainSample.vector_pvacuum_double_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_pvacuum_double_t self) -> pvacuum_double_t"""
        return _libBornAgainSample.vector_pvacuum_double_t_pop(self)

    def append(self, x):
        r"""append(vector_pvacuum_double_t self, pvacuum_double_t x)"""
        return _libBornAgainSample.vector_pvacuum_double_t_append(self, x)

    def empty(self):
        r"""empty(vector_pvacuum_double_t self) -> bool"""
        return _libBornAgainSample.vector_pvacuum_double_t_empty(self)

    def size(self):
        r"""size(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::size_type"""
        return _libBornAgainSample.vector_pvacuum_double_t_size(self)

    def swap(self, v):
        r"""swap(vector_pvacuum_double_t self, vector_pvacuum_double_t v)"""
        return _libBornAgainSample.vector_pvacuum_double_t_swap(self, v)

    def begin(self):
        r"""begin(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::iterator"""
        return _libBornAgainSample.vector_pvacuum_double_t_begin(self)

    def end(self):
        r"""end(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::iterator"""
        return _libBornAgainSample.vector_pvacuum_double_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::reverse_iterator"""
        return _libBornAgainSample.vector_pvacuum_double_t_rbegin(self)

    def rend(self):
        r"""rend(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::reverse_iterator"""
        return _libBornAgainSample.vector_pvacuum_double_t_rend(self)

    def clear(self):
        r"""clear(vector_pvacuum_double_t self)"""
        return _libBornAgainSample.vector_pvacuum_double_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::allocator_type"""
        return _libBornAgainSample.vector_pvacuum_double_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_pvacuum_double_t self)"""
        return _libBornAgainSample.vector_pvacuum_double_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::iterator pos) -> std::vector< std::pair< double,double > >::iterator
        erase(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::iterator first, std::vector< std::pair< double,double > >::iterator last) -> std::vector< std::pair< double,double > >::iterator
        """
        return _libBornAgainSample.vector_pvacuum_double_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_pvacuum_double_t self) -> vector_pvacuum_double_t
        __init__(vector_pvacuum_double_t self, vector_pvacuum_double_t other) -> vector_pvacuum_double_t
        __init__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type size) -> vector_pvacuum_double_t
        __init__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type size, pvacuum_double_t value) -> vector_pvacuum_double_t
        """
        _libBornAgainSample.vector_pvacuum_double_t_swiginit(self, _libBornAgainSample.new_vector_pvacuum_double_t(*args))

    def push_back(self, x):
        r"""push_back(vector_pvacuum_double_t self, pvacuum_double_t x)"""
        return _libBornAgainSample.vector_pvacuum_double_t_push_back(self, x)

    def front(self):
        r"""front(vector_pvacuum_double_t self) -> pvacuum_double_t"""
        return _libBornAgainSample.vector_pvacuum_double_t_front(self)

    def back(self):
        r"""back(vector_pvacuum_double_t self) -> pvacuum_double_t"""
        return _libBornAgainSample.vector_pvacuum_double_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type n, pvacuum_double_t x)"""
        return _libBornAgainSample.vector_pvacuum_double_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type new_size)
        resize(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type new_size, pvacuum_double_t x)
        """
        return _libBornAgainSample.vector_pvacuum_double_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::iterator pos, pvacuum_double_t x) -> std::vector< std::pair< double,double > >::iterator
        insert(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::iterator pos, std::vector< std::pair< double,double > >::size_type n, pvacuum_double_t x)
        """
        return _libBornAgainSample.vector_pvacuum_double_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type n)"""
        return _libBornAgainSample.vector_pvacuum_double_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::size_type"""
        return _libBornAgainSample.vector_pvacuum_double_t_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_vector_pvacuum_double_t

# Register vector_pvacuum_double_t in _libBornAgainSample:
_libBornAgainSample.vector_pvacuum_double_t_swigregister(vector_pvacuum_double_t)

import libBornAgainBase
class kvector_t(object):
    r"""Proxy of C++ BasicVector3D< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(kvector_t self) -> kvector_t
        __init__(kvector_t self, double const x1, double const y1, double const z1) -> kvector_t
        """
        _libBornAgainSample.kvector_t_swiginit(self, _libBornAgainSample.new_kvector_t(*args))

    def x(self):
        r"""x(kvector_t self) -> double"""
        return _libBornAgainSample.kvector_t_x(self)

    def y(self):
        r"""y(kvector_t self) -> double"""
        return _libBornAgainSample.kvector_t_y(self)

    def z(self):
        r"""z(kvector_t self) -> double"""
        return _libBornAgainSample.kvector_t_z(self)

    def setX(self, a):
        r"""setX(kvector_t self, double const & a)"""
        return _libBornAgainSample.kvector_t_setX(self, a)

    def setY(self, a):
        r"""setY(kvector_t self, double const & a)"""
        return _libBornAgainSample.kvector_t_setY(self, a)

    def setZ(self, a):
        r"""setZ(kvector_t self, double const & a)"""
        return _libBornAgainSample.kvector_t_setZ(self, a)

    def __iadd__(self, v):
        r"""__iadd__(kvector_t self, kvector_t v) -> kvector_t"""
        return _libBornAgainSample.kvector_t___iadd__(self, v)

    def __isub__(self, v):
        r"""__isub__(kvector_t self, kvector_t v) -> kvector_t"""
        return _libBornAgainSample.kvector_t___isub__(self, v)

    def conj(self):
        r"""conj(kvector_t self) -> kvector_t"""
        return _libBornAgainSample.kvector_t_conj(self)

    def mag2(self):
        r"""mag2(kvector_t self) -> double"""
        return _libBornAgainSample.kvector_t_mag2(self)

    def mag(self):
        r"""mag(kvector_t self) -> double"""
        return _libBornAgainSample.kvector_t_mag(self)

    def magxy2(self):
        r"""magxy2(kvector_t self) -> double"""
        return _libBornAgainSample.kvector_t_magxy2(self)

    def magxy(self):
        r"""magxy(kvector_t self) -> double"""
        return _libBornAgainSample.kvector_t_magxy(self)

    def phi(self):
        r"""phi(kvector_t self) -> double"""
        return _libBornAgainSample.kvector_t_phi(self)

    def theta(self):
        r"""theta(kvector_t self) -> double"""
        return _libBornAgainSample.kvector_t_theta(self)

    def cosTheta(self):
        r"""cosTheta(kvector_t self) -> double"""
        return _libBornAgainSample.kvector_t_cosTheta(self)

    def sin2Theta(self):
        r"""sin2Theta(kvector_t self) -> double"""
        return _libBornAgainSample.kvector_t_sin2Theta(self)

    def unit(self):
        r"""unit(kvector_t self) -> kvector_t"""
        return _libBornAgainSample.kvector_t_unit(self)

    def complex(self):
        r"""complex(kvector_t self) -> cvector_t"""
        return _libBornAgainSample.kvector_t_complex(self)

    def real(self):
        r"""real(kvector_t self) -> kvector_t"""
        return _libBornAgainSample.kvector_t_real(self)

    def angle(self, v):
        r"""angle(kvector_t self, kvector_t v) -> double"""
        return _libBornAgainSample.kvector_t_angle(self, v)

    def project(self, v):
        r"""project(kvector_t self, kvector_t v) -> kvector_t"""
        return _libBornAgainSample.kvector_t_project(self, v)

    def __add__(self, rhs):
        r"""__add__(kvector_t self, kvector_t rhs) -> kvector_t"""
        return _libBornAgainSample.kvector_t___add__(self, rhs)

    def __mul__(self, c):
        r"""__mul__(kvector_t self, double c) -> kvector_t"""
        return _libBornAgainSample.kvector_t___mul__(self, c)

    def __rmul__(self, c):
        r"""__rmul__(kvector_t self, double c) -> kvector_t"""
        return _libBornAgainSample.kvector_t___rmul__(self, c)

    def __neg__(self):
        r"""__neg__(kvector_t self) -> kvector_t"""
        return _libBornAgainSample.kvector_t___neg__(self)
    __swig_destroy__ = _libBornAgainSample.delete_kvector_t

# Register kvector_t in _libBornAgainSample:
_libBornAgainSample.kvector_t_swigregister(kvector_t)

class vector_kvector_t(object):
    r"""Proxy of C++ std::vector< BasicVector3D< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_kvector_t self) -> SwigPyIterator"""
        return _libBornAgainSample.vector_kvector_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_kvector_t self) -> bool"""
        return _libBornAgainSample.vector_kvector_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_kvector_t self) -> bool"""
        return _libBornAgainSample.vector_kvector_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::size_type"""
        return _libBornAgainSample.vector_kvector_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j) -> vector_kvector_t"""
        return _libBornAgainSample.vector_kvector_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j)
        __setslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j, vector_kvector_t v)
        """
        return _libBornAgainSample.vector_kvector_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j)"""
        return _libBornAgainSample.vector_kvector_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i)
        __delitem__(vector_kvector_t self, PySliceObject * slice)
        """
        return _libBornAgainSample.vector_kvector_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_kvector_t self, PySliceObject * slice) -> vector_kvector_t
        __getitem__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i) -> kvector_t
        """
        return _libBornAgainSample.vector_kvector_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_kvector_t self, PySliceObject * slice, vector_kvector_t v)
        __setitem__(vector_kvector_t self, PySliceObject * slice)
        __setitem__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, kvector_t x)
        """
        return _libBornAgainSample.vector_kvector_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_kvector_t self) -> kvector_t"""
        return _libBornAgainSample.vector_kvector_t_pop(self)

    def append(self, x):
        r"""append(vector_kvector_t self, kvector_t x)"""
        return _libBornAgainSample.vector_kvector_t_append(self, x)

    def empty(self):
        r"""empty(vector_kvector_t self) -> bool"""
        return _libBornAgainSample.vector_kvector_t_empty(self)

    def size(self):
        r"""size(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::size_type"""
        return _libBornAgainSample.vector_kvector_t_size(self)

    def swap(self, v):
        r"""swap(vector_kvector_t self, vector_kvector_t v)"""
        return _libBornAgainSample.vector_kvector_t_swap(self, v)

    def begin(self):
        r"""begin(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::iterator"""
        return _libBornAgainSample.vector_kvector_t_begin(self)

    def end(self):
        r"""end(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::iterator"""
        return _libBornAgainSample.vector_kvector_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::reverse_iterator"""
        return _libBornAgainSample.vector_kvector_t_rbegin(self)

    def rend(self):
        r"""rend(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::reverse_iterator"""
        return _libBornAgainSample.vector_kvector_t_rend(self)

    def clear(self):
        r"""clear(vector_kvector_t self)"""
        return _libBornAgainSample.vector_kvector_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::allocator_type"""
        return _libBornAgainSample.vector_kvector_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_kvector_t self)"""
        return _libBornAgainSample.vector_kvector_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator pos) -> std::vector< BasicVector3D< double > >::iterator
        erase(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator first, std::vector< BasicVector3D< double > >::iterator last) -> std::vector< BasicVector3D< double > >::iterator
        """
        return _libBornAgainSample.vector_kvector_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_kvector_t self) -> vector_kvector_t
        __init__(vector_kvector_t self, vector_kvector_t other) -> vector_kvector_t
        __init__(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type size) -> vector_kvector_t
        __init__(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type size, kvector_t value) -> vector_kvector_t
        """
        _libBornAgainSample.vector_kvector_t_swiginit(self, _libBornAgainSample.new_vector_kvector_t(*args))

    def push_back(self, x):
        r"""push_back(vector_kvector_t self, kvector_t x)"""
        return _libBornAgainSample.vector_kvector_t_push_back(self, x)

    def front(self):
        r"""front(vector_kvector_t self) -> kvector_t"""
        return _libBornAgainSample.vector_kvector_t_front(self)

    def back(self):
        r"""back(vector_kvector_t self) -> kvector_t"""
        return _libBornAgainSample.vector_kvector_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type n, kvector_t x)"""
        return _libBornAgainSample.vector_kvector_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type new_size)
        resize(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type new_size, kvector_t x)
        """
        return _libBornAgainSample.vector_kvector_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator pos, kvector_t x) -> std::vector< BasicVector3D< double > >::iterator
        insert(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator pos, std::vector< BasicVector3D< double > >::size_type n, kvector_t x)
        """
        return _libBornAgainSample.vector_kvector_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type n)"""
        return _libBornAgainSample.vector_kvector_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::size_type"""
        return _libBornAgainSample.vector_kvector_t_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_vector_kvector_t

# Register vector_kvector_t in _libBornAgainSample:
_libBornAgainSample.vector_kvector_t_swigregister(vector_kvector_t)

class cvector_t(object):
    r"""Proxy of C++ BasicVector3D< std::complex< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(cvector_t self) -> cvector_t
        __init__(cvector_t self, std::complex< double > const x1, std::complex< double > const y1, std::complex< double > const z1) -> cvector_t
        """
        _libBornAgainSample.cvector_t_swiginit(self, _libBornAgainSample.new_cvector_t(*args))

    def x(self):
        r"""x(cvector_t self) -> std::complex< double >"""
        return _libBornAgainSample.cvector_t_x(self)

    def y(self):
        r"""y(cvector_t self) -> std::complex< double >"""
        return _libBornAgainSample.cvector_t_y(self)

    def z(self):
        r"""z(cvector_t self) -> std::complex< double >"""
        return _libBornAgainSample.cvector_t_z(self)

    def setX(self, a):
        r"""setX(cvector_t self, std::complex< double > const & a)"""
        return _libBornAgainSample.cvector_t_setX(self, a)

    def setY(self, a):
        r"""setY(cvector_t self, std::complex< double > const & a)"""
        return _libBornAgainSample.cvector_t_setY(self, a)

    def setZ(self, a):
        r"""setZ(cvector_t self, std::complex< double > const & a)"""
        return _libBornAgainSample.cvector_t_setZ(self, a)

    def __iadd__(self, v):
        r"""__iadd__(cvector_t self, cvector_t v) -> cvector_t"""
        return _libBornAgainSample.cvector_t___iadd__(self, v)

    def __isub__(self, v):
        r"""__isub__(cvector_t self, cvector_t v) -> cvector_t"""
        return _libBornAgainSample.cvector_t___isub__(self, v)

    def conj(self):
        r"""conj(cvector_t self) -> cvector_t"""
        return _libBornAgainSample.cvector_t_conj(self)

    def mag2(self):
        r"""mag2(cvector_t self) -> double"""
        return _libBornAgainSample.cvector_t_mag2(self)

    def mag(self):
        r"""mag(cvector_t self) -> double"""
        return _libBornAgainSample.cvector_t_mag(self)

    def magxy2(self):
        r"""magxy2(cvector_t self) -> double"""
        return _libBornAgainSample.cvector_t_magxy2(self)

    def magxy(self):
        r"""magxy(cvector_t self) -> double"""
        return _libBornAgainSample.cvector_t_magxy(self)

    def unit(self):
        r"""unit(cvector_t self) -> cvector_t"""
        return _libBornAgainSample.cvector_t_unit(self)

    def real(self):
        r"""real(cvector_t self) -> kvector_t"""
        return _libBornAgainSample.cvector_t_real(self)

    def project(self, v):
        r"""project(cvector_t self, cvector_t v) -> cvector_t"""
        return _libBornAgainSample.cvector_t_project(self, v)
    __swig_destroy__ = _libBornAgainSample.delete_cvector_t

# Register cvector_t in _libBornAgainSample:
_libBornAgainSample.cvector_t_swigregister(cvector_t)

class vector_cvector_t(object):
    r"""Proxy of C++ std::vector< BasicVector3D< std::complex< double > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_cvector_t self) -> SwigPyIterator"""
        return _libBornAgainSample.vector_cvector_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_cvector_t self) -> bool"""
        return _libBornAgainSample.vector_cvector_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_cvector_t self) -> bool"""
        return _libBornAgainSample.vector_cvector_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::size_type"""
        return _libBornAgainSample.vector_cvector_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j) -> vector_cvector_t"""
        return _libBornAgainSample.vector_cvector_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j)
        __setslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j, vector_cvector_t v)
        """
        return _libBornAgainSample.vector_cvector_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j)"""
        return _libBornAgainSample.vector_cvector_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i)
        __delitem__(vector_cvector_t self, PySliceObject * slice)
        """
        return _libBornAgainSample.vector_cvector_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_cvector_t self, PySliceObject * slice) -> vector_cvector_t
        __getitem__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i) -> cvector_t
        """
        return _libBornAgainSample.vector_cvector_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_cvector_t self, PySliceObject * slice, vector_cvector_t v)
        __setitem__(vector_cvector_t self, PySliceObject * slice)
        __setitem__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, cvector_t x)
        """
        return _libBornAgainSample.vector_cvector_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_cvector_t self) -> cvector_t"""
        return _libBornAgainSample.vector_cvector_t_pop(self)

    def append(self, x):
        r"""append(vector_cvector_t self, cvector_t x)"""
        return _libBornAgainSample.vector_cvector_t_append(self, x)

    def empty(self):
        r"""empty(vector_cvector_t self) -> bool"""
        return _libBornAgainSample.vector_cvector_t_empty(self)

    def size(self):
        r"""size(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::size_type"""
        return _libBornAgainSample.vector_cvector_t_size(self)

    def swap(self, v):
        r"""swap(vector_cvector_t self, vector_cvector_t v)"""
        return _libBornAgainSample.vector_cvector_t_swap(self, v)

    def begin(self):
        r"""begin(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::iterator"""
        return _libBornAgainSample.vector_cvector_t_begin(self)

    def end(self):
        r"""end(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::iterator"""
        return _libBornAgainSample.vector_cvector_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::reverse_iterator"""
        return _libBornAgainSample.vector_cvector_t_rbegin(self)

    def rend(self):
        r"""rend(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::reverse_iterator"""
        return _libBornAgainSample.vector_cvector_t_rend(self)

    def clear(self):
        r"""clear(vector_cvector_t self)"""
        return _libBornAgainSample.vector_cvector_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::allocator_type"""
        return _libBornAgainSample.vector_cvector_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_cvector_t self)"""
        return _libBornAgainSample.vector_cvector_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator pos) -> std::vector< BasicVector3D< std::complex< double > > >::iterator
        erase(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator first, std::vector< BasicVector3D< std::complex< double > > >::iterator last) -> std::vector< BasicVector3D< std::complex< double > > >::iterator
        """
        return _libBornAgainSample.vector_cvector_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_cvector_t self) -> vector_cvector_t
        __init__(vector_cvector_t self, vector_cvector_t other) -> vector_cvector_t
        __init__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type size) -> vector_cvector_t
        __init__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type size, cvector_t value) -> vector_cvector_t
        """
        _libBornAgainSample.vector_cvector_t_swiginit(self, _libBornAgainSample.new_vector_cvector_t(*args))

    def push_back(self, x):
        r"""push_back(vector_cvector_t self, cvector_t x)"""
        return _libBornAgainSample.vector_cvector_t_push_back(self, x)

    def front(self):
        r"""front(vector_cvector_t self) -> cvector_t"""
        return _libBornAgainSample.vector_cvector_t_front(self)

    def back(self):
        r"""back(vector_cvector_t self) -> cvector_t"""
        return _libBornAgainSample.vector_cvector_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type n, cvector_t x)"""
        return _libBornAgainSample.vector_cvector_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type new_size)
        resize(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type new_size, cvector_t x)
        """
        return _libBornAgainSample.vector_cvector_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator pos, cvector_t x) -> std::vector< BasicVector3D< std::complex< double > > >::iterator
        insert(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator pos, std::vector< BasicVector3D< std::complex< double > > >::size_type n, cvector_t x)
        """
        return _libBornAgainSample.vector_cvector_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type n)"""
        return _libBornAgainSample.vector_cvector_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::size_type"""
        return _libBornAgainSample.vector_cvector_t_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_vector_cvector_t

# Register vector_cvector_t in _libBornAgainSample:
_libBornAgainSample.vector_cvector_t_swigregister(vector_cvector_t)

import libBornAgainParam
class swig_dummy_type_inode_vector(object):
    r"""Proxy of C++ std::vector< INode * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(swig_dummy_type_inode_vector self) -> SwigPyIterator"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(swig_dummy_type_inode_vector self) -> bool"""
        return _libBornAgainSample.swig_dummy_type_inode_vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(swig_dummy_type_inode_vector self) -> bool"""
        return _libBornAgainSample.swig_dummy_type_inode_vector___bool__(self)

    def __len__(self):
        r"""__len__(swig_dummy_type_inode_vector self) -> std::vector< INode * >::size_type"""
        return _libBornAgainSample.swig_dummy_type_inode_vector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(swig_dummy_type_inode_vector self, std::vector< INode * >::difference_type i, std::vector< INode * >::difference_type j) -> swig_dummy_type_inode_vector"""
        return _libBornAgainSample.swig_dummy_type_inode_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(swig_dummy_type_inode_vector self, std::vector< INode * >::difference_type i, std::vector< INode * >::difference_type j)
        __setslice__(swig_dummy_type_inode_vector self, std::vector< INode * >::difference_type i, std::vector< INode * >::difference_type j, swig_dummy_type_inode_vector v)
        """
        return _libBornAgainSample.swig_dummy_type_inode_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(swig_dummy_type_inode_vector self, std::vector< INode * >::difference_type i, std::vector< INode * >::difference_type j)"""
        return _libBornAgainSample.swig_dummy_type_inode_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(swig_dummy_type_inode_vector self, std::vector< INode * >::difference_type i)
        __delitem__(swig_dummy_type_inode_vector self, PySliceObject * slice)
        """
        return _libBornAgainSample.swig_dummy_type_inode_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(swig_dummy_type_inode_vector self, PySliceObject * slice) -> swig_dummy_type_inode_vector
        __getitem__(swig_dummy_type_inode_vector self, std::vector< INode * >::difference_type i) -> INode
        """
        return _libBornAgainSample.swig_dummy_type_inode_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(swig_dummy_type_inode_vector self, PySliceObject * slice, swig_dummy_type_inode_vector v)
        __setitem__(swig_dummy_type_inode_vector self, PySliceObject * slice)
        __setitem__(swig_dummy_type_inode_vector self, std::vector< INode * >::difference_type i, INode x)
        """
        return _libBornAgainSample.swig_dummy_type_inode_vector___setitem__(self, *args)

    def pop(self):
        r"""pop(swig_dummy_type_inode_vector self) -> INode"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_pop(self)

    def append(self, x):
        r"""append(swig_dummy_type_inode_vector self, INode x)"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_append(self, x)

    def empty(self):
        r"""empty(swig_dummy_type_inode_vector self) -> bool"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_empty(self)

    def size(self):
        r"""size(swig_dummy_type_inode_vector self) -> std::vector< INode * >::size_type"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_size(self)

    def swap(self, v):
        r"""swap(swig_dummy_type_inode_vector self, swig_dummy_type_inode_vector v)"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_swap(self, v)

    def begin(self):
        r"""begin(swig_dummy_type_inode_vector self) -> std::vector< INode * >::iterator"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_begin(self)

    def end(self):
        r"""end(swig_dummy_type_inode_vector self) -> std::vector< INode * >::iterator"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_end(self)

    def rbegin(self):
        r"""rbegin(swig_dummy_type_inode_vector self) -> std::vector< INode * >::reverse_iterator"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_rbegin(self)

    def rend(self):
        r"""rend(swig_dummy_type_inode_vector self) -> std::vector< INode * >::reverse_iterator"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_rend(self)

    def clear(self):
        r"""clear(swig_dummy_type_inode_vector self)"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(swig_dummy_type_inode_vector self) -> std::vector< INode * >::allocator_type"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(swig_dummy_type_inode_vector self)"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(swig_dummy_type_inode_vector self, std::vector< INode * >::iterator pos) -> std::vector< INode * >::iterator
        erase(swig_dummy_type_inode_vector self, std::vector< INode * >::iterator first, std::vector< INode * >::iterator last) -> std::vector< INode * >::iterator
        """
        return _libBornAgainSample.swig_dummy_type_inode_vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(swig_dummy_type_inode_vector self) -> swig_dummy_type_inode_vector
        __init__(swig_dummy_type_inode_vector self, swig_dummy_type_inode_vector other) -> swig_dummy_type_inode_vector
        __init__(swig_dummy_type_inode_vector self, std::vector< INode * >::size_type size) -> swig_dummy_type_inode_vector
        __init__(swig_dummy_type_inode_vector self, std::vector< INode * >::size_type size, INode value) -> swig_dummy_type_inode_vector
        """
        _libBornAgainSample.swig_dummy_type_inode_vector_swiginit(self, _libBornAgainSample.new_swig_dummy_type_inode_vector(*args))

    def push_back(self, x):
        r"""push_back(swig_dummy_type_inode_vector self, INode x)"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_push_back(self, x)

    def front(self):
        r"""front(swig_dummy_type_inode_vector self) -> INode"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_front(self)

    def back(self):
        r"""back(swig_dummy_type_inode_vector self) -> INode"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_back(self)

    def assign(self, n, x):
        r"""assign(swig_dummy_type_inode_vector self, std::vector< INode * >::size_type n, INode x)"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(swig_dummy_type_inode_vector self, std::vector< INode * >::size_type new_size)
        resize(swig_dummy_type_inode_vector self, std::vector< INode * >::size_type new_size, INode x)
        """
        return _libBornAgainSample.swig_dummy_type_inode_vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(swig_dummy_type_inode_vector self, std::vector< INode * >::iterator pos, INode x) -> std::vector< INode * >::iterator
        insert(swig_dummy_type_inode_vector self, std::vector< INode * >::iterator pos, std::vector< INode * >::size_type n, INode x)
        """
        return _libBornAgainSample.swig_dummy_type_inode_vector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(swig_dummy_type_inode_vector self, std::vector< INode * >::size_type n)"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_reserve(self, n)

    def capacity(self):
        r"""capacity(swig_dummy_type_inode_vector self) -> std::vector< INode * >::size_type"""
        return _libBornAgainSample.swig_dummy_type_inode_vector_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_swig_dummy_type_inode_vector

# Register swig_dummy_type_inode_vector in _libBornAgainSample:
_libBornAgainSample.swig_dummy_type_inode_vector_swigregister(swig_dummy_type_inode_vector)

class swig_dummy_type_const_inode_vector(object):
    r"""Proxy of C++ std::vector< INode const * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(swig_dummy_type_const_inode_vector self) -> SwigPyIterator"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(swig_dummy_type_const_inode_vector self) -> bool"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(swig_dummy_type_const_inode_vector self) -> bool"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector___bool__(self)

    def __len__(self):
        r"""__len__(swig_dummy_type_const_inode_vector self) -> std::vector< INode const * >::size_type"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::difference_type i, std::vector< INode const * >::difference_type j) -> swig_dummy_type_const_inode_vector"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::difference_type i, std::vector< INode const * >::difference_type j)
        __setslice__(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::difference_type i, std::vector< INode const * >::difference_type j, swig_dummy_type_const_inode_vector v)
        """
        return _libBornAgainSample.swig_dummy_type_const_inode_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::difference_type i, std::vector< INode const * >::difference_type j)"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::difference_type i)
        __delitem__(swig_dummy_type_const_inode_vector self, PySliceObject * slice)
        """
        return _libBornAgainSample.swig_dummy_type_const_inode_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(swig_dummy_type_const_inode_vector self, PySliceObject * slice) -> swig_dummy_type_const_inode_vector
        __getitem__(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::difference_type i) -> INode
        """
        return _libBornAgainSample.swig_dummy_type_const_inode_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(swig_dummy_type_const_inode_vector self, PySliceObject * slice, swig_dummy_type_const_inode_vector v)
        __setitem__(swig_dummy_type_const_inode_vector self, PySliceObject * slice)
        __setitem__(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::difference_type i, INode x)
        """
        return _libBornAgainSample.swig_dummy_type_const_inode_vector___setitem__(self, *args)

    def pop(self):
        r"""pop(swig_dummy_type_const_inode_vector self) -> INode"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_pop(self)

    def append(self, x):
        r"""append(swig_dummy_type_const_inode_vector self, INode x)"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_append(self, x)

    def empty(self):
        r"""empty(swig_dummy_type_const_inode_vector self) -> bool"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_empty(self)

    def size(self):
        r"""size(swig_dummy_type_const_inode_vector self) -> std::vector< INode const * >::size_type"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_size(self)

    def swap(self, v):
        r"""swap(swig_dummy_type_const_inode_vector self, swig_dummy_type_const_inode_vector v)"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_swap(self, v)

    def begin(self):
        r"""begin(swig_dummy_type_const_inode_vector self) -> std::vector< INode const * >::iterator"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_begin(self)

    def end(self):
        r"""end(swig_dummy_type_const_inode_vector self) -> std::vector< INode const * >::iterator"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_end(self)

    def rbegin(self):
        r"""rbegin(swig_dummy_type_const_inode_vector self) -> std::vector< INode const * >::reverse_iterator"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_rbegin(self)

    def rend(self):
        r"""rend(swig_dummy_type_const_inode_vector self) -> std::vector< INode const * >::reverse_iterator"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_rend(self)

    def clear(self):
        r"""clear(swig_dummy_type_const_inode_vector self)"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(swig_dummy_type_const_inode_vector self) -> std::vector< INode const * >::allocator_type"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(swig_dummy_type_const_inode_vector self)"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::iterator pos) -> std::vector< INode const * >::iterator
        erase(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::iterator first, std::vector< INode const * >::iterator last) -> std::vector< INode const * >::iterator
        """
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(swig_dummy_type_const_inode_vector self) -> swig_dummy_type_const_inode_vector
        __init__(swig_dummy_type_const_inode_vector self, swig_dummy_type_const_inode_vector other) -> swig_dummy_type_const_inode_vector
        __init__(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::size_type size) -> swig_dummy_type_const_inode_vector
        __init__(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::size_type size, INode value) -> swig_dummy_type_const_inode_vector
        """
        _libBornAgainSample.swig_dummy_type_const_inode_vector_swiginit(self, _libBornAgainSample.new_swig_dummy_type_const_inode_vector(*args))

    def push_back(self, x):
        r"""push_back(swig_dummy_type_const_inode_vector self, INode x)"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_push_back(self, x)

    def front(self):
        r"""front(swig_dummy_type_const_inode_vector self) -> INode"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_front(self)

    def back(self):
        r"""back(swig_dummy_type_const_inode_vector self) -> INode"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_back(self)

    def assign(self, n, x):
        r"""assign(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::size_type n, INode x)"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::size_type new_size)
        resize(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::size_type new_size, INode x)
        """
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::iterator pos, INode x) -> std::vector< INode const * >::iterator
        insert(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::iterator pos, std::vector< INode const * >::size_type n, INode x)
        """
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(swig_dummy_type_const_inode_vector self, std::vector< INode const * >::size_type n)"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_reserve(self, n)

    def capacity(self):
        r"""capacity(swig_dummy_type_const_inode_vector self) -> std::vector< INode const * >::size_type"""
        return _libBornAgainSample.swig_dummy_type_const_inode_vector_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_swig_dummy_type_const_inode_vector

# Register swig_dummy_type_const_inode_vector in _libBornAgainSample:
_libBornAgainSample.swig_dummy_type_const_inode_vector_swigregister(swig_dummy_type_const_inode_vector)

class vector_IFormFactorPtr_t(object):
    r"""Proxy of C++ std::vector< IFormFactor * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_IFormFactorPtr_t self) -> SwigPyIterator"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_IFormFactorPtr_t self) -> bool"""
        return _libBornAgainSample.vector_IFormFactorPtr_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_IFormFactorPtr_t self) -> bool"""
        return _libBornAgainSample.vector_IFormFactorPtr_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::size_type"""
        return _libBornAgainSample.vector_IFormFactorPtr_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i, std::vector< IFormFactor * >::difference_type j) -> vector_IFormFactorPtr_t"""
        return _libBornAgainSample.vector_IFormFactorPtr_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i, std::vector< IFormFactor * >::difference_type j)
        __setslice__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i, std::vector< IFormFactor * >::difference_type j, vector_IFormFactorPtr_t v)
        """
        return _libBornAgainSample.vector_IFormFactorPtr_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i, std::vector< IFormFactor * >::difference_type j)"""
        return _libBornAgainSample.vector_IFormFactorPtr_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i)
        __delitem__(vector_IFormFactorPtr_t self, PySliceObject * slice)
        """
        return _libBornAgainSample.vector_IFormFactorPtr_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_IFormFactorPtr_t self, PySliceObject * slice) -> vector_IFormFactorPtr_t
        __getitem__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i) -> IFormFactor
        """
        return _libBornAgainSample.vector_IFormFactorPtr_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_IFormFactorPtr_t self, PySliceObject * slice, vector_IFormFactorPtr_t v)
        __setitem__(vector_IFormFactorPtr_t self, PySliceObject * slice)
        __setitem__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i, IFormFactor x)
        """
        return _libBornAgainSample.vector_IFormFactorPtr_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_IFormFactorPtr_t self) -> IFormFactor"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_pop(self)

    def append(self, x):
        r"""append(vector_IFormFactorPtr_t self, IFormFactor x)"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_append(self, x)

    def empty(self):
        r"""empty(vector_IFormFactorPtr_t self) -> bool"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_empty(self)

    def size(self):
        r"""size(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::size_type"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_size(self)

    def swap(self, v):
        r"""swap(vector_IFormFactorPtr_t self, vector_IFormFactorPtr_t v)"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_swap(self, v)

    def begin(self):
        r"""begin(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::iterator"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_begin(self)

    def end(self):
        r"""end(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::iterator"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::reverse_iterator"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_rbegin(self)

    def rend(self):
        r"""rend(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::reverse_iterator"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_rend(self)

    def clear(self):
        r"""clear(vector_IFormFactorPtr_t self)"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::allocator_type"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_IFormFactorPtr_t self)"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::iterator pos) -> std::vector< IFormFactor * >::iterator
        erase(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::iterator first, std::vector< IFormFactor * >::iterator last) -> std::vector< IFormFactor * >::iterator
        """
        return _libBornAgainSample.vector_IFormFactorPtr_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_IFormFactorPtr_t self) -> vector_IFormFactorPtr_t
        __init__(vector_IFormFactorPtr_t self, vector_IFormFactorPtr_t other) -> vector_IFormFactorPtr_t
        __init__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::size_type size) -> vector_IFormFactorPtr_t
        __init__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::size_type size, IFormFactor value) -> vector_IFormFactorPtr_t
        """
        _libBornAgainSample.vector_IFormFactorPtr_t_swiginit(self, _libBornAgainSample.new_vector_IFormFactorPtr_t(*args))

    def push_back(self, x):
        r"""push_back(vector_IFormFactorPtr_t self, IFormFactor x)"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_push_back(self, x)

    def front(self):
        r"""front(vector_IFormFactorPtr_t self) -> IFormFactor"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_front(self)

    def back(self):
        r"""back(vector_IFormFactorPtr_t self) -> IFormFactor"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::size_type n, IFormFactor x)"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::size_type new_size)
        resize(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::size_type new_size, IFormFactor x)
        """
        return _libBornAgainSample.vector_IFormFactorPtr_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::iterator pos, IFormFactor x) -> std::vector< IFormFactor * >::iterator
        insert(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::iterator pos, std::vector< IFormFactor * >::size_type n, IFormFactor x)
        """
        return _libBornAgainSample.vector_IFormFactorPtr_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::size_type n)"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::size_type"""
        return _libBornAgainSample.vector_IFormFactorPtr_t_capacity(self)
    __swig_destroy__ = _libBornAgainSample.delete_vector_IFormFactorPtr_t

# Register vector_IFormFactorPtr_t in _libBornAgainSample:
_libBornAgainSample.vector_IFormFactorPtr_t_swigregister(vector_IFormFactorPtr_t)

class SampleBuilderFactoryTemp(object):
    r"""Proxy of C++ IFactory< std::string,ISampleBuilder > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def createItem(self, item_key):
        r"""createItem(SampleBuilderFactoryTemp self, std::string const & item_key) -> ISampleBuilder"""
        return _libBornAgainSample.SampleBuilderFactoryTemp_createItem(self, item_key)

    def registerItem(self, item_key, CreateFn):
        r"""registerItem(SampleBuilderFactoryTemp self, std::string const & item_key, IFactory< std::string,ISampleBuilder >::CreateItemCallback CreateFn) -> bool"""
        return _libBornAgainSample.SampleBuilderFactoryTemp_registerItem(self, item_key, CreateFn)

    def contains(self, item_key):
        r"""contains(SampleBuilderFactoryTemp self, std::string const & item_key) -> bool"""
        return _libBornAgainSample.SampleBuilderFactoryTemp_contains(self, item_key)

    def size(self):
        r"""size(SampleBuilderFactoryTemp self) -> size_t"""
        return _libBornAgainSample.SampleBuilderFactoryTemp_size(self)

    def __init__(self):
        r"""__init__(SampleBuilderFactoryTemp self) -> SampleBuilderFactoryTemp"""
        _libBornAgainSample.SampleBuilderFactoryTemp_swiginit(self, _libBornAgainSample.new_SampleBuilderFactoryTemp())
    __swig_destroy__ = _libBornAgainSample.delete_SampleBuilderFactoryTemp

# Register SampleBuilderFactoryTemp in _libBornAgainSample:
_libBornAgainSample.SampleBuilderFactoryTemp_swigregister(SampleBuilderFactoryTemp)

class Material(libBornAgainParam.IComponent):
    r"""


    A wrapper for underlying material implementation

    C++ includes: Material.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, material):
        r"""
        __init__(Material self, Material material) -> Material
        Material::Material(Material &&material)=default

        """
        _libBornAgainSample.Material_swiginit(self, _libBornAgainSample.new_Material(material))

    def inverted(self):
        r"""
        inverted(Material self) -> Material
        Material Material::inverted() const

        Constructs a material with inverted magnetization. 

        """
        return _libBornAgainSample.Material_inverted(self)

    def refractiveIndex(self, wavelength):
        r"""
        refractiveIndex(Material self, double wavelength) -> complex_t
        complex_t Material::refractiveIndex(double wavelength) const

        Returns refractive index. 

        """
        return _libBornAgainSample.Material_refractiveIndex(self, wavelength)

    def refractiveIndex2(self, wavelength):
        r"""
        refractiveIndex2(Material self, double wavelength) -> complex_t
        complex_t Material::refractiveIndex2(double wavelength) const

        Returns squared refractive index. 

        """
        return _libBornAgainSample.Material_refractiveIndex2(self, wavelength)

    def isScalarMaterial(self):
        r"""
        isScalarMaterial(Material self) -> bool
        bool Material::isScalarMaterial() const

        Indicates whether the interaction with the material is scalar. This means that different polarization states will be diffracted equally 

        """
        return _libBornAgainSample.Material_isScalarMaterial(self)

    def isMagneticMaterial(self):
        r"""
        isMagneticMaterial(Material self) -> bool
        bool Material::isMagneticMaterial() const

        """
        return _libBornAgainSample.Material_isMagneticMaterial(self)

    def getName(self):
        r"""
        getName(Material self) -> std::string
        std::string Material::getName() const

        Returns the name of material. 

        """
        return _libBornAgainSample.Material_getName(self)

    def magnetization(self):
        r"""
        magnetization(Material self) -> kvector_t
        kvector_t Material::magnetization() const

        Get the magnetization (in A/m) 

        """
        return _libBornAgainSample.Material_magnetization(self)

    def materialData(self):
        r"""
        materialData(Material self) -> complex_t
        complex_t Material::materialData() const

        Returns underlying material data. The units of returned values are the same as the ones passed to material factory functions 

        """
        return _libBornAgainSample.Material_materialData(self)

    def isEmpty(self):
        r"""
        isEmpty(Material self) -> bool
        bool Material::isEmpty() const

        Returns true if material underlying data is nullptr. 

        """
        return _libBornAgainSample.Material_isEmpty(self)

    def isDefaultMaterial(self):
        r"""
        isDefaultMaterial(Material self) -> bool
        bool Material::isDefaultMaterial() const

        Returns true if material has refractive index of (1.0, 0.0) and zero magnetization. 

        """
        return _libBornAgainSample.Material_isDefaultMaterial(self)

    def scalarSubtrSLD(self, wavevectors):
        r"""
        scalarSubtrSLD(Material self, WavevectorInfo wavevectors) -> complex_t
        complex_t Material::scalarSubtrSLD(const WavevectorInfo &wavevectors) const

        Returns (  $ \\pi/\\lambda^2 $ - sld), sld (in  $nm^{-2}$) being the scattering length density 

        """
        return _libBornAgainSample.Material_scalarSubtrSLD(self, wavevectors)

    def rotatedMaterial(self, transform):
        r"""
        rotatedMaterial(Material self, Transform3D const & transform) -> Material
        Material Material::rotatedMaterial(const Transform3D &transform) const

        """
        return _libBornAgainSample.Material_rotatedMaterial(self, transform)
    __swig_destroy__ = _libBornAgainSample.delete_Material

# Register Material in _libBornAgainSample:
_libBornAgainSample.Material_swigregister(Material)


def HomogeneousMaterial(*args):
    r"""
    HomogeneousMaterial() -> Material
    HomogeneousMaterial(std::string const & name, double delta, double beta, kvector_t magnetization={}) -> Material
    HomogeneousMaterial(std::string const & name, complex_t refractive_index, kvector_t magnetization={}) -> Material
    Material HomogeneousMaterial(const std::string &name, complex_t refractive_index, kvector_t magnetization={})

    Constructs a material with  name,  refractive_index and  magnetization (in A/m). Alternatively,  $\\delta$ and  $\\beta$ for refractive index  $n = 1 - \\delta + i \\beta$ can be passed directly. With no parameters given, constructs default (vacuum) material with  $n = 1$ and zero magnetization. 

    """
    return _libBornAgainSample.HomogeneousMaterial(*args)

def MaterialBySLD(*args):
    r"""
    MaterialBySLD() -> Material
    MaterialBySLD(std::string const & name, double sld_real, double sld_imag, kvector_t magnetization={}) -> Material
    Material MaterialBySLD(const std::string &name, double sld_real, double sld_imag, kvector_t magnetization={})

    Constructs a wavelength-independent material with a given complex-valued scattering length density (SLD). SLD values for a wide variety of materials can be found on https://sld-calculator.appspot.com/ and https://www.ncnr.nist.gov/resources/activation/ By convention, SLD imaginary part is treated as negative by default, which corresponds to attenuation of the signal. With no parameters given, MaterialBySLD constructs default (vacuum) material with zero sld and zero magnetization.

    Parameters:
    -----------

    name: 
    material name

    sld_real: 
    real part of the scattering length density, inverse square angstroms

    sld_imag: 
    imaginary part of the scattering length density, inverse square angstroms

    magnetization: 
    magnetization (in A/m) 

    """
    return _libBornAgainSample.MaterialBySLD(*args)
class WavevectorInfo(object):
    r"""


    Holds all wavevector information relevant for calculating form factors.

    C++ includes: WavevectorInfo.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def GetZeroQ():
        r"""GetZeroQ() -> WavevectorInfo"""
        return _libBornAgainSample.WavevectorInfo_GetZeroQ()

    def __init__(self, *args):
        r"""
        __init__(WavevectorInfo self, cvector_t ki, cvector_t kf, double wavelength) -> WavevectorInfo
        __init__(WavevectorInfo self, kvector_t ki, kvector_t kf, double wavelength) -> WavevectorInfo
        WavevectorInfo::WavevectorInfo(kvector_t ki, kvector_t kf, double wavelength)

        """
        _libBornAgainSample.WavevectorInfo_swiginit(self, _libBornAgainSample.new_WavevectorInfo(*args))

    def transformed(self, transform):
        r"""
        transformed(WavevectorInfo self, Transform3D const & transform) -> WavevectorInfo
        WavevectorInfo WavevectorInfo::transformed(const Transform3D &transform) const

        """
        return _libBornAgainSample.WavevectorInfo_transformed(self, transform)

    def getKi(self):
        r"""
        getKi(WavevectorInfo self) -> cvector_t
        cvector_t WavevectorInfo::getKi() const

        """
        return _libBornAgainSample.WavevectorInfo_getKi(self)

    def getKf(self):
        r"""
        getKf(WavevectorInfo self) -> cvector_t
        cvector_t WavevectorInfo::getKf() const

        """
        return _libBornAgainSample.WavevectorInfo_getKf(self)

    def getQ(self):
        r"""
        getQ(WavevectorInfo self) -> cvector_t
        cvector_t WavevectorInfo::getQ() const

        """
        return _libBornAgainSample.WavevectorInfo_getQ(self)

    def wavelength(self):
        r"""
        wavelength(WavevectorInfo self) -> double
        double WavevectorInfo::wavelength() const

        """
        return _libBornAgainSample.WavevectorInfo_wavelength(self)
    __swig_destroy__ = _libBornAgainSample.delete_WavevectorInfo

# Register WavevectorInfo in _libBornAgainSample:
_libBornAgainSample.WavevectorInfo_swigregister(WavevectorInfo)

def WavevectorInfo_GetZeroQ():
    r"""WavevectorInfo_GetZeroQ() -> WavevectorInfo"""
    return _libBornAgainSample.WavevectorInfo_GetZeroQ()

class SimulationOptions(object):
    r"""


    Collect the different options for simulation.

    SimulationOptions

    C++ includes: SimulationOptions.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(SimulationOptions self) -> SimulationOptions
        SimulationOptions::SimulationOptions()

        """
        _libBornAgainSample.SimulationOptions_swiginit(self, _libBornAgainSample.new_SimulationOptions())

    def isIntegrate(self):
        r"""
        isIntegrate(SimulationOptions self) -> bool
        bool SimulationOptions::isIntegrate() const

        """
        return _libBornAgainSample.SimulationOptions_isIntegrate(self)

    def getMcPoints(self):
        r"""
        getMcPoints(SimulationOptions self) -> size_t
        size_t SimulationOptions::getMcPoints() const

        """
        return _libBornAgainSample.SimulationOptions_getMcPoints(self)

    def setMonteCarloIntegration(self, flag=True, mc_points=50):
        r"""
        setMonteCarloIntegration(SimulationOptions self, bool flag=True, size_t mc_points=50)
        void SimulationOptions::setMonteCarloIntegration(bool flag=true, size_t mc_points=50)

        Enables/disables MonetCarlo integration.

        Parameters:
        -----------

        flag: 
        If true, MonteCarlo integration will be used, otherwise analytical calculations

        mc_points: 
        Number of points for MonteCarlo integrator 

        """
        return _libBornAgainSample.SimulationOptions_setMonteCarloIntegration(self, flag, mc_points)

    def setNumberOfThreads(self, nthreads):
        r"""
        setNumberOfThreads(SimulationOptions self, int nthreads)
        void SimulationOptions::setNumberOfThreads(int nthreads)

        Sets number of threads to use during the simulation (0 - take the default value from the hardware) 

        """
        return _libBornAgainSample.SimulationOptions_setNumberOfThreads(self, nthreads)

    def getNumberOfThreads(self):
        r"""
        getNumberOfThreads(SimulationOptions self) -> unsigned int
        unsigned SimulationOptions::getNumberOfThreads() const

        """
        return _libBornAgainSample.SimulationOptions_getNumberOfThreads(self)

    def setNumberOfBatches(self, nbatches):
        r"""
        setNumberOfBatches(SimulationOptions self, int nbatches)
        void SimulationOptions::setNumberOfBatches(int nbatches)

        Sets number of batches to split. 

        """
        return _libBornAgainSample.SimulationOptions_setNumberOfBatches(self, nbatches)

    def getNumberOfBatches(self):
        r"""
        getNumberOfBatches(SimulationOptions self) -> unsigned int
        unsigned SimulationOptions::getNumberOfBatches() const

        """
        return _libBornAgainSample.SimulationOptions_getNumberOfBatches(self)

    def getCurrentBatch(self):
        r"""
        getCurrentBatch(SimulationOptions self) -> unsigned int
        unsigned SimulationOptions::getCurrentBatch() const

        """
        return _libBornAgainSample.SimulationOptions_getCurrentBatch(self)

    def setThreadInfo(self, thread_info):
        r"""
        setThreadInfo(SimulationOptions self, ThreadInfo const & thread_info)
        void SimulationOptions::setThreadInfo(const ThreadInfo &thread_info)

        Sets the batch and thread information to be used. 

        """
        return _libBornAgainSample.SimulationOptions_setThreadInfo(self, thread_info)

    def getHardwareConcurrency(self):
        r"""
        getHardwareConcurrency(SimulationOptions self) -> unsigned int
        unsigned SimulationOptions::getHardwareConcurrency() const

        """
        return _libBornAgainSample.SimulationOptions_getHardwareConcurrency(self)

    def setIncludeSpecular(self, include_specular):
        r"""
        setIncludeSpecular(SimulationOptions self, bool include_specular)
        void SimulationOptions::setIncludeSpecular(bool include_specular)

        """
        return _libBornAgainSample.SimulationOptions_setIncludeSpecular(self, include_specular)

    def includeSpecular(self):
        r"""
        includeSpecular(SimulationOptions self) -> bool
        bool SimulationOptions::includeSpecular() const

        """
        return _libBornAgainSample.SimulationOptions_includeSpecular(self)

    def setUseAvgMaterials(self, use_avg_materials):
        r"""
        setUseAvgMaterials(SimulationOptions self, bool use_avg_materials)
        void SimulationOptions::setUseAvgMaterials(bool use_avg_materials)

        """
        return _libBornAgainSample.SimulationOptions_setUseAvgMaterials(self, use_avg_materials)

    def useAvgMaterials(self):
        r"""
        useAvgMaterials(SimulationOptions self) -> bool
        bool SimulationOptions::useAvgMaterials() const

        """
        return _libBornAgainSample.SimulationOptions_useAvgMaterials(self)
    __swig_destroy__ = _libBornAgainSample.delete_SimulationOptions

# Register SimulationOptions in _libBornAgainSample:
_libBornAgainSample.SimulationOptions_swigregister(SimulationOptions)

class ISampleNode(libBornAgainBase.ICloneable, libBornAgainParam.INode):
    r"""


    Abstract base class for sample components and properties related to scattering.

    C++ includes: ISampleNode.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(ISampleNode self) -> ISampleNode
        __init__(ISampleNode self, NodeMeta meta, vdouble1d_t PValues) -> ISampleNode
        ISampleNode::ISampleNode(const NodeMeta &meta, const std::vector< double > &PValues)

        """
        if self.__class__ == ISampleNode:
            _self = None
        else:
            _self = self
        _libBornAgainSample.ISampleNode_swiginit(self, _libBornAgainSample.new_ISampleNode(_self, *args))

    def clone(self):
        r"""
        clone(ISampleNode self) -> ISampleNode
        ISampleNode* ISampleNode::clone() const override=0

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.ISampleNode_clone(self)

    def material(self):
        r"""
        material(ISampleNode self) -> Material
        virtual const Material* ISampleNode::material() const

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainSample.ISampleNode_material(self)

    def containedMaterials(self):
        r"""
        containedMaterials(ISampleNode self) -> std::vector< Material const *,std::allocator< Material const * > >
        std::vector< const Material * > ISampleNode::containedMaterials() const

        Returns set of unique materials contained in this  ISampleNode. 

        """
        return _libBornAgainSample.ISampleNode_containedMaterials(self)

    def isMagnetic(self):
        r"""
        isMagnetic(ISampleNode self) -> bool
        bool ISampleNode::isMagnetic() const

        Returns true if there is any magnetic material in this  ISampleNode. 

        """
        return _libBornAgainSample.ISampleNode_isMagnetic(self)
    __swig_destroy__ = _libBornAgainSample.delete_ISampleNode
    def __disown__(self):
        self.this.disown()
        _libBornAgainSample.disown_ISampleNode(self)
        return weakref.proxy(self)

# Register ISampleNode in _libBornAgainSample:
_libBornAgainSample.ISampleNode_swigregister(ISampleNode)

class IFormFactor(ISampleNode):
    r"""


    Abstract base class for all form factors.

    The actual form factor is returned by the complex valued function  IFormFactor::evaluate, which depends on the incoming and outgoing wave vectors ki and kf. If it only depends on the scattering vector q=ki-kf, then it is a  IBornFF.

    C++ includes: IFormFactor.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(IFormFactor self) -> IFormFactor
        __init__(IFormFactor self, NodeMeta meta, vdouble1d_t PValues) -> IFormFactor
        IFormFactor::IFormFactor(const NodeMeta &meta, const std::vector< double > &PValues)

        """
        if self.__class__ == IFormFactor:
            _self = None
        else:
            _self = self
        _libBornAgainSample.IFormFactor_swiginit(self, _libBornAgainSample.new_IFormFactor(_self, *args))
    __swig_destroy__ = _libBornAgainSample.delete_IFormFactor

    def clone(self):
        r"""
        clone(IFormFactor self) -> IFormFactor
        IFormFactor* IFormFactor::clone() const override=0

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.IFormFactor_clone(self)

    def createSlicedFormFactor(self, limits, rot, translation):
        r"""
        createSlicedFormFactor(IFormFactor self, ZLimits limits, IRotation rot, kvector_t translation) -> IFormFactor
        IFormFactor * IFormFactor::createSlicedFormFactor(ZLimits limits, const IRotation &rot, kvector_t translation) const

        Creates a (possibly sliced) form factor with the given rotation and translation. 

        """
        return _libBornAgainSample.IFormFactor_createSlicedFormFactor(self, limits, rot, translation)

    def setAmbientMaterial(self, arg0):
        r"""
        setAmbientMaterial(IFormFactor self, Material arg0)
        virtual void IFormFactor::setAmbientMaterial(const Material &)=0

        Passes the material in which this particle is embedded. 

        """
        return _libBornAgainSample.IFormFactor_setAmbientMaterial(self, arg0)

    def evaluate(self, wavevectors):
        r"""
        evaluate(IFormFactor self, WavevectorInfo wavevectors) -> complex_t
        virtual complex_t IFormFactor::evaluate(const WavevectorInfo &wavevectors) const =0

        Returns scattering amplitude for complex wavevectors ki, kf. 

        """
        return _libBornAgainSample.IFormFactor_evaluate(self, wavevectors)

    def volume(self):
        r"""
        volume(IFormFactor self) -> double
        double IFormFactor::volume() const

        Returns the total volume of the particle of this form factor's shape. 

        """
        return _libBornAgainSample.IFormFactor_volume(self)

    def radialExtension(self):
        r"""
        radialExtension(IFormFactor self) -> double
        virtual double IFormFactor::radialExtension() const =0

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.IFormFactor_radialExtension(self)

    def bottomZ(self, rotation):
        r"""
        bottomZ(IFormFactor self, IRotation rotation) -> double
        virtual double IFormFactor::bottomZ(const IRotation &rotation) const =0

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.IFormFactor_bottomZ(self, rotation)

    def topZ(self, rotation):
        r"""
        topZ(IFormFactor self, IRotation rotation) -> double
        virtual double IFormFactor::topZ(const IRotation &rotation) const =0

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.IFormFactor_topZ(self, rotation)

    def canSliceAnalytically(self, rot):
        r"""canSliceAnalytically(IFormFactor self, IRotation rot) -> bool"""
        return _libBornAgainSample.IFormFactor_canSliceAnalytically(self, rot)

    def sliceFormFactor(self, limits, rot, translation):
        r"""sliceFormFactor(IFormFactor self, ZLimits limits, IRotation rot, kvector_t translation) -> IFormFactor"""
        return _libBornAgainSample.IFormFactor_sliceFormFactor(self, limits, rot, translation)
    def __disown__(self):
        self.this.disown()
        _libBornAgainSample.disown_IFormFactor(self)
        return weakref.proxy(self)

# Register IFormFactor in _libBornAgainSample:
_libBornAgainSample.IFormFactor_swigregister(IFormFactor)

class SlicingEffects(object):
    r"""


    Nested structure that holds slicing effects on position and removed parts.

    C++ includes: IBornFF.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    position = property(_libBornAgainSample.SlicingEffects_position_get, _libBornAgainSample.SlicingEffects_position_set, doc=r"""position : kvector_t""")
    dz_bottom = property(_libBornAgainSample.SlicingEffects_dz_bottom_get, _libBornAgainSample.SlicingEffects_dz_bottom_set, doc=r"""dz_bottom : double""")
    dz_top = property(_libBornAgainSample.SlicingEffects_dz_top_get, _libBornAgainSample.SlicingEffects_dz_top_set, doc=r"""dz_top : double""")

    def __init__(self):
        r"""
        __init__(SlicingEffects self) -> SlicingEffects


        Nested structure that holds slicing effects on position and removed parts.

        C++ includes: IBornFF.h

        """
        _libBornAgainSample.SlicingEffects_swiginit(self, _libBornAgainSample.new_SlicingEffects())
    __swig_destroy__ = _libBornAgainSample.delete_SlicingEffects

# Register SlicingEffects in _libBornAgainSample:
_libBornAgainSample.SlicingEffects_swigregister(SlicingEffects)

class IBornFF(IFormFactor):
    r"""


    Abstract base class for Born form factors.

    In contrast to the generic  IFormFactor, a Born form factor does not depend on the incoming and outgoing wave vectors ki and kf, except through their difference, the scattering vector q=ki-kf.

    C++ includes: IBornFF.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(IBornFF self) -> IBornFF
        __init__(IBornFF self, NodeMeta meta, vdouble1d_t PValues) -> IBornFF
        IBornFF::IBornFF(const NodeMeta &meta, const std::vector< double > &PValues)

        """
        if self.__class__ == IBornFF:
            _self = None
        else:
            _self = self
        _libBornAgainSample.IBornFF_swiginit(self, _libBornAgainSample.new_IBornFF(_self, *args))
    __swig_destroy__ = _libBornAgainSample.delete_IBornFF

    def clone(self):
        r"""
        clone(IBornFF self) -> IBornFF
        IBornFF* IBornFF::clone() const override=0

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.IBornFF_clone(self)

    def setAmbientMaterial(self, arg0):
        r"""
        setAmbientMaterial(IBornFF self, Material arg0)
        void IBornFF::setAmbientMaterial(const Material &) override

        Passes the material in which this particle is embedded. 

        """
        return _libBornAgainSample.IBornFF_setAmbientMaterial(self, arg0)

    def evaluate(self, wavevectors):
        r"""
        evaluate(IBornFF self, WavevectorInfo wavevectors) -> complex_t
        complex_t IBornFF::evaluate(const WavevectorInfo &wavevectors) const override

        Returns scattering amplitude for complex wavevectors ki, kf. 

        """
        return _libBornAgainSample.IBornFF_evaluate(self, wavevectors)

    def bottomZ(self, rotation):
        r"""
        bottomZ(IBornFF self, IRotation rotation) -> double
        double IBornFF::bottomZ(const IRotation &rotation) const override

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.IBornFF_bottomZ(self, rotation)

    def topZ(self, rotation):
        r"""
        topZ(IBornFF self, IRotation rotation) -> double
        double IBornFF::topZ(const IRotation &rotation) const override

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.IBornFF_topZ(self, rotation)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(IBornFF self, cvector_t q) -> complex_t
        virtual complex_t IBornFF::evaluate_for_q(cvector_t q) const =0

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.IBornFF_evaluate_for_q(self, q)

    def canSliceAnalytically(self, rot):
        r"""canSliceAnalytically(IBornFF self, IRotation rot) -> bool"""
        return _libBornAgainSample.IBornFF_canSliceAnalytically(self, rot)
    def __disown__(self):
        self.this.disown()
        _libBornAgainSample.disown_IBornFF(self)
        return weakref.proxy(self)

    def sliceFormFactor(self, limits, rot, translation):
        r"""sliceFormFactor(IBornFF self, ZLimits limits, IRotation rot, kvector_t translation) -> IFormFactor"""
        return _libBornAgainSample.IBornFF_sliceFormFactor(self, limits, rot, translation)

# Register IBornFF in _libBornAgainSample:
_libBornAgainSample.IBornFF_swigregister(IBornFF)

class IFormFactorDecorator(IFormFactor):
    r"""


    Encapsulates another formfactor and adds extra functionality (a scalar factor, a position-dependent phase factor, ...).

    This class is designed according to the Decorator Pattern. It inherits from  IFormFactor and has a member of type IFormFactor*.

    C++ includes: IFormFactorDecorator.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainSample.delete_IFormFactorDecorator

    def clone(self):
        r"""
        clone(IFormFactorDecorator self) -> IFormFactorDecorator
        IFormFactorDecorator* IFormFactorDecorator::clone() const override=0

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.IFormFactorDecorator_clone(self)

    def setAmbientMaterial(self, material):
        r"""
        setAmbientMaterial(IFormFactorDecorator self, Material material)
        void IFormFactorDecorator::setAmbientMaterial(const Material &material) override

        Passes the material in which this particle is embedded. 

        """
        return _libBornAgainSample.IFormFactorDecorator_setAmbientMaterial(self, material)

    def volume(self):
        r"""
        volume(IFormFactorDecorator self) -> double
        double IFormFactorDecorator::volume() const override

        Returns the total volume of the particle of this form factor's shape. 

        """
        return _libBornAgainSample.IFormFactorDecorator_volume(self)

    def radialExtension(self):
        r"""
        radialExtension(IFormFactorDecorator self) -> double
        double IFormFactorDecorator::radialExtension() const override

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.IFormFactorDecorator_radialExtension(self)

    def bottomZ(self, rotation):
        r"""
        bottomZ(IFormFactorDecorator self, IRotation rotation) -> double
        double IFormFactorDecorator::bottomZ(const IRotation &rotation) const override

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.IFormFactorDecorator_bottomZ(self, rotation)

    def topZ(self, rotation):
        r"""
        topZ(IFormFactorDecorator self, IRotation rotation) -> double
        double IFormFactorDecorator::topZ(const IRotation &rotation) const override

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.IFormFactorDecorator_topZ(self, rotation)

    def getFormFactor(self):
        r"""
        getFormFactor(IFormFactorDecorator self) -> IFormFactor
        const IFormFactor* IFormFactorDecorator::getFormFactor() const

        """
        return _libBornAgainSample.IFormFactorDecorator_getFormFactor(self)

# Register IFormFactorDecorator in _libBornAgainSample:
_libBornAgainSample.IFormFactorDecorator_swigregister(IFormFactorDecorator)

class IRotation(libBornAgainBase.ICloneable, libBornAgainParam.INode):
    r"""


    Abstract base class for rotations.

    C++ includes: Rotations.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def createRotation(transform):
        r"""createRotation(Transform3D const & transform) -> IRotation"""
        return _libBornAgainSample.IRotation_createRotation(transform)

    def clone(self):
        r"""
        clone(IRotation self) -> IRotation
        virtual IRotation* IRotation::clone() const =0

        """
        return _libBornAgainSample.IRotation_clone(self)

    def createInverse(self):
        r"""
        createInverse(IRotation self) -> IRotation
        virtual IRotation* IRotation::createInverse() const =0

        Returns a new  IRotation object that is the current object's inverse. 

        """
        return _libBornAgainSample.IRotation_createInverse(self)

    def getTransform3D(self):
        r"""
        getTransform3D(IRotation self) -> Transform3D
        virtual Transform3D IRotation::getTransform3D() const =0

        Returns transformation. 

        """
        return _libBornAgainSample.IRotation_getTransform3D(self)

    def transformed(self, v):
        r"""
        transformed(IRotation self, kvector_t v) -> kvector_t
        kvector_t IRotation::transformed(const kvector_t &v) const

        """
        return _libBornAgainSample.IRotation_transformed(self, v)

    def isIdentity(self):
        r"""
        isIdentity(IRotation self) -> bool
        bool IRotation::isIdentity() const

        Returns true if rotation matrix is identity matrix (no rotations) 

        """
        return _libBornAgainSample.IRotation_isIdentity(self)

    def zInvariant(self):
        r"""
        zInvariant(IRotation self) -> bool
        bool IRotation::zInvariant() const

        """
        return _libBornAgainSample.IRotation_zInvariant(self)
    __swig_destroy__ = _libBornAgainSample.delete_IRotation

# Register IRotation in _libBornAgainSample:
_libBornAgainSample.IRotation_swigregister(IRotation)

def IRotation_createRotation(transform):
    r"""IRotation_createRotation(Transform3D const & transform) -> IRotation"""
    return _libBornAgainSample.IRotation_createRotation(transform)


def createProduct(left, right):
    r"""
    createProduct(IRotation left, IRotation right) -> IRotation
    IRotation* createProduct(const IRotation &left, const IRotation &right)

    Returns concatenated rotation (first right, then left). 

    """
    return _libBornAgainSample.createProduct(left, right)
class IdentityRotation(IRotation):
    r"""


    The identity rotation, which leaves everything in place.

    C++ includes: Rotations.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(IdentityRotation self) -> IdentityRotation
        IdentityRotation::IdentityRotation()

        """
        _libBornAgainSample.IdentityRotation_swiginit(self, _libBornAgainSample.new_IdentityRotation())

    def clone(self):
        r"""
        clone(IdentityRotation self) -> IdentityRotation
        IdentityRotation* IdentityRotation::clone() const

        """
        return _libBornAgainSample.IdentityRotation_clone(self)

    def createInverse(self):
        r"""
        createInverse(IdentityRotation self) -> IdentityRotation
        IdentityRotation* IdentityRotation::createInverse() const

        Returns a new  IRotation object that is the current object's inverse. 

        """
        return _libBornAgainSample.IdentityRotation_createInverse(self)

    def accept(self, visitor):
        r"""
        accept(IdentityRotation self, INodeVisitor * visitor)
        void IdentityRotation::accept(INodeVisitor *visitor) const

        """
        return _libBornAgainSample.IdentityRotation_accept(self, visitor)

    def getTransform3D(self):
        r"""
        getTransform3D(IdentityRotation self) -> Transform3D
        Transform3D IdentityRotation::getTransform3D() const

        Returns transformation. 

        """
        return _libBornAgainSample.IdentityRotation_getTransform3D(self)

    def isIdentity(self):
        r"""
        isIdentity(IdentityRotation self) -> bool
        bool IdentityRotation::isIdentity() const

        Returns true if rotation matrix is identity matrix (no rotations) 

        """
        return _libBornAgainSample.IdentityRotation_isIdentity(self)
    __swig_destroy__ = _libBornAgainSample.delete_IdentityRotation

# Register IdentityRotation in _libBornAgainSample:
_libBornAgainSample.IdentityRotation_swigregister(IdentityRotation)

class RotationX(IRotation):
    r"""


    A rotation about the x axis.

    C++ includes: Rotations.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(RotationX self, vdouble1d_t P) -> RotationX
        __init__(RotationX self, double angle) -> RotationX
        RotationX::RotationX(double angle)

        """
        _libBornAgainSample.RotationX_swiginit(self, _libBornAgainSample.new_RotationX(*args))

    def clone(self):
        r"""
        clone(RotationX self) -> RotationX
        RotationX* RotationX::clone() const

        """
        return _libBornAgainSample.RotationX_clone(self)

    def createInverse(self):
        r"""
        createInverse(RotationX self) -> RotationX
        RotationX* RotationX::createInverse() const

        Returns a new  IRotation object that is the current object's inverse. 

        """
        return _libBornAgainSample.RotationX_createInverse(self)

    def accept(self, visitor):
        r"""
        accept(RotationX self, INodeVisitor * visitor)
        void RotationX::accept(INodeVisitor *visitor) const

        """
        return _libBornAgainSample.RotationX_accept(self, visitor)

    def getAngle(self):
        r"""
        getAngle(RotationX self) -> double
        double RotationX::getAngle() const

        """
        return _libBornAgainSample.RotationX_getAngle(self)

    def getTransform3D(self):
        r"""
        getTransform3D(RotationX self) -> Transform3D
        Transform3D RotationX::getTransform3D() const

        Returns transformation. 

        """
        return _libBornAgainSample.RotationX_getTransform3D(self)
    __swig_destroy__ = _libBornAgainSample.delete_RotationX

# Register RotationX in _libBornAgainSample:
_libBornAgainSample.RotationX_swigregister(RotationX)

class RotationY(IRotation):
    r"""


    A rotation about the y axis.

    C++ includes: Rotations.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(RotationY self, vdouble1d_t P) -> RotationY
        __init__(RotationY self, double angle) -> RotationY
        RotationY::RotationY(double angle)

        """
        _libBornAgainSample.RotationY_swiginit(self, _libBornAgainSample.new_RotationY(*args))

    def clone(self):
        r"""
        clone(RotationY self) -> RotationY
        RotationY* RotationY::clone() const

        """
        return _libBornAgainSample.RotationY_clone(self)

    def createInverse(self):
        r"""
        createInverse(RotationY self) -> RotationY
        RotationY* RotationY::createInverse() const

        Returns a new  IRotation object that is the current object's inverse. 

        """
        return _libBornAgainSample.RotationY_createInverse(self)

    def accept(self, visitor):
        r"""
        accept(RotationY self, INodeVisitor * visitor)
        void RotationY::accept(INodeVisitor *visitor) const

        """
        return _libBornAgainSample.RotationY_accept(self, visitor)

    def getAngle(self):
        r"""
        getAngle(RotationY self) -> double
        double RotationY::getAngle() const

        """
        return _libBornAgainSample.RotationY_getAngle(self)

    def getTransform3D(self):
        r"""
        getTransform3D(RotationY self) -> Transform3D
        Transform3D RotationY::getTransform3D() const

        Returns transformation. 

        """
        return _libBornAgainSample.RotationY_getTransform3D(self)
    __swig_destroy__ = _libBornAgainSample.delete_RotationY

# Register RotationY in _libBornAgainSample:
_libBornAgainSample.RotationY_swigregister(RotationY)

class RotationZ(IRotation):
    r"""


    A rotation about the z axis.

    C++ includes: Rotations.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(RotationZ self, vdouble1d_t P) -> RotationZ
        __init__(RotationZ self, double angle) -> RotationZ
        RotationZ::RotationZ(double angle)

        """
        _libBornAgainSample.RotationZ_swiginit(self, _libBornAgainSample.new_RotationZ(*args))

    def clone(self):
        r"""
        clone(RotationZ self) -> RotationZ
        RotationZ* RotationZ::clone() const

        """
        return _libBornAgainSample.RotationZ_clone(self)

    def createInverse(self):
        r"""
        createInverse(RotationZ self) -> RotationZ
        RotationZ* RotationZ::createInverse() const

        Returns a new  IRotation object that is the current object's inverse. 

        """
        return _libBornAgainSample.RotationZ_createInverse(self)

    def accept(self, visitor):
        r"""
        accept(RotationZ self, INodeVisitor * visitor)
        void RotationZ::accept(INodeVisitor *visitor) const

        """
        return _libBornAgainSample.RotationZ_accept(self, visitor)

    def getAngle(self):
        r"""
        getAngle(RotationZ self) -> double
        double RotationZ::getAngle() const

        """
        return _libBornAgainSample.RotationZ_getAngle(self)

    def getTransform3D(self):
        r"""
        getTransform3D(RotationZ self) -> Transform3D
        Transform3D RotationZ::getTransform3D() const

        Returns transformation. 

        """
        return _libBornAgainSample.RotationZ_getTransform3D(self)
    __swig_destroy__ = _libBornAgainSample.delete_RotationZ

# Register RotationZ in _libBornAgainSample:
_libBornAgainSample.RotationZ_swigregister(RotationZ)

class RotationEuler(IRotation):
    r"""


    A sequence of rotations about the z-x'-z'' axes.

    C++ includes: Rotations.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(RotationEuler self, vdouble1d_t P) -> RotationEuler
        __init__(RotationEuler self, double alpha, double beta, double gamma) -> RotationEuler
        RotationEuler::RotationEuler(double alpha, double beta, double gamma)

        """
        _libBornAgainSample.RotationEuler_swiginit(self, _libBornAgainSample.new_RotationEuler(*args))

    def clone(self):
        r"""
        clone(RotationEuler self) -> RotationEuler
        RotationEuler* RotationEuler::clone() const

        """
        return _libBornAgainSample.RotationEuler_clone(self)

    def createInverse(self):
        r"""
        createInverse(RotationEuler self) -> IRotation
        IRotation * RotationEuler::createInverse() const

        Returns a new  IRotation object that is the current object's inverse. 

        """
        return _libBornAgainSample.RotationEuler_createInverse(self)

    def accept(self, visitor):
        r"""
        accept(RotationEuler self, INodeVisitor * visitor)
        void RotationEuler::accept(INodeVisitor *visitor) const

        """
        return _libBornAgainSample.RotationEuler_accept(self, visitor)

    def getAlpha(self):
        r"""
        getAlpha(RotationEuler self) -> double
        double RotationEuler::getAlpha() const

        """
        return _libBornAgainSample.RotationEuler_getAlpha(self)

    def getBeta(self):
        r"""
        getBeta(RotationEuler self) -> double
        double RotationEuler::getBeta() const

        """
        return _libBornAgainSample.RotationEuler_getBeta(self)

    def getGamma(self):
        r"""
        getGamma(RotationEuler self) -> double
        double RotationEuler::getGamma() const

        """
        return _libBornAgainSample.RotationEuler_getGamma(self)

    def getTransform3D(self):
        r"""
        getTransform3D(RotationEuler self) -> Transform3D
        Transform3D RotationEuler::getTransform3D() const

        Returns transformation. 

        """
        return _libBornAgainSample.RotationEuler_getTransform3D(self)
    __swig_destroy__ = _libBornAgainSample.delete_RotationEuler

# Register RotationEuler in _libBornAgainSample:
_libBornAgainSample.RotationEuler_swigregister(RotationEuler)

class FormFactorCrystal(IFormFactor):
    r"""


    The form factor of a  MesoCrystal.

    C++ includes: FormFactorCrystal.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lattice, basis_form_factor, meso_form_factor, position_variance=0.0):
        r"""
        __init__(FormFactorCrystal self, Lattice3D lattice, IFormFactor basis_form_factor, IFormFactor meso_form_factor, double position_variance=0.0) -> FormFactorCrystal
        FormFactorCrystal::FormFactorCrystal(const Lattice3D &lattice, const IFormFactor &basis_form_factor, const IFormFactor &meso_form_factor, double position_variance=0.0)

        """
        _libBornAgainSample.FormFactorCrystal_swiginit(self, _libBornAgainSample.new_FormFactorCrystal(lattice, basis_form_factor, meso_form_factor, position_variance))
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorCrystal

    def clone(self):
        r"""
        clone(FormFactorCrystal self) -> FormFactorCrystal
        FormFactorCrystal* FormFactorCrystal::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorCrystal_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorCrystal self, INodeVisitor * visitor)
        void FormFactorCrystal::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.FormFactorCrystal_accept(self, visitor)

    def setAmbientMaterial(self, material):
        r"""
        setAmbientMaterial(FormFactorCrystal self, Material material)
        void FormFactorCrystal::setAmbientMaterial(const Material &material) override

        Passes the material in which this particle is embedded. 

        """
        return _libBornAgainSample.FormFactorCrystal_setAmbientMaterial(self, material)

    def volume(self):
        r"""
        volume(FormFactorCrystal self) -> double
        double FormFactorCrystal::volume() const override

        Returns the total volume of the particle of this form factor's shape. 

        """
        return _libBornAgainSample.FormFactorCrystal_volume(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorCrystal self) -> double
        double FormFactorCrystal::radialExtension() const override

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorCrystal_radialExtension(self)

    def bottomZ(self, rotation):
        r"""
        bottomZ(FormFactorCrystal self, IRotation rotation) -> double
        double FormFactorCrystal::bottomZ(const IRotation &rotation) const override

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.FormFactorCrystal_bottomZ(self, rotation)

    def topZ(self, rotation):
        r"""
        topZ(FormFactorCrystal self, IRotation rotation) -> double
        double FormFactorCrystal::topZ(const IRotation &rotation) const override

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.FormFactorCrystal_topZ(self, rotation)

    def evaluate(self, wavevectors):
        r"""
        evaluate(FormFactorCrystal self, WavevectorInfo wavevectors) -> complex_t
        complex_t FormFactorCrystal::evaluate(const WavevectorInfo &wavevectors) const override

        Returns scattering amplitude for complex wavevectors ki, kf. 

        """
        return _libBornAgainSample.FormFactorCrystal_evaluate(self, wavevectors)

# Register FormFactorCrystal in _libBornAgainSample:
_libBornAgainSample.FormFactorCrystal_swigregister(FormFactorCrystal)

class FormFactorWeighted(IFormFactor):
    r"""


    Coherent sum of different scalar  IFormFactors with different weights.

    Used by  ParticleComposition. If same particles are at different positions, then consider FormFactorDecoratorMultiPositionFactor (restore from commit 0500a26de76).

    C++ includes: FormFactorWeighted.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(FormFactorWeighted self) -> FormFactorWeighted
        FormFactorWeighted::FormFactorWeighted()

        """
        _libBornAgainSample.FormFactorWeighted_swiginit(self, _libBornAgainSample.new_FormFactorWeighted())
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorWeighted

    def clone(self):
        r"""
        clone(FormFactorWeighted self) -> FormFactorWeighted
        FormFactorWeighted * FormFactorWeighted::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorWeighted_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorWeighted self, INodeVisitor * visitor)
        void FormFactorWeighted::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.FormFactorWeighted_accept(self, visitor)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorWeighted self) -> double
        double FormFactorWeighted::radialExtension() const override

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorWeighted_radialExtension(self)

    def bottomZ(self, rotation):
        r"""
        bottomZ(FormFactorWeighted self, IRotation rotation) -> double
        double FormFactorWeighted::bottomZ(const IRotation &rotation) const override

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.FormFactorWeighted_bottomZ(self, rotation)

    def topZ(self, rotation):
        r"""
        topZ(FormFactorWeighted self, IRotation rotation) -> double
        double FormFactorWeighted::topZ(const IRotation &rotation) const override

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.FormFactorWeighted_topZ(self, rotation)

    def addFormFactor(self, form_factor, weight=1.0):
        r"""
        addFormFactor(FormFactorWeighted self, IFormFactor form_factor, double weight=1.0)
        void FormFactorWeighted::addFormFactor(const IFormFactor &form_factor, double weight=1.0)

        """
        return _libBornAgainSample.FormFactorWeighted_addFormFactor(self, form_factor, weight)

    def setAmbientMaterial(self, material):
        r"""
        setAmbientMaterial(FormFactorWeighted self, Material material)
        void FormFactorWeighted::setAmbientMaterial(const Material &material) override

        Passes the material in which this particle is embedded. 

        """
        return _libBornAgainSample.FormFactorWeighted_setAmbientMaterial(self, material)

    def evaluate(self, wavevectors):
        r"""
        evaluate(FormFactorWeighted self, WavevectorInfo wavevectors) -> complex_t
        complex_t FormFactorWeighted::evaluate(const WavevectorInfo &wavevectors) const override

        Returns scattering amplitude for complex wavevectors ki, kf. 

        """
        return _libBornAgainSample.FormFactorWeighted_evaluate(self, wavevectors)

# Register FormFactorWeighted in _libBornAgainSample:
_libBornAgainSample.FormFactorWeighted_swigregister(FormFactorWeighted)

class IAbstractParticle(ISampleNode):
    r"""


    Interface for a generic particle.

    Inherited by  IParticle and  ParticleDistribution.

    C++ includes: IAbstractParticle.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainSample.delete_IAbstractParticle

    def clone(self):
        r"""
        clone(IAbstractParticle self) -> IAbstractParticle
        virtual IAbstractParticle* IAbstractParticle::clone() const =0

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.IAbstractParticle_clone(self)

    def accept(self, visitor):
        r"""
        accept(IAbstractParticle self, INodeVisitor * visitor)
        void IAbstractParticle::accept(INodeVisitor *visitor) const

        """
        return _libBornAgainSample.IAbstractParticle_accept(self, visitor)

    def abundance(self):
        r"""
        abundance(IAbstractParticle self) -> double
        double IAbstractParticle::abundance() const

        """
        return _libBornAgainSample.IAbstractParticle_abundance(self)

    def setAbundance(self, abundance):
        r"""
        setAbundance(IAbstractParticle self, double abundance)
        void IAbstractParticle::setAbundance(double abundance)

        Sets particle abundance.

        Parameters:
        -----------

        abundance: 
        proportion of this type of particles normalized to the total number of particles in the layout. 

        """
        return _libBornAgainSample.IAbstractParticle_setAbundance(self, abundance)

    def translate(self, translation):
        r"""
        translate(IAbstractParticle self, kvector_t translation)
        virtual void IAbstractParticle::translate(kvector_t translation)=0

        Translates the particle with the given vector. 

        """
        return _libBornAgainSample.IAbstractParticle_translate(self, translation)

    def rotate(self, rotation):
        r"""
        rotate(IAbstractParticle self, IRotation rotation)
        virtual void IAbstractParticle::rotate(const IRotation &rotation)=0

        Applies the given rotation to the particle. 

        """
        return _libBornAgainSample.IAbstractParticle_rotate(self, rotation)

# Register IAbstractParticle in _libBornAgainSample:
_libBornAgainSample.IAbstractParticle_swigregister(IAbstractParticle)

class Crystal(ISampleNode):
    r"""


    A crystal structure, defined by a Bravais lattice, a basis, and a position variance.

    The basis is either a  Particle or a  ParticleComposition.

    Computations are delegated to class  FormFactorCrystal.

    Used in  MesoCrystal, where it is given an outer shape.

    C++ includes: Crystal.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, basis, lattice, position_variance=0):
        r"""
        __init__(Crystal self, IParticle basis, Lattice3D lattice, double position_variance=0) -> Crystal
        Crystal::Crystal(const IParticle &basis, const Lattice3D &lattice, double position_variance=0)

        """
        _libBornAgainSample.Crystal_swiginit(self, _libBornAgainSample.new_Crystal(basis, lattice, position_variance))
    __swig_destroy__ = _libBornAgainSample.delete_Crystal

    def clone(self):
        r"""
        clone(Crystal self) -> Crystal
        Crystal * Crystal::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.Crystal_clone(self)

    def accept(self, visitor):
        r"""
        accept(Crystal self, INodeVisitor * visitor)
        void Crystal::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.Crystal_accept(self, visitor)

    def createTotalFormFactor(self, meso_crystal_form_factor, p_rotation, translation):
        r"""
        createTotalFormFactor(Crystal self, IFormFactor meso_crystal_form_factor, IRotation p_rotation, kvector_t translation) -> IFormFactor
        IFormFactor * Crystal::createTotalFormFactor(const IFormFactor &meso_crystal_form_factor, const IRotation *p_rotation, const kvector_t &translation) const

        """
        return _libBornAgainSample.Crystal_createTotalFormFactor(self, meso_crystal_form_factor, p_rotation, translation)

    def homogeneousRegions(self):
        r"""
        homogeneousRegions(Crystal self) -> std::vector< HomogeneousRegion,std::allocator< HomogeneousRegion > >
        std::vector< HomogeneousRegion > Crystal::homogeneousRegions() const

        """
        return _libBornAgainSample.Crystal_homogeneousRegions(self)

    def transformedLattice(self, p_rotation=None):
        r"""
        transformedLattice(Crystal self, IRotation p_rotation=None) -> Lattice3D
        Lattice3D Crystal::transformedLattice(const IRotation *p_rotation=nullptr) const

        """
        return _libBornAgainSample.Crystal_transformedLattice(self, p_rotation)

    def getChildren(self):
        r"""
        getChildren(Crystal self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > Crystal::getChildren() const final

        """
        return _libBornAgainSample.Crystal_getChildren(self)

# Register Crystal in _libBornAgainSample:
_libBornAgainSample.Crystal_swigregister(Crystal)

class IParticle(IAbstractParticle):
    r"""


    Abstract base class for  Particle,  ParticleComposition,  ParticleCoreShell,  MesoCrystal. Provides position/rotation and form factor. Abundance is inherited from  IAbstractParticle.

    C++ includes: IParticle.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainSample.delete_IParticle

    def clone(self):
        r"""
        clone(IParticle self) -> IParticle
        IParticle* IParticle::clone() const override=0

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.IParticle_clone(self)

    def createFormFactor(self):
        r"""
        createFormFactor(IParticle self) -> IFormFactor
        IFormFactor * IParticle::createFormFactor() const

        Creates a form factor for this particle. 

        """
        return _libBornAgainSample.IParticle_createFormFactor(self)

    def createSlicedParticle(self, limits):
        r"""
        createSlicedParticle(IParticle self, ZLimits limits) -> SlicedParticle
        SlicedParticle IParticle::createSlicedParticle(ZLimits limits) const

        Creates a sliced form factor for this particle. 

        """
        return _libBornAgainSample.IParticle_createSlicedParticle(self, limits)

    def position(self):
        r"""
        position(IParticle self) -> kvector_t
        kvector_t IParticle::position() const

        Returns particle position. 

        """
        return _libBornAgainSample.IParticle_position(self)

    def setPosition(self, *args):
        r"""
        setPosition(IParticle self, kvector_t position)
        setPosition(IParticle self, double x, double y, double z)
        void IParticle::setPosition(double x, double y, double z)

        Sets relative position of the particle's reference point in the coordinate system of parent.

        Parameters:
        -----------

        x: 
        x-coordinate in nanometers

        y: 
        y-coordinate in nanometers

        z: 
        z-coordinate in nanometers 

        """
        return _libBornAgainSample.IParticle_setPosition(self, *args)

    def translate(self, translation):
        r"""
        translate(IParticle self, kvector_t translation)
        void IParticle::translate(kvector_t translation) final

        Translates the particle. 

        """
        return _libBornAgainSample.IParticle_translate(self, translation)

    def rotation(self):
        r"""
        rotation(IParticle self) -> IRotation
        const IRotation * IParticle::rotation() const

        Returns rotation object. 

        """
        return _libBornAgainSample.IParticle_rotation(self)

    def setRotation(self, rotation):
        r"""
        setRotation(IParticle self, IRotation rotation)
        void IParticle::setRotation(const IRotation &rotation)

        Sets transformation. 

        """
        return _libBornAgainSample.IParticle_setRotation(self, rotation)

    def rotate(self, rotation):
        r"""
        rotate(IParticle self, IRotation rotation)
        void IParticle::rotate(const IRotation &rotation) final

        Rotates the particle. 

        """
        return _libBornAgainSample.IParticle_rotate(self, rotation)

    def getChildren(self):
        r"""
        getChildren(IParticle self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > IParticle::getChildren() const override

        """
        return _libBornAgainSample.IParticle_getChildren(self)

    def registerAbundance(self, make_registered=True):
        r"""
        registerAbundance(IParticle self, bool make_registered=True)
        void IParticle::registerAbundance(bool make_registered=true)

        """
        return _libBornAgainSample.IParticle_registerAbundance(self, make_registered)

    def registerPosition(self, make_registered=True):
        r"""
        registerPosition(IParticle self, bool make_registered=True)
        void IParticle::registerPosition(bool make_registered=true)

        Registers the three components of its position. 

        """
        return _libBornAgainSample.IParticle_registerPosition(self, make_registered)

    def decompose(self):
        r"""
        decompose(IParticle self) -> SafePointerVector< IParticle >
        SafePointerVector< IParticle > IParticle::decompose() const

        Decompose in constituent  IParticle objects. 

        """
        return _libBornAgainSample.IParticle_decompose(self)

    def bottomTopZ(self):
        r"""
        bottomTopZ(IParticle self) -> ParticleLimits
        ParticleLimits IParticle::bottomTopZ() const

        Top and bottom z-coordinate. 

        """
        return _libBornAgainSample.IParticle_bottomTopZ(self)

# Register IParticle in _libBornAgainSample:
_libBornAgainSample.IParticle_swigregister(IParticle)

class MesoCrystal(IParticle):
    r"""


    A particle with an internal structure of smaller particles.

    C++ includes: MesoCrystal.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, particle_structure, form_factor):
        r"""
        __init__(MesoCrystal self, Crystal particle_structure, IFormFactor form_factor) -> MesoCrystal
        MesoCrystal::MesoCrystal(const Crystal &particle_structure, const IFormFactor &form_factor)

        """
        _libBornAgainSample.MesoCrystal_swiginit(self, _libBornAgainSample.new_MesoCrystal(particle_structure, form_factor))
    __swig_destroy__ = _libBornAgainSample.delete_MesoCrystal

    def clone(self):
        r"""
        clone(MesoCrystal self) -> MesoCrystal
        MesoCrystal * MesoCrystal::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.MesoCrystal_clone(self)

    def accept(self, visitor):
        r"""
        accept(MesoCrystal self, INodeVisitor * visitor)
        void MesoCrystal::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.MesoCrystal_accept(self, visitor)

    def createSlicedParticle(self, limits):
        r"""
        createSlicedParticle(MesoCrystal self, ZLimits limits) -> SlicedParticle
        SlicedParticle MesoCrystal::createSlicedParticle(ZLimits limits) const final

        Creates a sliced form factor for this particle. 

        """
        return _libBornAgainSample.MesoCrystal_createSlicedParticle(self, limits)

    def getChildren(self):
        r"""
        getChildren(MesoCrystal self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > MesoCrystal::getChildren() const final

        """
        return _libBornAgainSample.MesoCrystal_getChildren(self)

# Register MesoCrystal in _libBornAgainSample:
_libBornAgainSample.MesoCrystal_swigregister(MesoCrystal)

class Particle(IParticle):
    r"""


    A particle with a form factor and refractive index.

    C++ includes: Particle.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainSample.delete_Particle

    def __init__(self, *args):
        r"""
        __init__(Particle self, Material material) -> Particle
        __init__(Particle self, Material material, IFormFactor form_factor) -> Particle
        __init__(Particle self, Material material, IFormFactor form_factor, IRotation rotation) -> Particle
        Particle::Particle(Material material, const IFormFactor &form_factor, const IRotation &rotation)

        """
        _libBornAgainSample.Particle_swiginit(self, _libBornAgainSample.new_Particle(*args))

    def clone(self):
        r"""
        clone(Particle self) -> Particle
        Particle * Particle::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.Particle_clone(self)

    def accept(self, visitor):
        r"""
        accept(Particle self, INodeVisitor * visitor)
        void Particle::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.Particle_accept(self, visitor)

    def createSlicedParticle(self, limits):
        r"""
        createSlicedParticle(Particle self, ZLimits limits) -> SlicedParticle
        SlicedParticle Particle::createSlicedParticle(ZLimits limits) const final

        Creates a sliced form factor for this particle. 

        """
        return _libBornAgainSample.Particle_createSlicedParticle(self, limits)

    def setMaterial(self, material):
        r"""
        setMaterial(Particle self, Material material)
        void Particle::setMaterial(Material material)

        """
        return _libBornAgainSample.Particle_setMaterial(self, material)

    def material(self):
        r"""
        material(Particle self) -> Material
        const Material* Particle::material() const final

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainSample.Particle_material(self)

    def getChildren(self):
        r"""
        getChildren(Particle self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > Particle::getChildren() const final

        """
        return _libBornAgainSample.Particle_getChildren(self)

# Register Particle in _libBornAgainSample:
_libBornAgainSample.Particle_swigregister(Particle)

class ParticleComposition(IParticle):
    r"""


    A composition of particles at fixed positions

    C++ includes: ParticleComposition.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(ParticleComposition self) -> ParticleComposition
        __init__(ParticleComposition self, IParticle particle, vector_kvector_t positions) -> ParticleComposition
        ParticleComposition::ParticleComposition(const IParticle &particle, std::vector< kvector_t > positions)

        """
        _libBornAgainSample.ParticleComposition_swiginit(self, _libBornAgainSample.new_ParticleComposition(*args))
    __swig_destroy__ = _libBornAgainSample.delete_ParticleComposition

    def clone(self):
        r"""
        clone(ParticleComposition self) -> ParticleComposition
        ParticleComposition * ParticleComposition::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.ParticleComposition_clone(self)

    def accept(self, visitor):
        r"""
        accept(ParticleComposition self, INodeVisitor * visitor)
        void ParticleComposition::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.ParticleComposition_accept(self, visitor)

    def createFormFactor(self):
        r"""
        createFormFactor(ParticleComposition self) -> IFormFactor
        IFormFactor * ParticleComposition::createFormFactor() const final

        Creates a form factor for this particle. 

        """
        return _libBornAgainSample.ParticleComposition_createFormFactor(self)

    def addParticle(self, *args):
        r"""
        addParticle(ParticleComposition self, IParticle particle)
        addParticle(ParticleComposition self, IParticle particle, kvector_t position)
        void ParticleComposition::addParticle(const IParticle &particle, kvector_t position)

        """
        return _libBornAgainSample.ParticleComposition_addParticle(self, *args)

    def addParticles(self, particle, positions):
        r"""
        addParticles(ParticleComposition self, IParticle particle, vector_kvector_t positions)
        void ParticleComposition::addParticles(const IParticle &particle, std::vector< kvector_t > positions)

        """
        return _libBornAgainSample.ParticleComposition_addParticles(self, particle, positions)

    def nbrParticles(self):
        r"""
        nbrParticles(ParticleComposition self) -> size_t
        size_t ParticleComposition::nbrParticles() const

        Returns number of different particles. 

        """
        return _libBornAgainSample.ParticleComposition_nbrParticles(self)

    def getChildren(self):
        r"""
        getChildren(ParticleComposition self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > ParticleComposition::getChildren() const final

        """
        return _libBornAgainSample.ParticleComposition_getChildren(self)

    def decompose(self):
        r"""
        decompose(ParticleComposition self) -> SafePointerVector< IParticle >
        SafePointerVector< IParticle > ParticleComposition::decompose() const final

        Decompose in constituent  IParticle objects. 

        """
        return _libBornAgainSample.ParticleComposition_decompose(self)

    def bottomTopZ(self):
        r"""
        bottomTopZ(ParticleComposition self) -> ParticleLimits
        ParticleLimits ParticleComposition::bottomTopZ() const final

        Top and bottom z-coordinate. 

        """
        return _libBornAgainSample.ParticleComposition_bottomTopZ(self)

# Register ParticleComposition in _libBornAgainSample:
_libBornAgainSample.ParticleComposition_swigregister(ParticleComposition)

class ParticleCoreShell(IParticle):
    r"""


    A particle with a core/shell geometry.

    C++ includes: ParticleCoreShell.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(ParticleCoreShell self, Particle shell, Particle core, kvector_t relative_core_position=kvector_t(0.0, 0.0, 0.0)) -> ParticleCoreShell
        ParticleCoreShell::ParticleCoreShell(const Particle &shell, const Particle &core, kvector_t relative_core_position=kvector_t(0.0, 0.0, 0.0))

        """
        _libBornAgainSample.ParticleCoreShell_swiginit(self, _libBornAgainSample.new_ParticleCoreShell(*args))
    __swig_destroy__ = _libBornAgainSample.delete_ParticleCoreShell

    def clone(self):
        r"""
        clone(ParticleCoreShell self) -> ParticleCoreShell
        ParticleCoreShell * ParticleCoreShell::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.ParticleCoreShell_clone(self)

    def accept(self, visitor):
        r"""
        accept(ParticleCoreShell self, INodeVisitor * visitor)
        void ParticleCoreShell::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.ParticleCoreShell_accept(self, visitor)

    def createSlicedParticle(self, limits):
        r"""
        createSlicedParticle(ParticleCoreShell self, ZLimits limits) -> SlicedParticle
        SlicedParticle ParticleCoreShell::createSlicedParticle(ZLimits limits) const final

        Creates a sliced form factor for this particle. 

        """
        return _libBornAgainSample.ParticleCoreShell_createSlicedParticle(self, limits)

    def coreParticle(self):
        r"""
        coreParticle(ParticleCoreShell self) -> Particle
        const Particle * ParticleCoreShell::coreParticle() const

        """
        return _libBornAgainSample.ParticleCoreShell_coreParticle(self)

    def shellParticle(self):
        r"""
        shellParticle(ParticleCoreShell self) -> Particle
        const Particle * ParticleCoreShell::shellParticle() const

        """
        return _libBornAgainSample.ParticleCoreShell_shellParticle(self)

    def getChildren(self):
        r"""
        getChildren(ParticleCoreShell self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > ParticleCoreShell::getChildren() const final

        """
        return _libBornAgainSample.ParticleCoreShell_getChildren(self)

# Register ParticleCoreShell in _libBornAgainSample:
_libBornAgainSample.ParticleCoreShell_swigregister(ParticleCoreShell)

class ParticleDistribution(IAbstractParticle):
    r"""


    A particle type that is a parametric distribution of  IParticle's.

    C++ includes: ParticleDistribution.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, prototype, par_distr):
        r"""
        __init__(ParticleDistribution self, IParticle prototype, ParameterDistribution par_distr) -> ParticleDistribution
        ParticleDistribution::ParticleDistribution(const IParticle &prototype, const ParameterDistribution &par_distr)

        """
        _libBornAgainSample.ParticleDistribution_swiginit(self, _libBornAgainSample.new_ParticleDistribution(prototype, par_distr))

    def clone(self):
        r"""
        clone(ParticleDistribution self) -> ParticleDistribution
        ParticleDistribution * ParticleDistribution::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.ParticleDistribution_clone(self)

    def accept(self, visitor):
        r"""
        accept(ParticleDistribution self, INodeVisitor * visitor)
        void ParticleDistribution::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.ParticleDistribution_accept(self, visitor)

    def translate(self, translation):
        r"""
        translate(ParticleDistribution self, kvector_t translation)
        void ParticleDistribution::translate(kvector_t translation) final

        Translates the particle with the given vector. 

        """
        return _libBornAgainSample.ParticleDistribution_translate(self, translation)

    def rotate(self, rotation):
        r"""
        rotate(ParticleDistribution self, IRotation rotation)
        void ParticleDistribution::rotate(const IRotation &rotation) final

        Applies the given rotation to the particle. 

        """
        return _libBornAgainSample.ParticleDistribution_rotate(self, rotation)

    def generateParticles(self):
        r"""
        generateParticles(ParticleDistribution self) -> SafePointerVector< IParticle >
        SafePointerVector< IParticle > ParticleDistribution::generateParticles() const

        Returns list of new particles generated according to a distribution.

        Returns particle clones with parameter values drawn from distribution. 

        """
        return _libBornAgainSample.ParticleDistribution_generateParticles(self)

    def prototype(self):
        r"""
        prototype(ParticleDistribution self) -> IParticle
        const IParticle& ParticleDistribution::prototype() const

        Returns the prototype particle, used for generating multiple ones. 

        """
        return _libBornAgainSample.ParticleDistribution_prototype(self)

    def parameterDistribution(self):
        r"""
        parameterDistribution(ParticleDistribution self) -> ParameterDistribution
        ParameterDistribution ParticleDistribution::parameterDistribution() const

        Returns the distributed parameter data. 

        """
        return _libBornAgainSample.ParticleDistribution_parameterDistribution(self)

    def getChildren(self):
        r"""
        getChildren(ParticleDistribution self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > ParticleDistribution::getChildren() const final

        """
        return _libBornAgainSample.ParticleDistribution_getChildren(self)

    def mainUnits(self):
        r"""
        mainUnits(ParticleDistribution self) -> std::string
        std::string ParticleDistribution::mainUnits() const

        """
        return _libBornAgainSample.ParticleDistribution_mainUnits(self)
    __swig_destroy__ = _libBornAgainSample.delete_ParticleDistribution

# Register ParticleDistribution in _libBornAgainSample:
_libBornAgainSample.ParticleDistribution_swigregister(ParticleDistribution)

class IFTDecayFunction1D(libBornAgainBase.ICloneable, libBornAgainParam.INode):
    r"""


    Interface for a one-dimensional decay function, with evaluate(q) returning the Fourier transform, normalized to  $\\int dq\\; {\\rm evaluate}(q) = 1$.

    C++ includes: FTDecay1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        r"""
        clone(IFTDecayFunction1D self) -> IFTDecayFunction1D
        virtual IFTDecayFunction1D* IFTDecayFunction1D::clone() const =0

        """
        return _libBornAgainSample.IFTDecayFunction1D_clone(self)

    def evaluate(self, q):
        r"""
        evaluate(IFTDecayFunction1D self, double q) -> double
        virtual double IFTDecayFunction1D::evaluate(double q) const =0

        """
        return _libBornAgainSample.IFTDecayFunction1D_evaluate(self, q)

    def decayLength(self):
        r"""
        decayLength(IFTDecayFunction1D self) -> double
        double IFTDecayFunction1D::decayLength() const

        """
        return _libBornAgainSample.IFTDecayFunction1D_decayLength(self)
    __swig_destroy__ = _libBornAgainSample.delete_IFTDecayFunction1D

# Register IFTDecayFunction1D in _libBornAgainSample:
_libBornAgainSample.IFTDecayFunction1D_swigregister(IFTDecayFunction1D)

class FTDecayFunction1DCauchy(IFTDecayFunction1D):
    r"""


    One-dimensional Cauchy decay function in reciprocal space; corresponds to exp(-|x|/decay_length) in real space.

    C++ includes: FTDecay1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDecayFunction1DCauchy self, vdouble1d_t P) -> FTDecayFunction1DCauchy
        __init__(FTDecayFunction1DCauchy self, double decay_length) -> FTDecayFunction1DCauchy
        FTDecayFunction1DCauchy::FTDecayFunction1DCauchy(double decay_length)

        """
        _libBornAgainSample.FTDecayFunction1DCauchy_swiginit(self, _libBornAgainSample.new_FTDecayFunction1DCauchy(*args))

    def clone(self):
        r"""
        clone(FTDecayFunction1DCauchy self) -> FTDecayFunction1DCauchy
        FTDecayFunction1DCauchy * FTDecayFunction1DCauchy::clone() const

        """
        return _libBornAgainSample.FTDecayFunction1DCauchy_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDecayFunction1DCauchy self, INodeVisitor * visitor)
        void FTDecayFunction1DCauchy::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDecayFunction1DCauchy_accept(self, visitor)

    def evaluate(self, q):
        r"""
        evaluate(FTDecayFunction1DCauchy self, double q) -> double
        double FTDecayFunction1DCauchy::evaluate(double q) const final

        """
        return _libBornAgainSample.FTDecayFunction1DCauchy_evaluate(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FTDecayFunction1DCauchy

# Register FTDecayFunction1DCauchy in _libBornAgainSample:
_libBornAgainSample.FTDecayFunction1DCauchy_swigregister(FTDecayFunction1DCauchy)

class FTDecayFunction1DGauss(IFTDecayFunction1D):
    r"""


    One-dimensional Gauss decay function in reciprocal space; corresponds to exp[-x^2/(2*decay_length^2)] in real space.

    C++ includes: FTDecay1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDecayFunction1DGauss self, vdouble1d_t P) -> FTDecayFunction1DGauss
        __init__(FTDecayFunction1DGauss self, double decay_length) -> FTDecayFunction1DGauss
        FTDecayFunction1DGauss::FTDecayFunction1DGauss(double decay_length)

        """
        _libBornAgainSample.FTDecayFunction1DGauss_swiginit(self, _libBornAgainSample.new_FTDecayFunction1DGauss(*args))

    def clone(self):
        r"""
        clone(FTDecayFunction1DGauss self) -> FTDecayFunction1DGauss
        FTDecayFunction1DGauss * FTDecayFunction1DGauss::clone() const

        """
        return _libBornAgainSample.FTDecayFunction1DGauss_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDecayFunction1DGauss self, INodeVisitor * visitor)
        void FTDecayFunction1DGauss::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDecayFunction1DGauss_accept(self, visitor)

    def evaluate(self, q):
        r"""
        evaluate(FTDecayFunction1DGauss self, double q) -> double
        double FTDecayFunction1DGauss::evaluate(double q) const final

        """
        return _libBornAgainSample.FTDecayFunction1DGauss_evaluate(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FTDecayFunction1DGauss

# Register FTDecayFunction1DGauss in _libBornAgainSample:
_libBornAgainSample.FTDecayFunction1DGauss_swigregister(FTDecayFunction1DGauss)

class FTDecayFunction1DTriangle(IFTDecayFunction1D):
    r"""


    One-dimensional triangle decay function in reciprocal space; corresponds to 1-|x|/decay_length if |x|<decay_length (and 0 otherwise) in real space.

    C++ includes: FTDecay1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDecayFunction1DTriangle self, vdouble1d_t P) -> FTDecayFunction1DTriangle
        __init__(FTDecayFunction1DTriangle self, double decay_length) -> FTDecayFunction1DTriangle
        FTDecayFunction1DTriangle::FTDecayFunction1DTriangle(double decay_length)

        """
        _libBornAgainSample.FTDecayFunction1DTriangle_swiginit(self, _libBornAgainSample.new_FTDecayFunction1DTriangle(*args))

    def clone(self):
        r"""
        clone(FTDecayFunction1DTriangle self) -> FTDecayFunction1DTriangle
        FTDecayFunction1DTriangle * FTDecayFunction1DTriangle::clone() const

        """
        return _libBornAgainSample.FTDecayFunction1DTriangle_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDecayFunction1DTriangle self, INodeVisitor * visitor)
        void FTDecayFunction1DTriangle::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDecayFunction1DTriangle_accept(self, visitor)

    def evaluate(self, q):
        r"""
        evaluate(FTDecayFunction1DTriangle self, double q) -> double
        double FTDecayFunction1DTriangle::evaluate(double q) const final

        """
        return _libBornAgainSample.FTDecayFunction1DTriangle_evaluate(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FTDecayFunction1DTriangle

# Register FTDecayFunction1DTriangle in _libBornAgainSample:
_libBornAgainSample.FTDecayFunction1DTriangle_swigregister(FTDecayFunction1DTriangle)

class FTDecayFunction1DVoigt(IFTDecayFunction1D):
    r"""


    One-dimensional pseudo-Voigt decay function in reciprocal space; corresponds to eta*Gauss + (1-eta)*Cauchy.

    C++ includes: FTDecay1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDecayFunction1DVoigt self, vdouble1d_t P) -> FTDecayFunction1DVoigt
        __init__(FTDecayFunction1DVoigt self, double decay_length, double eta) -> FTDecayFunction1DVoigt
        FTDecayFunction1DVoigt::FTDecayFunction1DVoigt(double decay_length, double eta)

        """
        _libBornAgainSample.FTDecayFunction1DVoigt_swiginit(self, _libBornAgainSample.new_FTDecayFunction1DVoigt(*args))

    def clone(self):
        r"""
        clone(FTDecayFunction1DVoigt self) -> FTDecayFunction1DVoigt
        FTDecayFunction1DVoigt * FTDecayFunction1DVoigt::clone() const

        """
        return _libBornAgainSample.FTDecayFunction1DVoigt_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDecayFunction1DVoigt self, INodeVisitor * visitor)
        void FTDecayFunction1DVoigt::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDecayFunction1DVoigt_accept(self, visitor)

    def evaluate(self, q):
        r"""
        evaluate(FTDecayFunction1DVoigt self, double q) -> double
        double FTDecayFunction1DVoigt::evaluate(double q) const final

        """
        return _libBornAgainSample.FTDecayFunction1DVoigt_evaluate(self, q)

    def eEta(self):
        r"""
        eEta(FTDecayFunction1DVoigt self) -> double
        double FTDecayFunction1DVoigt::eEta() const

        """
        return _libBornAgainSample.FTDecayFunction1DVoigt_eEta(self)
    __swig_destroy__ = _libBornAgainSample.delete_FTDecayFunction1DVoigt

# Register FTDecayFunction1DVoigt in _libBornAgainSample:
_libBornAgainSample.FTDecayFunction1DVoigt_swigregister(FTDecayFunction1DVoigt)

class IFTDecayFunction2D(libBornAgainBase.ICloneable, libBornAgainParam.INode):
    r"""


    Interface for two-dimensional decay function in reciprocal space.

    C++ includes: FTDecay2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        r"""
        clone(IFTDecayFunction2D self) -> IFTDecayFunction2D
        virtual IFTDecayFunction2D* IFTDecayFunction2D::clone() const =0

        """
        return _libBornAgainSample.IFTDecayFunction2D_clone(self)

    def decayLengthX(self):
        r"""
        decayLengthX(IFTDecayFunction2D self) -> double
        double IFTDecayFunction2D::decayLengthX() const

        get decay length in distribution's X-direction 

        """
        return _libBornAgainSample.IFTDecayFunction2D_decayLengthX(self)

    def decayLengthY(self):
        r"""
        decayLengthY(IFTDecayFunction2D self) -> double
        double IFTDecayFunction2D::decayLengthY() const

        get decay length in distribution's Y-direction 

        """
        return _libBornAgainSample.IFTDecayFunction2D_decayLengthY(self)

    def gamma(self):
        r"""
        gamma(IFTDecayFunction2D self) -> double
        double IFTDecayFunction2D::gamma() const

        get angle between first lattice vector and X-axis of distribution (both in direct space) 

        """
        return _libBornAgainSample.IFTDecayFunction2D_gamma(self)

    def evaluate(self, qx, qy):
        r"""
        evaluate(IFTDecayFunction2D self, double qx, double qy) -> double
        virtual double IFTDecayFunction2D::evaluate(double qx, double qy) const =0

        evaluate Fourier transformed decay function for q in X,Y coordinates 

        """
        return _libBornAgainSample.IFTDecayFunction2D_evaluate(self, qx, qy)

    def boundingReciprocalLatticeCoordinates(self, qX, qY, a, b, alpha):
        r"""
        boundingReciprocalLatticeCoordinates(IFTDecayFunction2D self, double qX, double qY, double a, double b, double alpha) -> pvacuum_double_t
        std::pair< double, double > IFTDecayFunction2D::boundingReciprocalLatticeCoordinates(double qX, double qY, double a, double b, double alpha) const

        transform back to a*, b* basis:

        Calculates bounding values of reciprocal lattice coordinates that contain the centered rectangle with a corner defined by qX and qY 

        """
        return _libBornAgainSample.IFTDecayFunction2D_boundingReciprocalLatticeCoordinates(self, qX, qY, a, b, alpha)
    __swig_destroy__ = _libBornAgainSample.delete_IFTDecayFunction2D

# Register IFTDecayFunction2D in _libBornAgainSample:
_libBornAgainSample.IFTDecayFunction2D_swigregister(IFTDecayFunction2D)

class FTDecayFunction2DCauchy(IFTDecayFunction2D):
    r"""


    Two-dimensional Cauchy decay function in reciprocal space; corresponds to exp(-r) in real space, with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDecay2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDecayFunction2DCauchy self, vdouble1d_t P) -> FTDecayFunction2DCauchy
        __init__(FTDecayFunction2DCauchy self, double decay_length_x, double decay_length_y, double gamma) -> FTDecayFunction2DCauchy
        FTDecayFunction2DCauchy::FTDecayFunction2DCauchy(double decay_length_x, double decay_length_y, double gamma)

        """
        _libBornAgainSample.FTDecayFunction2DCauchy_swiginit(self, _libBornAgainSample.new_FTDecayFunction2DCauchy(*args))

    def clone(self):
        r"""
        clone(FTDecayFunction2DCauchy self) -> FTDecayFunction2DCauchy
        FTDecayFunction2DCauchy * FTDecayFunction2DCauchy::clone() const

        """
        return _libBornAgainSample.FTDecayFunction2DCauchy_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDecayFunction2DCauchy self, INodeVisitor * visitor)
        void FTDecayFunction2DCauchy::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDecayFunction2DCauchy_accept(self, visitor)

    def evaluate(self, qx, qy):
        r"""
        evaluate(FTDecayFunction2DCauchy self, double qx, double qy) -> double
        double FTDecayFunction2DCauchy::evaluate(double qx, double qy) const final

        evaluate Fourier transformed decay function for q in X,Y coordinates 

        """
        return _libBornAgainSample.FTDecayFunction2DCauchy_evaluate(self, qx, qy)
    __swig_destroy__ = _libBornAgainSample.delete_FTDecayFunction2DCauchy

# Register FTDecayFunction2DCauchy in _libBornAgainSample:
_libBornAgainSample.FTDecayFunction2DCauchy_swigregister(FTDecayFunction2DCauchy)

class FTDecayFunction2DGauss(IFTDecayFunction2D):
    r"""


    Two-dimensional Gauss decay function in reciprocal space; corresponds to exp(-r^2/2) in real space, with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDecay2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDecayFunction2DGauss self, vdouble1d_t P) -> FTDecayFunction2DGauss
        __init__(FTDecayFunction2DGauss self, double decay_length_x, double decay_length_y, double gamma) -> FTDecayFunction2DGauss
        FTDecayFunction2DGauss::FTDecayFunction2DGauss(double decay_length_x, double decay_length_y, double gamma)

        """
        _libBornAgainSample.FTDecayFunction2DGauss_swiginit(self, _libBornAgainSample.new_FTDecayFunction2DGauss(*args))

    def clone(self):
        r"""
        clone(FTDecayFunction2DGauss self) -> FTDecayFunction2DGauss
        FTDecayFunction2DGauss * FTDecayFunction2DGauss::clone() const

        """
        return _libBornAgainSample.FTDecayFunction2DGauss_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDecayFunction2DGauss self, INodeVisitor * visitor)
        void FTDecayFunction2DGauss::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDecayFunction2DGauss_accept(self, visitor)

    def evaluate(self, qx, qy):
        r"""
        evaluate(FTDecayFunction2DGauss self, double qx, double qy) -> double
        double FTDecayFunction2DGauss::evaluate(double qx, double qy) const final

        evaluate Fourier transformed decay function for q in X,Y coordinates 

        """
        return _libBornAgainSample.FTDecayFunction2DGauss_evaluate(self, qx, qy)
    __swig_destroy__ = _libBornAgainSample.delete_FTDecayFunction2DGauss

# Register FTDecayFunction2DGauss in _libBornAgainSample:
_libBornAgainSample.FTDecayFunction2DGauss_swigregister(FTDecayFunction2DGauss)

class FTDecayFunction2DVoigt(IFTDecayFunction2D):
    r"""


    Two-dimensional pseudo-Voigt decay function in reciprocal space; corresponds to eta*Gauss + (1-eta)*Cauchy.

    C++ includes: FTDecay2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDecayFunction2DVoigt self, vdouble1d_t P) -> FTDecayFunction2DVoigt
        __init__(FTDecayFunction2DVoigt self, double decay_length_x, double decay_length_y, double gamma, double eta) -> FTDecayFunction2DVoigt
        FTDecayFunction2DVoigt::FTDecayFunction2DVoigt(double decay_length_x, double decay_length_y, double gamma, double eta)

        """
        _libBornAgainSample.FTDecayFunction2DVoigt_swiginit(self, _libBornAgainSample.new_FTDecayFunction2DVoigt(*args))

    def clone(self):
        r"""
        clone(FTDecayFunction2DVoigt self) -> FTDecayFunction2DVoigt
        FTDecayFunction2DVoigt * FTDecayFunction2DVoigt::clone() const

        """
        return _libBornAgainSample.FTDecayFunction2DVoigt_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDecayFunction2DVoigt self, INodeVisitor * visitor)
        void FTDecayFunction2DVoigt::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDecayFunction2DVoigt_accept(self, visitor)

    def evaluate(self, qx, qy):
        r"""
        evaluate(FTDecayFunction2DVoigt self, double qx, double qy) -> double
        double FTDecayFunction2DVoigt::evaluate(double qx, double qy) const final

        evaluate Fourier transformed decay function for q in X,Y coordinates 

        """
        return _libBornAgainSample.FTDecayFunction2DVoigt_evaluate(self, qx, qy)

    def eta(self):
        r"""
        eta(FTDecayFunction2DVoigt self) -> double
        double FTDecayFunction2DVoigt::eta() const

        """
        return _libBornAgainSample.FTDecayFunction2DVoigt_eta(self)
    __swig_destroy__ = _libBornAgainSample.delete_FTDecayFunction2DVoigt

# Register FTDecayFunction2DVoigt in _libBornAgainSample:
_libBornAgainSample.FTDecayFunction2DVoigt_swigregister(FTDecayFunction2DVoigt)

class IFTDistribution1D(libBornAgainBase.ICloneable, libBornAgainParam.INode):
    r"""


    Interface for a one-dimensional distribution, with normalization adjusted so that the Fourier transform evaluate(q) is a decay function that starts at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        r"""
        clone(IFTDistribution1D self) -> IFTDistribution1D
        virtual IFTDistribution1D* IFTDistribution1D::clone() const =0

        """
        return _libBornAgainSample.IFTDistribution1D_clone(self)

    def evaluate(self, q):
        r"""
        evaluate(IFTDistribution1D self, double q) -> double
        virtual double IFTDistribution1D::evaluate(double q) const =0

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainSample.IFTDistribution1D_evaluate(self, q)

    def omega(self):
        r"""
        omega(IFTDistribution1D self) -> double
        double IFTDistribution1D::omega() const

        """
        return _libBornAgainSample.IFTDistribution1D_omega(self)

    def qSecondDerivative(self):
        r"""
        qSecondDerivative(IFTDistribution1D self) -> double
        virtual double IFTDistribution1D::qSecondDerivative() const =0

        Returns the negative of the second order derivative in q space around q=0. 

        """
        return _libBornAgainSample.IFTDistribution1D_qSecondDerivative(self)
    __swig_destroy__ = _libBornAgainSample.delete_IFTDistribution1D

# Register IFTDistribution1D in _libBornAgainSample:
_libBornAgainSample.IFTDistribution1D_swigregister(IFTDistribution1D)

class FTDistribution1DCauchy(IFTDistribution1D):
    r"""


    Exponential  IFTDistribution1D exp(-|omega*x|); its Fourier transform evaluate(q) is a Cauchy-Lorentzian starting at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDistribution1DCauchy self, vdouble1d_t P) -> FTDistribution1DCauchy
        __init__(FTDistribution1DCauchy self, double omega) -> FTDistribution1DCauchy
        FTDistribution1DCauchy::FTDistribution1DCauchy(double omega)

        """
        _libBornAgainSample.FTDistribution1DCauchy_swiginit(self, _libBornAgainSample.new_FTDistribution1DCauchy(*args))

    def clone(self):
        r"""
        clone(FTDistribution1DCauchy self) -> FTDistribution1DCauchy
        FTDistribution1DCauchy * FTDistribution1DCauchy::clone() const final

        """
        return _libBornAgainSample.FTDistribution1DCauchy_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDistribution1DCauchy self, INodeVisitor * visitor)
        void FTDistribution1DCauchy::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDistribution1DCauchy_accept(self, visitor)

    def evaluate(self, q):
        r"""
        evaluate(FTDistribution1DCauchy self, double q) -> double
        double FTDistribution1DCauchy::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainSample.FTDistribution1DCauchy_evaluate(self, q)

    def qSecondDerivative(self):
        r"""
        qSecondDerivative(FTDistribution1DCauchy self) -> double
        double FTDistribution1DCauchy::qSecondDerivative() const final

        Returns the negative of the second order derivative in q space around q=0. 

        """
        return _libBornAgainSample.FTDistribution1DCauchy_qSecondDerivative(self)
    __swig_destroy__ = _libBornAgainSample.delete_FTDistribution1DCauchy

# Register FTDistribution1DCauchy in _libBornAgainSample:
_libBornAgainSample.FTDistribution1DCauchy_swigregister(FTDistribution1DCauchy)

class FTDistribution1DGauss(IFTDistribution1D):
    r"""


    Gaussian  IFTDistribution1D; its Fourier transform evaluate(q) is a Gaussian starting at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDistribution1DGauss self, vdouble1d_t P) -> FTDistribution1DGauss
        __init__(FTDistribution1DGauss self, double omega) -> FTDistribution1DGauss
        FTDistribution1DGauss::FTDistribution1DGauss(double omega)

        """
        _libBornAgainSample.FTDistribution1DGauss_swiginit(self, _libBornAgainSample.new_FTDistribution1DGauss(*args))

    def clone(self):
        r"""
        clone(FTDistribution1DGauss self) -> FTDistribution1DGauss
        FTDistribution1DGauss * FTDistribution1DGauss::clone() const final

        """
        return _libBornAgainSample.FTDistribution1DGauss_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDistribution1DGauss self, INodeVisitor * visitor)
        void FTDistribution1DGauss::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDistribution1DGauss_accept(self, visitor)

    def evaluate(self, q):
        r"""
        evaluate(FTDistribution1DGauss self, double q) -> double
        double FTDistribution1DGauss::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainSample.FTDistribution1DGauss_evaluate(self, q)

    def qSecondDerivative(self):
        r"""
        qSecondDerivative(FTDistribution1DGauss self) -> double
        double FTDistribution1DGauss::qSecondDerivative() const final

        Returns the negative of the second order derivative in q space around q=0. 

        """
        return _libBornAgainSample.FTDistribution1DGauss_qSecondDerivative(self)
    __swig_destroy__ = _libBornAgainSample.delete_FTDistribution1DGauss

# Register FTDistribution1DGauss in _libBornAgainSample:
_libBornAgainSample.FTDistribution1DGauss_swigregister(FTDistribution1DGauss)

class FTDistribution1DGate(IFTDistribution1D):
    r"""


    Square gate  IFTDistribution1D; its Fourier transform evaluate(q) is a sinc function starting at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDistribution1DGate self, vdouble1d_t P) -> FTDistribution1DGate
        __init__(FTDistribution1DGate self, double omega) -> FTDistribution1DGate
        FTDistribution1DGate::FTDistribution1DGate(double omega)

        """
        _libBornAgainSample.FTDistribution1DGate_swiginit(self, _libBornAgainSample.new_FTDistribution1DGate(*args))

    def clone(self):
        r"""
        clone(FTDistribution1DGate self) -> FTDistribution1DGate
        FTDistribution1DGate * FTDistribution1DGate::clone() const final

        """
        return _libBornAgainSample.FTDistribution1DGate_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDistribution1DGate self, INodeVisitor * visitor)
        void FTDistribution1DGate::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDistribution1DGate_accept(self, visitor)

    def evaluate(self, q):
        r"""
        evaluate(FTDistribution1DGate self, double q) -> double
        double FTDistribution1DGate::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainSample.FTDistribution1DGate_evaluate(self, q)

    def qSecondDerivative(self):
        r"""
        qSecondDerivative(FTDistribution1DGate self) -> double
        double FTDistribution1DGate::qSecondDerivative() const final

        Returns the negative of the second order derivative in q space around q=0. 

        """
        return _libBornAgainSample.FTDistribution1DGate_qSecondDerivative(self)
    __swig_destroy__ = _libBornAgainSample.delete_FTDistribution1DGate

# Register FTDistribution1DGate in _libBornAgainSample:
_libBornAgainSample.FTDistribution1DGate_swigregister(FTDistribution1DGate)

class FTDistribution1DTriangle(IFTDistribution1D):
    r"""


    Triangle  IFTDistribution1D [1-|x|/omega if |x|<omega, and 0 otherwise]; its Fourier transform evaluate(q) is a squared sinc function starting at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDistribution1DTriangle self, vdouble1d_t P) -> FTDistribution1DTriangle
        __init__(FTDistribution1DTriangle self, double omega) -> FTDistribution1DTriangle
        FTDistribution1DTriangle::FTDistribution1DTriangle(double omega)

        """
        _libBornAgainSample.FTDistribution1DTriangle_swiginit(self, _libBornAgainSample.new_FTDistribution1DTriangle(*args))

    def clone(self):
        r"""
        clone(FTDistribution1DTriangle self) -> FTDistribution1DTriangle
        FTDistribution1DTriangle * FTDistribution1DTriangle::clone() const final

        """
        return _libBornAgainSample.FTDistribution1DTriangle_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDistribution1DTriangle self, INodeVisitor * visitor)
        void FTDistribution1DTriangle::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDistribution1DTriangle_accept(self, visitor)

    def evaluate(self, q):
        r"""
        evaluate(FTDistribution1DTriangle self, double q) -> double
        double FTDistribution1DTriangle::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainSample.FTDistribution1DTriangle_evaluate(self, q)

    def qSecondDerivative(self):
        r"""
        qSecondDerivative(FTDistribution1DTriangle self) -> double
        double FTDistribution1DTriangle::qSecondDerivative() const final

        Returns the negative of the second order derivative in q space around q=0. 

        """
        return _libBornAgainSample.FTDistribution1DTriangle_qSecondDerivative(self)
    __swig_destroy__ = _libBornAgainSample.delete_FTDistribution1DTriangle

# Register FTDistribution1DTriangle in _libBornAgainSample:
_libBornAgainSample.FTDistribution1DTriangle_swigregister(FTDistribution1DTriangle)

class FTDistribution1DCosine(IFTDistribution1D):
    r"""


    IFTDistribution1D consisting of one cosine wave [1+cos(pi*x/omega) if |x|<omega, and 0 otherwise]; its Fourier transform evaluate(q) starts at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDistribution1DCosine self, vdouble1d_t P) -> FTDistribution1DCosine
        __init__(FTDistribution1DCosine self, double omega) -> FTDistribution1DCosine
        FTDistribution1DCosine::FTDistribution1DCosine(double omega)

        """
        _libBornAgainSample.FTDistribution1DCosine_swiginit(self, _libBornAgainSample.new_FTDistribution1DCosine(*args))

    def clone(self):
        r"""
        clone(FTDistribution1DCosine self) -> FTDistribution1DCosine
        FTDistribution1DCosine * FTDistribution1DCosine::clone() const final

        """
        return _libBornAgainSample.FTDistribution1DCosine_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDistribution1DCosine self, INodeVisitor * visitor)
        void FTDistribution1DCosine::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDistribution1DCosine_accept(self, visitor)

    def evaluate(self, q):
        r"""
        evaluate(FTDistribution1DCosine self, double q) -> double
        double FTDistribution1DCosine::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainSample.FTDistribution1DCosine_evaluate(self, q)

    def qSecondDerivative(self):
        r"""
        qSecondDerivative(FTDistribution1DCosine self) -> double
        double FTDistribution1DCosine::qSecondDerivative() const final

        Returns the negative of the second order derivative in q space around q=0. 

        """
        return _libBornAgainSample.FTDistribution1DCosine_qSecondDerivative(self)
    __swig_destroy__ = _libBornAgainSample.delete_FTDistribution1DCosine

# Register FTDistribution1DCosine in _libBornAgainSample:
_libBornAgainSample.FTDistribution1DCosine_swigregister(FTDistribution1DCosine)

class FTDistribution1DVoigt(IFTDistribution1D):
    r"""


    IFTDistribution1D that provides a Fourier transform evaluate(q) in form of a pseudo-Voigt decay function eta*Gauss + (1-eta)*Cauchy, with both components starting at 1 for q=0.

    C++ includes: FTDistributions1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDistribution1DVoigt self, vdouble1d_t P) -> FTDistribution1DVoigt
        __init__(FTDistribution1DVoigt self, double omega, double eta) -> FTDistribution1DVoigt
        FTDistribution1DVoigt::FTDistribution1DVoigt(double omega, double eta)

        """
        _libBornAgainSample.FTDistribution1DVoigt_swiginit(self, _libBornAgainSample.new_FTDistribution1DVoigt(*args))

    def clone(self):
        r"""
        clone(FTDistribution1DVoigt self) -> FTDistribution1DVoigt
        FTDistribution1DVoigt * FTDistribution1DVoigt::clone() const final

        """
        return _libBornAgainSample.FTDistribution1DVoigt_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDistribution1DVoigt self, INodeVisitor * visitor)
        void FTDistribution1DVoigt::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDistribution1DVoigt_accept(self, visitor)

    def evaluate(self, q):
        r"""
        evaluate(FTDistribution1DVoigt self, double q) -> double
        double FTDistribution1DVoigt::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainSample.FTDistribution1DVoigt_evaluate(self, q)

    def eta(self):
        r"""
        eta(FTDistribution1DVoigt self) -> double
        double FTDistribution1DVoigt::eta() const

        """
        return _libBornAgainSample.FTDistribution1DVoigt_eta(self)

    def qSecondDerivative(self):
        r"""
        qSecondDerivative(FTDistribution1DVoigt self) -> double
        double FTDistribution1DVoigt::qSecondDerivative() const final

        Returns the negative of the second order derivative in q space around q=0. 

        """
        return _libBornAgainSample.FTDistribution1DVoigt_qSecondDerivative(self)
    __swig_destroy__ = _libBornAgainSample.delete_FTDistribution1DVoigt

# Register FTDistribution1DVoigt in _libBornAgainSample:
_libBornAgainSample.FTDistribution1DVoigt_swigregister(FTDistribution1DVoigt)

class IFTDistribution2D(libBornAgainBase.ICloneable, libBornAgainParam.INode):
    r"""


    Interface for two-dimensional distributions in Fourier space.

    C++ includes: FTDistributions2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        r"""
        clone(IFTDistribution2D self) -> IFTDistribution2D
        IFTDistribution2D* IFTDistribution2D::clone() const =0

        """
        return _libBornAgainSample.IFTDistribution2D_clone(self)

    def omegaX(self):
        r"""
        omegaX(IFTDistribution2D self) -> double
        double IFTDistribution2D::omegaX() const

        """
        return _libBornAgainSample.IFTDistribution2D_omegaX(self)

    def omegaY(self):
        r"""
        omegaY(IFTDistribution2D self) -> double
        double IFTDistribution2D::omegaY() const

        """
        return _libBornAgainSample.IFTDistribution2D_omegaY(self)

    def gamma(self):
        r"""
        gamma(IFTDistribution2D self) -> double
        double IFTDistribution2D::gamma() const

        """
        return _libBornAgainSample.IFTDistribution2D_gamma(self)

    def delta(self):
        r"""
        delta(IFTDistribution2D self) -> double
        double IFTDistribution2D::delta() const

        Angle in direct space between X- and Y-axis of distribution. 

        """
        return _libBornAgainSample.IFTDistribution2D_delta(self)

    def evaluate(self, qx, qy):
        r"""
        evaluate(IFTDistribution2D self, double qx, double qy) -> double
        virtual double IFTDistribution2D::evaluate(double qx, double qy) const =0

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainSample.IFTDistribution2D_evaluate(self, qx, qy)
    __swig_destroy__ = _libBornAgainSample.delete_IFTDistribution2D

# Register IFTDistribution2D in _libBornAgainSample:
_libBornAgainSample.IFTDistribution2D_swigregister(IFTDistribution2D)

class FTDistribution2DCauchy(IFTDistribution2D):
    r"""


    Two-dimensional Cauchy distribution in Fourier space; corresponds to a normalized exp(-r) in real space, with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDistributions2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDistribution2DCauchy self, vdouble1d_t P) -> FTDistribution2DCauchy
        __init__(FTDistribution2DCauchy self, double omega_x, double omega_y, double gamma) -> FTDistribution2DCauchy
        FTDistribution2DCauchy::FTDistribution2DCauchy(double omega_x, double omega_y, double gamma)

        """
        _libBornAgainSample.FTDistribution2DCauchy_swiginit(self, _libBornAgainSample.new_FTDistribution2DCauchy(*args))

    def clone(self):
        r"""
        clone(FTDistribution2DCauchy self) -> FTDistribution2DCauchy
        FTDistribution2DCauchy * FTDistribution2DCauchy::clone() const final

        """
        return _libBornAgainSample.FTDistribution2DCauchy_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDistribution2DCauchy self, INodeVisitor * visitor)
        void FTDistribution2DCauchy::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDistribution2DCauchy_accept(self, visitor)

    def evaluate(self, qx, qy):
        r"""
        evaluate(FTDistribution2DCauchy self, double qx, double qy) -> double
        double FTDistribution2DCauchy::evaluate(double qx, double qy) const final

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainSample.FTDistribution2DCauchy_evaluate(self, qx, qy)
    __swig_destroy__ = _libBornAgainSample.delete_FTDistribution2DCauchy

# Register FTDistribution2DCauchy in _libBornAgainSample:
_libBornAgainSample.FTDistribution2DCauchy_swigregister(FTDistribution2DCauchy)

class FTDistribution2DGauss(IFTDistribution2D):
    r"""


    Two-dimensional Gauss distribution in Fourier space; corresponds to normalized exp(-r^2/2) in real space with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDistributions2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDistribution2DGauss self, vdouble1d_t P) -> FTDistribution2DGauss
        __init__(FTDistribution2DGauss self, double omega_x, double omega_y, double gamma) -> FTDistribution2DGauss
        FTDistribution2DGauss::FTDistribution2DGauss(double omega_x, double omega_y, double gamma)

        """
        _libBornAgainSample.FTDistribution2DGauss_swiginit(self, _libBornAgainSample.new_FTDistribution2DGauss(*args))

    def clone(self):
        r"""
        clone(FTDistribution2DGauss self) -> FTDistribution2DGauss
        FTDistribution2DGauss * FTDistribution2DGauss::clone() const final

        """
        return _libBornAgainSample.FTDistribution2DGauss_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDistribution2DGauss self, INodeVisitor * visitor)
        void FTDistribution2DGauss::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDistribution2DGauss_accept(self, visitor)

    def evaluate(self, qx, qy):
        r"""
        evaluate(FTDistribution2DGauss self, double qx, double qy) -> double
        double FTDistribution2DGauss::evaluate(double qx, double qy) const final

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainSample.FTDistribution2DGauss_evaluate(self, qx, qy)
    __swig_destroy__ = _libBornAgainSample.delete_FTDistribution2DGauss

# Register FTDistribution2DGauss in _libBornAgainSample:
_libBornAgainSample.FTDistribution2DGauss_swigregister(FTDistribution2DGauss)

class FTDistribution2DGate(IFTDistribution2D):
    r"""


    Two-dimensional gate distribution in Fourier space; corresponds to normalized constant if r<1 (and 0 otherwise) in real space, with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDistributions2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDistribution2DGate self, vdouble1d_t P) -> FTDistribution2DGate
        __init__(FTDistribution2DGate self, double omega_x, double omega_y, double gamma) -> FTDistribution2DGate
        FTDistribution2DGate::FTDistribution2DGate(double omega_x, double omega_y, double gamma)

        """
        _libBornAgainSample.FTDistribution2DGate_swiginit(self, _libBornAgainSample.new_FTDistribution2DGate(*args))

    def clone(self):
        r"""
        clone(FTDistribution2DGate self) -> FTDistribution2DGate
        FTDistribution2DGate * FTDistribution2DGate::clone() const final

        """
        return _libBornAgainSample.FTDistribution2DGate_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDistribution2DGate self, INodeVisitor * visitor)
        void FTDistribution2DGate::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDistribution2DGate_accept(self, visitor)

    def evaluate(self, qx, qy):
        r"""
        evaluate(FTDistribution2DGate self, double qx, double qy) -> double
        double FTDistribution2DGate::evaluate(double qx, double qy) const final

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainSample.FTDistribution2DGate_evaluate(self, qx, qy)
    __swig_destroy__ = _libBornAgainSample.delete_FTDistribution2DGate

# Register FTDistribution2DGate in _libBornAgainSample:
_libBornAgainSample.FTDistribution2DGate_swigregister(FTDistribution2DGate)

class FTDistribution2DCone(IFTDistribution2D):
    r"""


    Two-dimensional cone distribution in Fourier space; corresponds to 1-r if r<1 (and 0 otherwise) in real space with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDistributions2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDistribution2DCone self, vdouble1d_t P) -> FTDistribution2DCone
        __init__(FTDistribution2DCone self, double omega_x, double omega_y, double gamma) -> FTDistribution2DCone
        FTDistribution2DCone::FTDistribution2DCone(double omega_x, double omega_y, double gamma)

        """
        _libBornAgainSample.FTDistribution2DCone_swiginit(self, _libBornAgainSample.new_FTDistribution2DCone(*args))

    def clone(self):
        r"""
        clone(FTDistribution2DCone self) -> FTDistribution2DCone
        FTDistribution2DCone * FTDistribution2DCone::clone() const final

        """
        return _libBornAgainSample.FTDistribution2DCone_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDistribution2DCone self, INodeVisitor * visitor)
        void FTDistribution2DCone::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDistribution2DCone_accept(self, visitor)

    def evaluate(self, qx, qy):
        r"""
        evaluate(FTDistribution2DCone self, double qx, double qy) -> double
        double FTDistribution2DCone::evaluate(double qx, double qy) const final

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainSample.FTDistribution2DCone_evaluate(self, qx, qy)
    __swig_destroy__ = _libBornAgainSample.delete_FTDistribution2DCone

# Register FTDistribution2DCone in _libBornAgainSample:
_libBornAgainSample.FTDistribution2DCone_swigregister(FTDistribution2DCone)

class FTDistribution2DVoigt(IFTDistribution2D):
    r"""


    Two-dimensional Voigt distribution in Fourier space; corresponds to eta*Gauss + (1-eta)*Cauchy

    C++ includes: FTDistributions2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FTDistribution2DVoigt self, vdouble1d_t P) -> FTDistribution2DVoigt
        __init__(FTDistribution2DVoigt self, double omega_x, double omega_y, double gamma, double eta) -> FTDistribution2DVoigt
        FTDistribution2DVoigt::FTDistribution2DVoigt(double omega_x, double omega_y, double gamma, double eta)

        """
        _libBornAgainSample.FTDistribution2DVoigt_swiginit(self, _libBornAgainSample.new_FTDistribution2DVoigt(*args))

    def clone(self):
        r"""
        clone(FTDistribution2DVoigt self) -> FTDistribution2DVoigt
        FTDistribution2DVoigt * FTDistribution2DVoigt::clone() const final

        """
        return _libBornAgainSample.FTDistribution2DVoigt_clone(self)

    def accept(self, visitor):
        r"""
        accept(FTDistribution2DVoigt self, INodeVisitor * visitor)
        void FTDistribution2DVoigt::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FTDistribution2DVoigt_accept(self, visitor)

    def evaluate(self, qx, qy):
        r"""
        evaluate(FTDistribution2DVoigt self, double qx, double qy) -> double
        double FTDistribution2DVoigt::evaluate(double qx, double qy) const final

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainSample.FTDistribution2DVoigt_evaluate(self, qx, qy)

    def eta(self):
        r"""
        eta(FTDistribution2DVoigt self) -> double
        double FTDistribution2DVoigt::eta() const

        """
        return _libBornAgainSample.FTDistribution2DVoigt_eta(self)
    __swig_destroy__ = _libBornAgainSample.delete_FTDistribution2DVoigt

# Register FTDistribution2DVoigt in _libBornAgainSample:
_libBornAgainSample.FTDistribution2DVoigt_swigregister(FTDistribution2DVoigt)

class IPeakShape(ISampleNode):
    r"""


    Abstract base class class that defines the peak shape of a Bragg peak.

    C++ includes: IPeakShape.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainSample.delete_IPeakShape

    def clone(self):
        r"""
        clone(IPeakShape self) -> IPeakShape
        virtual IPeakShape* IPeakShape::clone() const =0

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.IPeakShape_clone(self)

    def evaluate(self, q, q_lattice_point):
        r"""
        evaluate(IPeakShape self, kvector_t q, kvector_t q_lattice_point) -> double
        virtual double IPeakShape::evaluate(const kvector_t q, const kvector_t q_lattice_point) const =0

        Evaluates the peak shape at q from a reciprocal lattice point at q_lattice_point. 

        """
        return _libBornAgainSample.IPeakShape_evaluate(self, q, q_lattice_point)

    def angularDisorder(self):
        r"""
        angularDisorder(IPeakShape self) -> bool
        virtual bool IPeakShape::angularDisorder() const

        Indicates if the peak shape encodes angular disorder, in which case all peaks in a spherical shell are needed 

        """
        return _libBornAgainSample.IPeakShape_angularDisorder(self)

# Register IPeakShape in _libBornAgainSample:
_libBornAgainSample.IPeakShape_swigregister(IPeakShape)

class IsotropicGaussPeakShape(IPeakShape):
    r"""


    Class that implements an isotropic Gaussian peak shape of a Bragg peak.

    C++ includes: IPeakShape.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, max_intensity, domainsize):
        r"""
        __init__(IsotropicGaussPeakShape self, double max_intensity, double domainsize) -> IsotropicGaussPeakShape
        IsotropicGaussPeakShape::IsotropicGaussPeakShape(double max_intensity, double domainsize)

        """
        _libBornAgainSample.IsotropicGaussPeakShape_swiginit(self, _libBornAgainSample.new_IsotropicGaussPeakShape(max_intensity, domainsize))
    __swig_destroy__ = _libBornAgainSample.delete_IsotropicGaussPeakShape

    def clone(self):
        r"""
        clone(IsotropicGaussPeakShape self) -> IsotropicGaussPeakShape
        IsotropicGaussPeakShape * IsotropicGaussPeakShape::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.IsotropicGaussPeakShape_clone(self)

    def accept(self, visitor):
        r"""
        accept(IsotropicGaussPeakShape self, INodeVisitor * visitor)
        void IsotropicGaussPeakShape::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.IsotropicGaussPeakShape_accept(self, visitor)

    def evaluate(self, q, q_lattice_point):
        r"""
        evaluate(IsotropicGaussPeakShape self, kvector_t q, kvector_t q_lattice_point) -> double
        double IsotropicGaussPeakShape::evaluate(const kvector_t q, const kvector_t q_lattice_point) const override

        Evaluates the peak shape at q from a reciprocal lattice point at q_lattice_point. 

        """
        return _libBornAgainSample.IsotropicGaussPeakShape_evaluate(self, q, q_lattice_point)

# Register IsotropicGaussPeakShape in _libBornAgainSample:
_libBornAgainSample.IsotropicGaussPeakShape_swigregister(IsotropicGaussPeakShape)

class IsotropicLorentzPeakShape(IPeakShape):
    r"""


    An isotropic Lorentzian peak shape of a Bragg peak.

    C++ includes: IPeakShape.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, max_intensity, domainsize):
        r"""
        __init__(IsotropicLorentzPeakShape self, double max_intensity, double domainsize) -> IsotropicLorentzPeakShape
        IsotropicLorentzPeakShape::IsotropicLorentzPeakShape(double max_intensity, double domainsize)

        """
        _libBornAgainSample.IsotropicLorentzPeakShape_swiginit(self, _libBornAgainSample.new_IsotropicLorentzPeakShape(max_intensity, domainsize))
    __swig_destroy__ = _libBornAgainSample.delete_IsotropicLorentzPeakShape

    def clone(self):
        r"""
        clone(IsotropicLorentzPeakShape self) -> IsotropicLorentzPeakShape
        IsotropicLorentzPeakShape * IsotropicLorentzPeakShape::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.IsotropicLorentzPeakShape_clone(self)

    def accept(self, visitor):
        r"""
        accept(IsotropicLorentzPeakShape self, INodeVisitor * visitor)
        void IsotropicLorentzPeakShape::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.IsotropicLorentzPeakShape_accept(self, visitor)

    def evaluate(self, q, q_lattice_point):
        r"""
        evaluate(IsotropicLorentzPeakShape self, kvector_t q, kvector_t q_lattice_point) -> double
        double IsotropicLorentzPeakShape::evaluate(const kvector_t q, const kvector_t q_lattice_point) const override

        Evaluates the peak shape at q from a reciprocal lattice point at q_lattice_point. 

        """
        return _libBornAgainSample.IsotropicLorentzPeakShape_evaluate(self, q, q_lattice_point)

# Register IsotropicLorentzPeakShape in _libBornAgainSample:
_libBornAgainSample.IsotropicLorentzPeakShape_swigregister(IsotropicLorentzPeakShape)

class GaussFisherPeakShape(IPeakShape):
    r"""


    A peak shape that is Gaussian in the radial direction and uses the Mises-Fisher distribution in the angular direction.

    C++ includes: IPeakShape.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, max_intensity, radial_size, kappa):
        r"""
        __init__(GaussFisherPeakShape self, double max_intensity, double radial_size, double kappa) -> GaussFisherPeakShape
        GaussFisherPeakShape::GaussFisherPeakShape(double max_intensity, double radial_size, double kappa)

        """
        _libBornAgainSample.GaussFisherPeakShape_swiginit(self, _libBornAgainSample.new_GaussFisherPeakShape(max_intensity, radial_size, kappa))
    __swig_destroy__ = _libBornAgainSample.delete_GaussFisherPeakShape

    def clone(self):
        r"""
        clone(GaussFisherPeakShape self) -> GaussFisherPeakShape
        GaussFisherPeakShape * GaussFisherPeakShape::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.GaussFisherPeakShape_clone(self)

    def accept(self, visitor):
        r"""
        accept(GaussFisherPeakShape self, INodeVisitor * visitor)
        void GaussFisherPeakShape::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.GaussFisherPeakShape_accept(self, visitor)

    def evaluate(self, q, q_lattice_point):
        r"""
        evaluate(GaussFisherPeakShape self, kvector_t q, kvector_t q_lattice_point) -> double
        double GaussFisherPeakShape::evaluate(const kvector_t q, const kvector_t q_lattice_point) const override

        Evaluates the peak shape at q from a reciprocal lattice point at q_lattice_point. 

        """
        return _libBornAgainSample.GaussFisherPeakShape_evaluate(self, q, q_lattice_point)

    def angularDisorder(self):
        r"""
        angularDisorder(GaussFisherPeakShape self) -> bool
        bool GaussFisherPeakShape::angularDisorder() const override

        Indicates if the peak shape encodes angular disorder, in which case all peaks in a spherical shell are needed 

        """
        return _libBornAgainSample.GaussFisherPeakShape_angularDisorder(self)

# Register GaussFisherPeakShape in _libBornAgainSample:
_libBornAgainSample.GaussFisherPeakShape_swigregister(GaussFisherPeakShape)

class LorentzFisherPeakShape(IPeakShape):
    r"""


    A peak shape that is Lorentzian in the radial direction and uses the Mises-Fisher distribution in the angular direction.

    C++ includes: IPeakShape.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, max_intensity, radial_size, kappa):
        r"""
        __init__(LorentzFisherPeakShape self, double max_intensity, double radial_size, double kappa) -> LorentzFisherPeakShape
        LorentzFisherPeakShape::LorentzFisherPeakShape(double max_intensity, double radial_size, double kappa)

        """
        _libBornAgainSample.LorentzFisherPeakShape_swiginit(self, _libBornAgainSample.new_LorentzFisherPeakShape(max_intensity, radial_size, kappa))
    __swig_destroy__ = _libBornAgainSample.delete_LorentzFisherPeakShape

    def clone(self):
        r"""
        clone(LorentzFisherPeakShape self) -> LorentzFisherPeakShape
        LorentzFisherPeakShape * LorentzFisherPeakShape::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.LorentzFisherPeakShape_clone(self)

    def accept(self, visitor):
        r"""
        accept(LorentzFisherPeakShape self, INodeVisitor * visitor)
        void LorentzFisherPeakShape::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.LorentzFisherPeakShape_accept(self, visitor)

    def evaluate(self, q, q_lattice_point):
        r"""
        evaluate(LorentzFisherPeakShape self, kvector_t q, kvector_t q_lattice_point) -> double
        double LorentzFisherPeakShape::evaluate(const kvector_t q, const kvector_t q_lattice_point) const override

        Evaluates the peak shape at q from a reciprocal lattice point at q_lattice_point. 

        """
        return _libBornAgainSample.LorentzFisherPeakShape_evaluate(self, q, q_lattice_point)

    def angularDisorder(self):
        r"""
        angularDisorder(LorentzFisherPeakShape self) -> bool
        bool LorentzFisherPeakShape::angularDisorder() const override

        Indicates if the peak shape encodes angular disorder, in which case all peaks in a spherical shell are needed 

        """
        return _libBornAgainSample.LorentzFisherPeakShape_angularDisorder(self)

# Register LorentzFisherPeakShape in _libBornAgainSample:
_libBornAgainSample.LorentzFisherPeakShape_swigregister(LorentzFisherPeakShape)

class MisesFisherGaussPeakShape(IPeakShape):
    r"""


    A peak shape that is Gaussian in the radial direction and a convolution of a Mises-Fisher distribution with a Mises distribution on the two-sphere.

    C++ includes: IPeakShape.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, max_intensity, radial_size, zenith, kappa_1, kappa_2):
        r"""
        __init__(MisesFisherGaussPeakShape self, double max_intensity, double radial_size, kvector_t zenith, double kappa_1, double kappa_2) -> MisesFisherGaussPeakShape
        MisesFisherGaussPeakShape::MisesFisherGaussPeakShape(double max_intensity, double radial_size, kvector_t zenith, double kappa_1, double kappa_2)

        """
        _libBornAgainSample.MisesFisherGaussPeakShape_swiginit(self, _libBornAgainSample.new_MisesFisherGaussPeakShape(max_intensity, radial_size, zenith, kappa_1, kappa_2))
    __swig_destroy__ = _libBornAgainSample.delete_MisesFisherGaussPeakShape

    def clone(self):
        r"""
        clone(MisesFisherGaussPeakShape self) -> MisesFisherGaussPeakShape
        MisesFisherGaussPeakShape * MisesFisherGaussPeakShape::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.MisesFisherGaussPeakShape_clone(self)

    def accept(self, visitor):
        r"""
        accept(MisesFisherGaussPeakShape self, INodeVisitor * visitor)
        void MisesFisherGaussPeakShape::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.MisesFisherGaussPeakShape_accept(self, visitor)

    def evaluate(self, q, q_lattice_point):
        r"""
        evaluate(MisesFisherGaussPeakShape self, kvector_t q, kvector_t q_lattice_point) -> double
        double MisesFisherGaussPeakShape::evaluate(const kvector_t q, const kvector_t q_lattice_point) const override

        Evaluates the peak shape at q from a reciprocal lattice point at q_lattice_point. 

        """
        return _libBornAgainSample.MisesFisherGaussPeakShape_evaluate(self, q, q_lattice_point)

    def angularDisorder(self):
        r"""
        angularDisorder(MisesFisherGaussPeakShape self) -> bool
        bool MisesFisherGaussPeakShape::angularDisorder() const override

        Indicates if the peak shape encodes angular disorder, in which case all peaks in a spherical shell are needed 

        """
        return _libBornAgainSample.MisesFisherGaussPeakShape_angularDisorder(self)

# Register MisesFisherGaussPeakShape in _libBornAgainSample:
_libBornAgainSample.MisesFisherGaussPeakShape_swigregister(MisesFisherGaussPeakShape)

class MisesGaussPeakShape(IPeakShape):
    r"""


    A peak shape that is a convolution of a Mises-Fisher distribution with a 3d Gaussian.

    C++ includes: IPeakShape.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, max_intensity, radial_size, zenith, kappa):
        r"""
        __init__(MisesGaussPeakShape self, double max_intensity, double radial_size, kvector_t zenith, double kappa) -> MisesGaussPeakShape
        MisesGaussPeakShape::MisesGaussPeakShape(double max_intensity, double radial_size, kvector_t zenith, double kappa)

        """
        _libBornAgainSample.MisesGaussPeakShape_swiginit(self, _libBornAgainSample.new_MisesGaussPeakShape(max_intensity, radial_size, zenith, kappa))
    __swig_destroy__ = _libBornAgainSample.delete_MisesGaussPeakShape

    def clone(self):
        r"""
        clone(MisesGaussPeakShape self) -> MisesGaussPeakShape
        MisesGaussPeakShape * MisesGaussPeakShape::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.MisesGaussPeakShape_clone(self)

    def accept(self, visitor):
        r"""
        accept(MisesGaussPeakShape self, INodeVisitor * visitor)
        void MisesGaussPeakShape::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.MisesGaussPeakShape_accept(self, visitor)

    def evaluate(self, q, q_lattice_point):
        r"""
        evaluate(MisesGaussPeakShape self, kvector_t q, kvector_t q_lattice_point) -> double
        double MisesGaussPeakShape::evaluate(const kvector_t q, const kvector_t q_lattice_point) const override

        Evaluates the peak shape at q from a reciprocal lattice point at q_lattice_point. 

        """
        return _libBornAgainSample.MisesGaussPeakShape_evaluate(self, q, q_lattice_point)

    def angularDisorder(self):
        r"""
        angularDisorder(MisesGaussPeakShape self) -> bool
        bool MisesGaussPeakShape::angularDisorder() const override

        Indicates if the peak shape encodes angular disorder, in which case all peaks in a spherical shell are needed 

        """
        return _libBornAgainSample.MisesGaussPeakShape_angularDisorder(self)

# Register MisesGaussPeakShape in _libBornAgainSample:
_libBornAgainSample.MisesGaussPeakShape_swigregister(MisesGaussPeakShape)

class IInterferenceFunction(ISampleNode):
    r"""


    Abstract base class of interference functions.

    C++ includes: IInterferenceFunction.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        r"""
        clone(IInterferenceFunction self) -> IInterferenceFunction
        virtual IInterferenceFunction* IInterferenceFunction::clone() const =0

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.IInterferenceFunction_clone(self)

    def evaluate(self, q, outer_iff=1.0):
        r"""
        evaluate(IInterferenceFunction self, kvector_t q, double outer_iff=1.0) -> double
        double IInterferenceFunction::evaluate(const kvector_t q, double outer_iff=1.0) const

        Evaluates the interference function for a given wavevector transfer. 

        """
        return _libBornAgainSample.IInterferenceFunction_evaluate(self, q, outer_iff)

    def setPositionVariance(self, var):
        r"""
        setPositionVariance(IInterferenceFunction self, double var)
        void IInterferenceFunction::setPositionVariance(double var)

        Sets the variance of the position for the calculation of the DW factor It is defined as the variance in each relevant dimension 

        """
        return _libBornAgainSample.IInterferenceFunction_setPositionVariance(self, var)

    def positionVariance(self):
        r"""
        positionVariance(IInterferenceFunction self) -> double
        double IInterferenceFunction::positionVariance() const

        Returns the position variance. 

        """
        return _libBornAgainSample.IInterferenceFunction_positionVariance(self)

    def getParticleDensity(self):
        r"""
        getParticleDensity(IInterferenceFunction self) -> double
        virtual double IInterferenceFunction::getParticleDensity() const

        If defined by this interference function's parameters, returns the particle density (per area). Otherwise, returns zero or a user-defined value 

        """
        return _libBornAgainSample.IInterferenceFunction_getParticleDensity(self)

    def supportsMultilayer(self):
        r"""
        supportsMultilayer(IInterferenceFunction self) -> bool
        virtual bool IInterferenceFunction::supportsMultilayer() const

        Indicates if this interference function can be used with a multilayer (DWBA mode) 

        """
        return _libBornAgainSample.IInterferenceFunction_supportsMultilayer(self)

    def DWfactor(self, q):
        r"""
        DWfactor(IInterferenceFunction self, kvector_t q) -> double
        double IInterferenceFunction::DWfactor(kvector_t q) const

        Evaluates the Debye-Waller factor for a given wavevector transfer. 

        """
        return _libBornAgainSample.IInterferenceFunction_DWfactor(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_IInterferenceFunction

# Register IInterferenceFunction in _libBornAgainSample:
_libBornAgainSample.IInterferenceFunction_swigregister(IInterferenceFunction)

class InterferenceFunction1DLattice(IInterferenceFunction):
    r"""


    Interference function of a 1D lattice.

    C++ includes: InterferenceFunction1DLattice.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length, xi):
        r"""
        __init__(InterferenceFunction1DLattice self, double length, double xi) -> InterferenceFunction1DLattice
        InterferenceFunction1DLattice::InterferenceFunction1DLattice(double length, double xi)

        Constructor of interference function of one-dimensional lattice.

        Parameters:
        -----------

        length: 
        lattice constant in nanometers

        xi: 
        rotation of lattice with respect to x-axis in radians 

        """
        _libBornAgainSample.InterferenceFunction1DLattice_swiginit(self, _libBornAgainSample.new_InterferenceFunction1DLattice(length, xi))
    __swig_destroy__ = _libBornAgainSample.delete_InterferenceFunction1DLattice

    def clone(self):
        r"""
        clone(InterferenceFunction1DLattice self) -> InterferenceFunction1DLattice
        InterferenceFunction1DLattice * InterferenceFunction1DLattice::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.InterferenceFunction1DLattice_clone(self)

    def accept(self, visitor):
        r"""
        accept(InterferenceFunction1DLattice self, INodeVisitor * visitor)
        void InterferenceFunction1DLattice::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.InterferenceFunction1DLattice_accept(self, visitor)

    def setDecayFunction(self, decay):
        r"""
        setDecayFunction(InterferenceFunction1DLattice self, IFTDecayFunction1D decay)
        void InterferenceFunction1DLattice::setDecayFunction(const IFTDecayFunction1D &decay)

        Sets one-dimensional decay function.

        Parameters:
        -----------

        decay: 
        one-dimensional decay function in reciprocal space 

        """
        return _libBornAgainSample.InterferenceFunction1DLattice_setDecayFunction(self, decay)

    def getLength(self):
        r"""
        getLength(InterferenceFunction1DLattice self) -> double
        double InterferenceFunction1DLattice::getLength() const

        """
        return _libBornAgainSample.InterferenceFunction1DLattice_getLength(self)

    def getXi(self):
        r"""
        getXi(InterferenceFunction1DLattice self) -> double
        double InterferenceFunction1DLattice::getXi() const

        """
        return _libBornAgainSample.InterferenceFunction1DLattice_getXi(self)

    def getChildren(self):
        r"""
        getChildren(InterferenceFunction1DLattice self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > InterferenceFunction1DLattice::getChildren() const override

        """
        return _libBornAgainSample.InterferenceFunction1DLattice_getChildren(self)

# Register InterferenceFunction1DLattice in _libBornAgainSample:
_libBornAgainSample.InterferenceFunction1DLattice_swigregister(InterferenceFunction1DLattice)

class InterferenceFunction2DLattice(IInterferenceFunction):
    r"""


    Interference function of a 2D lattice.

    C++ includes: InterferenceFunction2DLattice.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lattice):
        r"""
        __init__(InterferenceFunction2DLattice self, Lattice2D lattice) -> InterferenceFunction2DLattice
        InterferenceFunction2DLattice::InterferenceFunction2DLattice(const Lattice2D &lattice)

        """
        _libBornAgainSample.InterferenceFunction2DLattice_swiginit(self, _libBornAgainSample.new_InterferenceFunction2DLattice(lattice))
    __swig_destroy__ = _libBornAgainSample.delete_InterferenceFunction2DLattice

    def clone(self):
        r"""
        clone(InterferenceFunction2DLattice self) -> InterferenceFunction2DLattice
        InterferenceFunction2DLattice * InterferenceFunction2DLattice::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.InterferenceFunction2DLattice_clone(self)

    def accept(self, visitor):
        r"""
        accept(InterferenceFunction2DLattice self, INodeVisitor * visitor)
        void InterferenceFunction2DLattice::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.InterferenceFunction2DLattice_accept(self, visitor)

    def setDecayFunction(self, decay):
        r"""
        setDecayFunction(InterferenceFunction2DLattice self, IFTDecayFunction2D decay)
        void InterferenceFunction2DLattice::setDecayFunction(const IFTDecayFunction2D &decay)

        Sets two-dimensional decay function.

        Parameters:
        -----------

        decay: 
        two-dimensional decay function in reciprocal space 

        """
        return _libBornAgainSample.InterferenceFunction2DLattice_setDecayFunction(self, decay)

    def setIntegrationOverXi(self, integrate_xi):
        r"""
        setIntegrationOverXi(InterferenceFunction2DLattice self, bool integrate_xi)
        void InterferenceFunction2DLattice::setIntegrationOverXi(bool integrate_xi)

        """
        return _libBornAgainSample.InterferenceFunction2DLattice_setIntegrationOverXi(self, integrate_xi)

    def integrationOverXi(self):
        r"""
        integrationOverXi(InterferenceFunction2DLattice self) -> bool
        bool InterferenceFunction2DLattice::integrationOverXi() const

        """
        return _libBornAgainSample.InterferenceFunction2DLattice_integrationOverXi(self)

    def lattice(self):
        r"""
        lattice(InterferenceFunction2DLattice self) -> Lattice2D
        const Lattice2D & InterferenceFunction2DLattice::lattice() const

        """
        return _libBornAgainSample.InterferenceFunction2DLattice_lattice(self)

    def getParticleDensity(self):
        r"""
        getParticleDensity(InterferenceFunction2DLattice self) -> double
        double InterferenceFunction2DLattice::getParticleDensity() const override

        Returns the particle density associated with this 2d lattice. 

        """
        return _libBornAgainSample.InterferenceFunction2DLattice_getParticleDensity(self)

    def getChildren(self):
        r"""
        getChildren(InterferenceFunction2DLattice self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > InterferenceFunction2DLattice::getChildren() const override

        """
        return _libBornAgainSample.InterferenceFunction2DLattice_getChildren(self)

    def onChange(self):
        r"""
        onChange(InterferenceFunction2DLattice self)
        void InterferenceFunction2DLattice::onChange() override

        """
        return _libBornAgainSample.InterferenceFunction2DLattice_onChange(self)

# Register InterferenceFunction2DLattice in _libBornAgainSample:
_libBornAgainSample.InterferenceFunction2DLattice_swigregister(InterferenceFunction2DLattice)

class InterferenceFunction2DParaCrystal(IInterferenceFunction):
    r"""


    Interference function of a 2D paracrystal.

    C++ includes: InterferenceFunction2DParaCrystal.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lattice, damping_length, domain_size_1, domain_size_2):
        r"""
        __init__(InterferenceFunction2DParaCrystal self, Lattice2D lattice, double damping_length, double domain_size_1, double domain_size_2) -> InterferenceFunction2DParaCrystal
        InterferenceFunction2DParaCrystal::InterferenceFunction2DParaCrystal(const Lattice2D &lattice, double damping_length, double domain_size_1, double domain_size_2)

        """
        _libBornAgainSample.InterferenceFunction2DParaCrystal_swiginit(self, _libBornAgainSample.new_InterferenceFunction2DParaCrystal(lattice, damping_length, domain_size_1, domain_size_2))
    __swig_destroy__ = _libBornAgainSample.delete_InterferenceFunction2DParaCrystal

    def clone(self):
        r"""
        clone(InterferenceFunction2DParaCrystal self) -> InterferenceFunction2DParaCrystal
        InterferenceFunction2DParaCrystal * InterferenceFunction2DParaCrystal::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_clone(self)

    def accept(self, visitor):
        r"""
        accept(InterferenceFunction2DParaCrystal self, INodeVisitor * visitor)
        void InterferenceFunction2DParaCrystal::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_accept(self, visitor)

    def setDomainSizes(self, size_1, size_2):
        r"""
        setDomainSizes(InterferenceFunction2DParaCrystal self, double size_1, double size_2)
        void InterferenceFunction2DParaCrystal::setDomainSizes(double size_1, double size_2)

        Sets the sizes of coherence domains.

        Parameters:
        -----------

        size_1: 
        coherence domain size along the first basis vector in nanometers

        size_2: 
        coherence domain size along the second basis vector in nanometers 

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_setDomainSizes(self, size_1, size_2)

    def setProbabilityDistributions(self, pdf_1, pdf_2):
        r"""
        setProbabilityDistributions(InterferenceFunction2DParaCrystal self, IFTDistribution2D pdf_1, IFTDistribution2D pdf_2)
        void InterferenceFunction2DParaCrystal::setProbabilityDistributions(const IFTDistribution2D &pdf_1, const IFTDistribution2D &pdf_2)

        Sets the probability distributions (Fourier transformed) for the two lattice directions.

        Parameters:
        -----------

        pdf_1: 
        probability distribution in first lattice direction

        pdf_2: 
        probability distribution in second lattice direction 

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_setProbabilityDistributions(self, pdf_1, pdf_2)

    def setDampingLength(self, damping_length):
        r"""
        setDampingLength(InterferenceFunction2DParaCrystal self, double damping_length)
        void InterferenceFunction2DParaCrystal::setDampingLength(double damping_length)

        Sets the damping length.

        Parameters:
        -----------

        damping_length: 
        the damping (coherence) length of the paracrystal in nanometers 

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_setDampingLength(self, damping_length)

    def domainSizes(self):
        r"""
        domainSizes(InterferenceFunction2DParaCrystal self) -> vdouble1d_t
        std::vector< double > InterferenceFunction2DParaCrystal::domainSizes() const

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_domainSizes(self)

    def setIntegrationOverXi(self, integrate_xi):
        r"""
        setIntegrationOverXi(InterferenceFunction2DParaCrystal self, bool integrate_xi)
        void InterferenceFunction2DParaCrystal::setIntegrationOverXi(bool integrate_xi)

        Enables/disables averaging over the lattice rotation angle.

        Parameters:
        -----------

        integrate_xi: 
        integration flag 

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_setIntegrationOverXi(self, integrate_xi)

    def integrationOverXi(self):
        r"""
        integrationOverXi(InterferenceFunction2DParaCrystal self) -> bool
        bool InterferenceFunction2DParaCrystal::integrationOverXi() const

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_integrationOverXi(self)

    def dampingLength(self):
        r"""
        dampingLength(InterferenceFunction2DParaCrystal self) -> double
        double InterferenceFunction2DParaCrystal::dampingLength() const

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_dampingLength(self)

    def lattice(self):
        r"""
        lattice(InterferenceFunction2DParaCrystal self) -> Lattice2D
        const Lattice2D & InterferenceFunction2DParaCrystal::lattice() const

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_lattice(self)

    def getParticleDensity(self):
        r"""
        getParticleDensity(InterferenceFunction2DParaCrystal self) -> double
        double InterferenceFunction2DParaCrystal::getParticleDensity() const override

        If defined by this interference function's parameters, returns the particle density (per area). Otherwise, returns zero or a user-defined value 

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_getParticleDensity(self)

    def getChildren(self):
        r"""
        getChildren(InterferenceFunction2DParaCrystal self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > InterferenceFunction2DParaCrystal::getChildren() const override

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_getChildren(self)

    def pdf1(self):
        r"""
        pdf1(InterferenceFunction2DParaCrystal self) -> IFTDistribution2D
        const IFTDistribution2D* InterferenceFunction2DParaCrystal::pdf1() const

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_pdf1(self)

    def pdf2(self):
        r"""
        pdf2(InterferenceFunction2DParaCrystal self) -> IFTDistribution2D
        const IFTDistribution2D* InterferenceFunction2DParaCrystal::pdf2() const

        """
        return _libBornAgainSample.InterferenceFunction2DParaCrystal_pdf2(self)

# Register InterferenceFunction2DParaCrystal in _libBornAgainSample:
_libBornAgainSample.InterferenceFunction2DParaCrystal_swigregister(InterferenceFunction2DParaCrystal)

class InterferenceFunction2DSuperLattice(IInterferenceFunction):
    r"""


    Interference function of a 2D superlattice with a configurable interference function for each lattice site.

    C++ includes: InterferenceFunction2DSuperLattice.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(InterferenceFunction2DSuperLattice self, Lattice2D lattice, unsigned int size_1, unsigned int size_2) -> InterferenceFunction2DSuperLattice
        __init__(InterferenceFunction2DSuperLattice self, double length_1, double length_2, double alpha, double xi, unsigned int size_1, unsigned int size_2) -> InterferenceFunction2DSuperLattice
        InterferenceFunction2DSuperLattice::InterferenceFunction2DSuperLattice(double length_1, double length_2, double alpha, double xi, unsigned size_1, unsigned size_2)

        Constructor of two-dimensional interference function.

        Parameters:
        -----------

        length_1: 
        length of first lattice vector in nanometers

        length_2: 
        length of second lattice vector in nanometers

        alpha: 
        angle between lattice vectors in radians

        xi: 
        rotation of lattice with respect to x-axis (beam direction) in radians

        size_1: 
        correlation length in direction 1

        size_2: 
        correlation length in direction 2 

        """
        _libBornAgainSample.InterferenceFunction2DSuperLattice_swiginit(self, _libBornAgainSample.new_InterferenceFunction2DSuperLattice(*args))
    __swig_destroy__ = _libBornAgainSample.delete_InterferenceFunction2DSuperLattice

    def clone(self):
        r"""
        clone(InterferenceFunction2DSuperLattice self) -> InterferenceFunction2DSuperLattice
        InterferenceFunction2DSuperLattice * InterferenceFunction2DSuperLattice::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.InterferenceFunction2DSuperLattice_clone(self)

    def accept(self, visitor):
        r"""
        accept(InterferenceFunction2DSuperLattice self, INodeVisitor * visitor)
        void InterferenceFunction2DSuperLattice::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.InterferenceFunction2DSuperLattice_accept(self, visitor)

    def setSubstructureIFF(self, sub_iff):
        r"""
        setSubstructureIFF(InterferenceFunction2DSuperLattice self, IInterferenceFunction sub_iff)
        void InterferenceFunction2DSuperLattice::setSubstructureIFF(const IInterferenceFunction &sub_iff)

        """
        return _libBornAgainSample.InterferenceFunction2DSuperLattice_setSubstructureIFF(self, sub_iff)

    def substructureIFF(self):
        r"""
        substructureIFF(InterferenceFunction2DSuperLattice self) -> IInterferenceFunction
        const IInterferenceFunction & InterferenceFunction2DSuperLattice::substructureIFF() const

        """
        return _libBornAgainSample.InterferenceFunction2DSuperLattice_substructureIFF(self)

    def evaluate(self, q, outer_iff=1.0):
        r"""
        evaluate(InterferenceFunction2DSuperLattice self, kvector_t q, double outer_iff=1.0) -> double
        double InterferenceFunction2DSuperLattice::evaluate(const kvector_t q, double outer_iff=1.0) const override

        Evaluates the interference function for a given wavevector transfer. 

        """
        return _libBornAgainSample.InterferenceFunction2DSuperLattice_evaluate(self, q, outer_iff)

    def domainSize1(self):
        r"""
        domainSize1(InterferenceFunction2DSuperLattice self) -> unsigned int
        unsigned InterferenceFunction2DSuperLattice::domainSize1() const

        """
        return _libBornAgainSample.InterferenceFunction2DSuperLattice_domainSize1(self)

    def domainSize2(self):
        r"""
        domainSize2(InterferenceFunction2DSuperLattice self) -> unsigned int
        unsigned InterferenceFunction2DSuperLattice::domainSize2() const

        """
        return _libBornAgainSample.InterferenceFunction2DSuperLattice_domainSize2(self)

    def setIntegrationOverXi(self, integrate_xi):
        r"""
        setIntegrationOverXi(InterferenceFunction2DSuperLattice self, bool integrate_xi)
        void InterferenceFunction2DSuperLattice::setIntegrationOverXi(bool integrate_xi)

        """
        return _libBornAgainSample.InterferenceFunction2DSuperLattice_setIntegrationOverXi(self, integrate_xi)

    def integrationOverXi(self):
        r"""
        integrationOverXi(InterferenceFunction2DSuperLattice self) -> bool
        bool InterferenceFunction2DSuperLattice::integrationOverXi() const

        """
        return _libBornAgainSample.InterferenceFunction2DSuperLattice_integrationOverXi(self)

    def lattice(self):
        r"""
        lattice(InterferenceFunction2DSuperLattice self) -> Lattice2D
        const Lattice2D & InterferenceFunction2DSuperLattice::lattice() const

        """
        return _libBornAgainSample.InterferenceFunction2DSuperLattice_lattice(self)

    def getChildren(self):
        r"""
        getChildren(InterferenceFunction2DSuperLattice self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > InterferenceFunction2DSuperLattice::getChildren() const override

        """
        return _libBornAgainSample.InterferenceFunction2DSuperLattice_getChildren(self)

# Register InterferenceFunction2DSuperLattice in _libBornAgainSample:
_libBornAgainSample.InterferenceFunction2DSuperLattice_swigregister(InterferenceFunction2DSuperLattice)

class InterferenceFunction3DLattice(IInterferenceFunction):
    r"""


    Interference function of a 3D lattice.

    C++ includes: InterferenceFunction3DLattice.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lattice):
        r"""
        __init__(InterferenceFunction3DLattice self, Lattice3D lattice) -> InterferenceFunction3DLattice
        InterferenceFunction3DLattice::InterferenceFunction3DLattice(const Lattice3D &lattice)

        """
        _libBornAgainSample.InterferenceFunction3DLattice_swiginit(self, _libBornAgainSample.new_InterferenceFunction3DLattice(lattice))
    __swig_destroy__ = _libBornAgainSample.delete_InterferenceFunction3DLattice

    def clone(self):
        r"""
        clone(InterferenceFunction3DLattice self) -> InterferenceFunction3DLattice
        InterferenceFunction3DLattice * InterferenceFunction3DLattice::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.InterferenceFunction3DLattice_clone(self)

    def accept(self, visitor):
        r"""
        accept(InterferenceFunction3DLattice self, INodeVisitor * visitor)
        void InterferenceFunction3DLattice::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.InterferenceFunction3DLattice_accept(self, visitor)

    def setPeakShape(self, peak_shape):
        r"""
        setPeakShape(InterferenceFunction3DLattice self, IPeakShape peak_shape)
        void InterferenceFunction3DLattice::setPeakShape(const IPeakShape &peak_shape)

        """
        return _libBornAgainSample.InterferenceFunction3DLattice_setPeakShape(self, peak_shape)

    def lattice(self):
        r"""
        lattice(InterferenceFunction3DLattice self) -> Lattice3D
        const Lattice3D & InterferenceFunction3DLattice::lattice() const

        """
        return _libBornAgainSample.InterferenceFunction3DLattice_lattice(self)

    def supportsMultilayer(self):
        r"""
        supportsMultilayer(InterferenceFunction3DLattice self) -> bool
        bool InterferenceFunction3DLattice::supportsMultilayer() const override

        Indicates if this interference function can be used with a multilayer (DWBA mode) 

        """
        return _libBornAgainSample.InterferenceFunction3DLattice_supportsMultilayer(self)

    def getChildren(self):
        r"""
        getChildren(InterferenceFunction3DLattice self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > InterferenceFunction3DLattice::getChildren() const override

        """
        return _libBornAgainSample.InterferenceFunction3DLattice_getChildren(self)

    def onChange(self):
        r"""
        onChange(InterferenceFunction3DLattice self)
        void InterferenceFunction3DLattice::onChange() override

        """
        return _libBornAgainSample.InterferenceFunction3DLattice_onChange(self)

# Register InterferenceFunction3DLattice in _libBornAgainSample:
_libBornAgainSample.InterferenceFunction3DLattice_swigregister(InterferenceFunction3DLattice)

class InterferenceFunctionFinite2DLattice(IInterferenceFunction):
    r"""


    Interference function of a finite 2D lattice.

    C++ includes: InterferenceFunctionFinite2DLattice.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lattice, N_1, N_2):
        r"""
        __init__(InterferenceFunctionFinite2DLattice self, Lattice2D lattice, unsigned int N_1, unsigned int N_2) -> InterferenceFunctionFinite2DLattice
        InterferenceFunctionFinite2DLattice::InterferenceFunctionFinite2DLattice(const Lattice2D &lattice, unsigned N_1, unsigned N_2)

        Constructor of two-dimensional finite lattice interference function.

        Parameters:
        -----------

        lattice: 
        object specifying a 2d lattice structure

        N_1: 
        number of lattice cells in the first lattice direction

        N_2: 
        number of lattice cells in the second lattice direction 

        """
        _libBornAgainSample.InterferenceFunctionFinite2DLattice_swiginit(self, _libBornAgainSample.new_InterferenceFunctionFinite2DLattice(lattice, N_1, N_2))
    __swig_destroy__ = _libBornAgainSample.delete_InterferenceFunctionFinite2DLattice

    def clone(self):
        r"""
        clone(InterferenceFunctionFinite2DLattice self) -> InterferenceFunctionFinite2DLattice
        InterferenceFunctionFinite2DLattice * InterferenceFunctionFinite2DLattice::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.InterferenceFunctionFinite2DLattice_clone(self)

    def accept(self, visitor):
        r"""
        accept(InterferenceFunctionFinite2DLattice self, INodeVisitor * visitor)
        void InterferenceFunctionFinite2DLattice::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.InterferenceFunctionFinite2DLattice_accept(self, visitor)

    def numberUnitCells1(self):
        r"""
        numberUnitCells1(InterferenceFunctionFinite2DLattice self) -> unsigned int
        unsigned InterferenceFunctionFinite2DLattice::numberUnitCells1() const

        """
        return _libBornAgainSample.InterferenceFunctionFinite2DLattice_numberUnitCells1(self)

    def numberUnitCells2(self):
        r"""
        numberUnitCells2(InterferenceFunctionFinite2DLattice self) -> unsigned int
        unsigned InterferenceFunctionFinite2DLattice::numberUnitCells2() const

        """
        return _libBornAgainSample.InterferenceFunctionFinite2DLattice_numberUnitCells2(self)

    def setIntegrationOverXi(self, integrate_xi):
        r"""
        setIntegrationOverXi(InterferenceFunctionFinite2DLattice self, bool integrate_xi)
        void InterferenceFunctionFinite2DLattice::setIntegrationOverXi(bool integrate_xi)

        """
        return _libBornAgainSample.InterferenceFunctionFinite2DLattice_setIntegrationOverXi(self, integrate_xi)

    def integrationOverXi(self):
        r"""
        integrationOverXi(InterferenceFunctionFinite2DLattice self) -> bool
        bool InterferenceFunctionFinite2DLattice::integrationOverXi() const

        """
        return _libBornAgainSample.InterferenceFunctionFinite2DLattice_integrationOverXi(self)

    def lattice(self):
        r"""
        lattice(InterferenceFunctionFinite2DLattice self) -> Lattice2D
        const Lattice2D & InterferenceFunctionFinite2DLattice::lattice() const

        """
        return _libBornAgainSample.InterferenceFunctionFinite2DLattice_lattice(self)

    def getParticleDensity(self):
        r"""
        getParticleDensity(InterferenceFunctionFinite2DLattice self) -> double
        double InterferenceFunctionFinite2DLattice::getParticleDensity() const override

        Returns the particle density associated with this 2d lattice. 

        """
        return _libBornAgainSample.InterferenceFunctionFinite2DLattice_getParticleDensity(self)

    def getChildren(self):
        r"""
        getChildren(InterferenceFunctionFinite2DLattice self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > InterferenceFunctionFinite2DLattice::getChildren() const override

        """
        return _libBornAgainSample.InterferenceFunctionFinite2DLattice_getChildren(self)

# Register InterferenceFunctionFinite2DLattice in _libBornAgainSample:
_libBornAgainSample.InterferenceFunctionFinite2DLattice_swigregister(InterferenceFunctionFinite2DLattice)

class InterferenceFunctionFinite3DLattice(IInterferenceFunction):
    r"""


    Interference function of a finite 3D lattice.

    C++ includes: InterferenceFunctionFinite3DLattice.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lattice, N_1, N_2, N_3):
        r"""
        __init__(InterferenceFunctionFinite3DLattice self, Lattice3D lattice, unsigned int N_1, unsigned int N_2, unsigned int N_3) -> InterferenceFunctionFinite3DLattice
        InterferenceFunctionFinite3DLattice::InterferenceFunctionFinite3DLattice(const Lattice3D &lattice, unsigned N_1, unsigned N_2, unsigned N_3)

        """
        _libBornAgainSample.InterferenceFunctionFinite3DLattice_swiginit(self, _libBornAgainSample.new_InterferenceFunctionFinite3DLattice(lattice, N_1, N_2, N_3))
    __swig_destroy__ = _libBornAgainSample.delete_InterferenceFunctionFinite3DLattice

    def clone(self):
        r"""
        clone(InterferenceFunctionFinite3DLattice self) -> InterferenceFunctionFinite3DLattice
        InterferenceFunctionFinite3DLattice * InterferenceFunctionFinite3DLattice::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.InterferenceFunctionFinite3DLattice_clone(self)

    def accept(self, visitor):
        r"""
        accept(InterferenceFunctionFinite3DLattice self, INodeVisitor * visitor)
        void InterferenceFunctionFinite3DLattice::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.InterferenceFunctionFinite3DLattice_accept(self, visitor)

    def numberUnitCells1(self):
        r"""
        numberUnitCells1(InterferenceFunctionFinite3DLattice self) -> unsigned int
        unsigned InterferenceFunctionFinite3DLattice::numberUnitCells1() const

        """
        return _libBornAgainSample.InterferenceFunctionFinite3DLattice_numberUnitCells1(self)

    def numberUnitCells2(self):
        r"""
        numberUnitCells2(InterferenceFunctionFinite3DLattice self) -> unsigned int
        unsigned InterferenceFunctionFinite3DLattice::numberUnitCells2() const

        """
        return _libBornAgainSample.InterferenceFunctionFinite3DLattice_numberUnitCells2(self)

    def numberUnitCells3(self):
        r"""
        numberUnitCells3(InterferenceFunctionFinite3DLattice self) -> unsigned int
        unsigned InterferenceFunctionFinite3DLattice::numberUnitCells3() const

        """
        return _libBornAgainSample.InterferenceFunctionFinite3DLattice_numberUnitCells3(self)

    def lattice(self):
        r"""
        lattice(InterferenceFunctionFinite3DLattice self) -> Lattice3D
        const Lattice3D & InterferenceFunctionFinite3DLattice::lattice() const

        """
        return _libBornAgainSample.InterferenceFunctionFinite3DLattice_lattice(self)

    def supportsMultilayer(self):
        r"""
        supportsMultilayer(InterferenceFunctionFinite3DLattice self) -> bool
        bool InterferenceFunctionFinite3DLattice::supportsMultilayer() const override

        Indicates if this interference function can be used with a multilayer (DWBA mode) 

        """
        return _libBornAgainSample.InterferenceFunctionFinite3DLattice_supportsMultilayer(self)

    def getChildren(self):
        r"""
        getChildren(InterferenceFunctionFinite3DLattice self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > InterferenceFunctionFinite3DLattice::getChildren() const override

        """
        return _libBornAgainSample.InterferenceFunctionFinite3DLattice_getChildren(self)

# Register InterferenceFunctionFinite3DLattice in _libBornAgainSample:
_libBornAgainSample.InterferenceFunctionFinite3DLattice_swigregister(InterferenceFunctionFinite3DLattice)

class InterferenceFunctionHardDisk(IInterferenceFunction):
    r"""


    Percus-Yevick hard disk interference function.

    M.S. Ripoll & C.F. Tejero (1995) Approximate analytical expression for the direct correlation function of hard discs within the Percus-Yevick equation, Molecular Physics, 85:2, 423-428, DOI: 10.1080/00268979500101211

    C++ includes: InterferenceFunctionHardDisk.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, radius, density, position_var=0):
        r"""
        __init__(InterferenceFunctionHardDisk self, double radius, double density, double position_var=0) -> InterferenceFunctionHardDisk
        InterferenceFunctionHardDisk::InterferenceFunctionHardDisk(double radius, double density, double position_var=0)

        """
        _libBornAgainSample.InterferenceFunctionHardDisk_swiginit(self, _libBornAgainSample.new_InterferenceFunctionHardDisk(radius, density, position_var))
    __swig_destroy__ = _libBornAgainSample.delete_InterferenceFunctionHardDisk

    def clone(self):
        r"""
        clone(InterferenceFunctionHardDisk self) -> InterferenceFunctionHardDisk
        InterferenceFunctionHardDisk * InterferenceFunctionHardDisk::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.InterferenceFunctionHardDisk_clone(self)

    def accept(self, visitor):
        r"""
        accept(InterferenceFunctionHardDisk self, INodeVisitor * visitor)
        void InterferenceFunctionHardDisk::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.InterferenceFunctionHardDisk_accept(self, visitor)

    def getParticleDensity(self):
        r"""
        getParticleDensity(InterferenceFunctionHardDisk self) -> double
        double InterferenceFunctionHardDisk::getParticleDensity() const override

        If defined by this interference function's parameters, returns the particle density (per area). Otherwise, returns zero or a user-defined value 

        """
        return _libBornAgainSample.InterferenceFunctionHardDisk_getParticleDensity(self)

    def radius(self):
        r"""
        radius(InterferenceFunctionHardDisk self) -> double
        double InterferenceFunctionHardDisk::radius() const

        """
        return _libBornAgainSample.InterferenceFunctionHardDisk_radius(self)

    def density(self):
        r"""
        density(InterferenceFunctionHardDisk self) -> double
        double InterferenceFunctionHardDisk::density() const

        """
        return _libBornAgainSample.InterferenceFunctionHardDisk_density(self)

# Register InterferenceFunctionHardDisk in _libBornAgainSample:
_libBornAgainSample.InterferenceFunctionHardDisk_swigregister(InterferenceFunctionHardDisk)

class InterferenceFunctionNone(IInterferenceFunction):
    r"""


    Default interference function (i.e. absence of any interference).

    C++ includes: InterferenceFunctionNone.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(InterferenceFunctionNone self) -> InterferenceFunctionNone
        InterferenceFunctionNone::InterferenceFunctionNone()

        """
        _libBornAgainSample.InterferenceFunctionNone_swiginit(self, _libBornAgainSample.new_InterferenceFunctionNone())

    def clone(self):
        r"""
        clone(InterferenceFunctionNone self) -> InterferenceFunctionNone
        InterferenceFunctionNone * InterferenceFunctionNone::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.InterferenceFunctionNone_clone(self)

    def accept(self, visitor):
        r"""
        accept(InterferenceFunctionNone self, INodeVisitor * visitor)
        void InterferenceFunctionNone::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.InterferenceFunctionNone_accept(self, visitor)
    __swig_destroy__ = _libBornAgainSample.delete_InterferenceFunctionNone

# Register InterferenceFunctionNone in _libBornAgainSample:
_libBornAgainSample.InterferenceFunctionNone_swigregister(InterferenceFunctionNone)

class InterferenceFunctionRadialParaCrystal(IInterferenceFunction):
    r"""


    Interference function of radial paracrystal.

    C++ includes: InterferenceFunctionRadialParaCrystal.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, peak_distance, damping_length):
        r"""
        __init__(InterferenceFunctionRadialParaCrystal self, double peak_distance, double damping_length) -> InterferenceFunctionRadialParaCrystal
        InterferenceFunctionRadialParaCrystal::InterferenceFunctionRadialParaCrystal(double peak_distance, double damping_length)

        Constructor of interference function of radial paracrystal.

        Parameters:
        -----------

        peak_distance: 
        average distance to the next neighbor in nanometers

        damping_length: 
        the damping (coherence) length of the paracrystal in nanometers 

        """
        _libBornAgainSample.InterferenceFunctionRadialParaCrystal_swiginit(self, _libBornAgainSample.new_InterferenceFunctionRadialParaCrystal(peak_distance, damping_length))

    def clone(self):
        r"""
        clone(InterferenceFunctionRadialParaCrystal self) -> InterferenceFunctionRadialParaCrystal
        InterferenceFunctionRadialParaCrystal * InterferenceFunctionRadialParaCrystal::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_clone(self)

    def accept(self, visitor):
        r"""
        accept(InterferenceFunctionRadialParaCrystal self, INodeVisitor * visitor)
        void InterferenceFunctionRadialParaCrystal::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_accept(self, visitor)

    def setKappa(self, kappa):
        r"""
        setKappa(InterferenceFunctionRadialParaCrystal self, double kappa)
        void InterferenceFunctionRadialParaCrystal::setKappa(double kappa)

        Sets size spacing coupling parameter of the Size Spacing Correlation Approximation. 

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_setKappa(self, kappa)

    def kappa(self):
        r"""
        kappa(InterferenceFunctionRadialParaCrystal self) -> double
        double InterferenceFunctionRadialParaCrystal::kappa() const

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_kappa(self)

    def setDomainSize(self, size):
        r"""
        setDomainSize(InterferenceFunctionRadialParaCrystal self, double size)
        void InterferenceFunctionRadialParaCrystal::setDomainSize(double size)

        Sets domain size (finite size corrections).

        Parameters:
        -----------

        size: 
        size of coherence domain along the lattice main axis in nanometers 

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_setDomainSize(self, size)

    def domainSize(self):
        r"""
        domainSize(InterferenceFunctionRadialParaCrystal self) -> double
        double InterferenceFunctionRadialParaCrystal::domainSize() const

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_domainSize(self)

    def FTPDF(self, qpar):
        r"""
        FTPDF(InterferenceFunctionRadialParaCrystal self, double qpar) -> complex_t
        complex_t InterferenceFunctionRadialParaCrystal::FTPDF(double qpar) const

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_FTPDF(self, qpar)

    def setProbabilityDistribution(self, pdf):
        r"""
        setProbabilityDistribution(InterferenceFunctionRadialParaCrystal self, IFTDistribution1D pdf)
        void InterferenceFunctionRadialParaCrystal::setProbabilityDistribution(const IFTDistribution1D &pdf)

        Sets one-dimensional probability distribution.

        Parameters:
        -----------

        pdf: 
        probability distribution (Fourier transform of probability density) 

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_setProbabilityDistribution(self, pdf)

    def peakDistance(self):
        r"""
        peakDistance(InterferenceFunctionRadialParaCrystal self) -> double
        double InterferenceFunctionRadialParaCrystal::peakDistance() const

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_peakDistance(self)

    def dampingLength(self):
        r"""
        dampingLength(InterferenceFunctionRadialParaCrystal self) -> double
        double InterferenceFunctionRadialParaCrystal::dampingLength() const

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_dampingLength(self)

    def getChildren(self):
        r"""
        getChildren(InterferenceFunctionRadialParaCrystal self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > InterferenceFunctionRadialParaCrystal::getChildren() const final

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_getChildren(self)

    def randomSample(self):
        r"""
        randomSample(InterferenceFunctionRadialParaCrystal self) -> double
        double InterferenceFunctionRadialParaCrystal::randomSample() const

        """
        return _libBornAgainSample.InterferenceFunctionRadialParaCrystal_randomSample(self)
    __swig_destroy__ = _libBornAgainSample.delete_InterferenceFunctionRadialParaCrystal

# Register InterferenceFunctionRadialParaCrystal in _libBornAgainSample:
_libBornAgainSample.InterferenceFunctionRadialParaCrystal_swigregister(InterferenceFunctionRadialParaCrystal)

class InterferenceFunctionTwin(IInterferenceFunction):
    r"""


    Interference function for two particles at a mean distance and given standard deviation from each other in a given direction.

    C++ includes: InterferenceFunctionTwin.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, direction, mean_distance, std_dev):
        r"""
        __init__(InterferenceFunctionTwin self, kvector_t direction, double mean_distance, double std_dev) -> InterferenceFunctionTwin
        InterferenceFunctionTwin::InterferenceFunctionTwin(const kvector_t &direction, double mean_distance, double std_dev)

        """
        _libBornAgainSample.InterferenceFunctionTwin_swiginit(self, _libBornAgainSample.new_InterferenceFunctionTwin(direction, mean_distance, std_dev))

    def clone(self):
        r"""
        clone(InterferenceFunctionTwin self) -> InterferenceFunctionTwin
        InterferenceFunctionTwin * InterferenceFunctionTwin::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.InterferenceFunctionTwin_clone(self)

    def accept(self, visitor):
        r"""
        accept(InterferenceFunctionTwin self, INodeVisitor * visitor)
        void InterferenceFunctionTwin::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.InterferenceFunctionTwin_accept(self, visitor)

    def direction(self):
        r"""
        direction(InterferenceFunctionTwin self) -> kvector_t
        kvector_t InterferenceFunctionTwin::direction() const

        """
        return _libBornAgainSample.InterferenceFunctionTwin_direction(self)

    def meanDistance(self):
        r"""
        meanDistance(InterferenceFunctionTwin self) -> double
        double InterferenceFunctionTwin::meanDistance() const

        """
        return _libBornAgainSample.InterferenceFunctionTwin_meanDistance(self)

    def stdDev(self):
        r"""
        stdDev(InterferenceFunctionTwin self) -> double
        double InterferenceFunctionTwin::stdDev() const

        """
        return _libBornAgainSample.InterferenceFunctionTwin_stdDev(self)
    __swig_destroy__ = _libBornAgainSample.delete_InterferenceFunctionTwin

# Register InterferenceFunctionTwin in _libBornAgainSample:
_libBornAgainSample.InterferenceFunctionTwin_swigregister(InterferenceFunctionTwin)

class ParticleLayout(ISampleNode):
    r"""


    Decorator class that adds particles to  ISampleNode objects.

    C++ includes: ParticleLayout.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(ParticleLayout self) -> ParticleLayout
        __init__(ParticleLayout self, IAbstractParticle particle, double abundance=-1.0) -> ParticleLayout
        ParticleLayout::ParticleLayout(const IAbstractParticle &particle, double abundance=-1.0)

        """
        _libBornAgainSample.ParticleLayout_swiginit(self, _libBornAgainSample.new_ParticleLayout(*args))
    __swig_destroy__ = _libBornAgainSample.delete_ParticleLayout

    def clone(self):
        r"""
        clone(ParticleLayout self) -> ParticleLayout
        ParticleLayout * ParticleLayout::clone() const override

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.ParticleLayout_clone(self)

    def accept(self, visitor):
        r"""
        accept(ParticleLayout self, INodeVisitor * visitor)
        void ParticleLayout::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.ParticleLayout_accept(self, visitor)

    def addParticle(self, *args):
        r"""
        addParticle(ParticleLayout self, IAbstractParticle particle, double abundance=-1.0, kvector_t position={}, IRotation rotation=IdentityRotation())
        void ParticleLayout::addParticle(const IAbstractParticle &particle, double abundance=-1.0, const kvector_t position={}, const IRotation &rotation=IdentityRotation())

        Adds particle to the layout with abundance, position and the rotation defined.

        Parameters:
        -----------

        particle: 
        to be added

        abundance: 
         Particle abundance

        position: 
         Particle position

        rotation: 
         Particle rotation 

        """
        return _libBornAgainSample.ParticleLayout_addParticle(self, *args)

    def particles(self):
        r"""
        particles(ParticleLayout self) -> SafePointerVector< IParticle >
        SafePointerVector< IParticle > ParticleLayout::particles() const

        Returns information on all particles (type and abundance) and generates new particles if an  IAbstractParticle denotes a collection 

        """
        return _libBornAgainSample.ParticleLayout_particles(self)

    def interferenceFunction(self):
        r"""
        interferenceFunction(ParticleLayout self) -> IInterferenceFunction
        const IInterferenceFunction * ParticleLayout::interferenceFunction() const

        """
        return _libBornAgainSample.ParticleLayout_interferenceFunction(self)

    def getTotalAbundance(self):
        r"""
        getTotalAbundance(ParticleLayout self) -> double
        double ParticleLayout::getTotalAbundance() const

        """
        return _libBornAgainSample.ParticleLayout_getTotalAbundance(self)

    def setInterferenceFunction(self, interference_function):
        r"""
        setInterferenceFunction(ParticleLayout self, IInterferenceFunction interference_function)
        void ParticleLayout::setInterferenceFunction(const IInterferenceFunction &interference_function)

        Adds interference functions. 

        """
        return _libBornAgainSample.ParticleLayout_setInterferenceFunction(self, interference_function)

    def totalParticleSurfaceDensity(self):
        r"""
        totalParticleSurfaceDensity(ParticleLayout self) -> double
        double ParticleLayout::totalParticleSurfaceDensity() const

        """
        return _libBornAgainSample.ParticleLayout_totalParticleSurfaceDensity(self)

    def setTotalParticleSurfaceDensity(self, particle_density):
        r"""
        setTotalParticleSurfaceDensity(ParticleLayout self, double particle_density)
        void ParticleLayout::setTotalParticleSurfaceDensity(double particle_density)

        Sets total particle surface density.

        Parameters:
        -----------

        particle_density: 
        number of particles per square nanometer 

        """
        return _libBornAgainSample.ParticleLayout_setTotalParticleSurfaceDensity(self, particle_density)

    def getChildren(self):
        r"""
        getChildren(ParticleLayout self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > ParticleLayout::getChildren() const override

        """
        return _libBornAgainSample.ParticleLayout_getChildren(self)

    def weight(self):
        r"""
        weight(ParticleLayout self) -> double
        double ParticleLayout::weight() const

        Returns the relative weight of this layout. 

        """
        return _libBornAgainSample.ParticleLayout_weight(self)

    def setWeight(self, weight):
        r"""
        setWeight(ParticleLayout self, double weight)
        void ParticleLayout::setWeight(double weight)

        Sets the relative weight of this layout. 

        """
        return _libBornAgainSample.ParticleLayout_setWeight(self, weight)

# Register ParticleLayout in _libBornAgainSample:
_libBornAgainSample.ParticleLayout_swigregister(ParticleLayout)

class LayerRoughness(ISampleNode):
    r"""


    A roughness of interface between two layers.

    Based on the article D.K.G. de Boer, Physical review B, Volume 51, Number 8, 15 February 1995 "X-ray reflection and transmission by rough surfaces"

    C++ includes: LayerRoughness.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(LayerRoughness self, double sigma, double hurstParameter, double lateralCorrLength) -> LayerRoughness
        __init__(LayerRoughness self) -> LayerRoughness
        LayerRoughness::LayerRoughness()

        """
        _libBornAgainSample.LayerRoughness_swiginit(self, _libBornAgainSample.new_LayerRoughness(*args))

    def clone(self):
        r"""
        clone(LayerRoughness self) -> LayerRoughness
        LayerRoughness* LayerRoughness::clone() const

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.LayerRoughness_clone(self)

    def accept(self, visitor):
        r"""
        accept(LayerRoughness self, INodeVisitor * visitor)
        virtual void LayerRoughness::accept(INodeVisitor *visitor) const

        """
        return _libBornAgainSample.LayerRoughness_accept(self, visitor)

    def getSpectralFun(self, kvec):
        r"""
        getSpectralFun(LayerRoughness self, kvector_t kvec) -> double
        double LayerRoughness::getSpectralFun(const kvector_t kvec) const

        Returns power spectral density of the surface roughness.

        Power spectral density of the surface roughness is a result of two-dimensional Fourier transform of the correlation function of the roughness profile.

        Based on the article D.K.G. de Boer, Physical review B, Volume 51, Number 8, 15 February 1995 "X-ray reflection and transmission by rough surfaces" 

        """
        return _libBornAgainSample.LayerRoughness_getSpectralFun(self, kvec)

    def getCorrFun(self, k):
        r"""
        getCorrFun(LayerRoughness self, kvector_t k) -> double
        double LayerRoughness::getCorrFun(const kvector_t k) const

        Correlation function of the roughness profile. 

        """
        return _libBornAgainSample.LayerRoughness_getCorrFun(self, k)

    def setSigma(self, sigma):
        r"""
        setSigma(LayerRoughness self, double sigma)
        void LayerRoughness::setSigma(double sigma)

        Sets rms of roughness. 

        """
        return _libBornAgainSample.LayerRoughness_setSigma(self, sigma)

    def getSigma(self):
        r"""
        getSigma(LayerRoughness self) -> double
        double LayerRoughness::getSigma() const

        Returns rms of roughness. 

        """
        return _libBornAgainSample.LayerRoughness_getSigma(self)

    def setHurstParameter(self, hurstParameter):
        r"""
        setHurstParameter(LayerRoughness self, double hurstParameter)
        void LayerRoughness::setHurstParameter(double hurstParameter)

        Sets hurst parameter. It describes how jagged the surface is. 

        """
        return _libBornAgainSample.LayerRoughness_setHurstParameter(self, hurstParameter)

    def getHurstParameter(self):
        r"""
        getHurstParameter(LayerRoughness self) -> double
        double LayerRoughness::getHurstParameter() const

        Returns hurst parameter. 

        """
        return _libBornAgainSample.LayerRoughness_getHurstParameter(self)

    def setLatteralCorrLength(self, lateralCorrLength):
        r"""
        setLatteralCorrLength(LayerRoughness self, double lateralCorrLength)
        void LayerRoughness::setLatteralCorrLength(double lateralCorrLength)

        Sets lateral correlation length. 

        """
        return _libBornAgainSample.LayerRoughness_setLatteralCorrLength(self, lateralCorrLength)

    def getLatteralCorrLength(self):
        r"""
        getLatteralCorrLength(LayerRoughness self) -> double
        double LayerRoughness::getLatteralCorrLength() const

        Returns lateral correlation length. 

        """
        return _libBornAgainSample.LayerRoughness_getLatteralCorrLength(self)
    __swig_destroy__ = _libBornAgainSample.delete_LayerRoughness

# Register LayerRoughness in _libBornAgainSample:
_libBornAgainSample.LayerRoughness_swigregister(LayerRoughness)


def generateZValues(n_points, z_min, z_max):
    r"""
    generateZValues(int n_points, double z_min, double z_max) -> vdouble1d_t
    std::vector< double > swigAPI::generateZValues(int n_points, double z_min, double z_max)

    """
    return _libBornAgainSample.generateZValues(n_points, z_min, z_max)

def materialProfileSLD(multilayer, n_points, z_min, z_max):
    r"""
    materialProfileSLD(MultiLayer multilayer, int n_points, double z_min, double z_max) -> vector_complex_t
    std::vector< complex_t > swigAPI::materialProfileSLD(const MultiLayer &multilayer, int n_points, double z_min, double z_max)

    Calculate average material profile for given multilayer. 

    """
    return _libBornAgainSample.materialProfileSLD(multilayer, n_points, z_min, z_max)

def defaultMaterialProfileLimits(multilayer):
    r"""
    defaultMaterialProfileLimits(MultiLayer multilayer) -> pvacuum_double_t
    std::pair< double, double > swigAPI::defaultMaterialProfileLimits(const MultiLayer &multilayer)

    Get default z limits for generating a material profile. 

    """
    return _libBornAgainSample.defaultMaterialProfileLimits(multilayer)
class Layer(ISampleNode):
    r"""


    A layer in a  MultiLayer sample.

    C++ includes: Layer.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, material, thickness=0):
        r"""
        __init__(Layer self, Material material, double thickness=0) -> Layer
        Layer::Layer(Material material, double thickness=0)

        Constructor of a layer with thickness and material

        Parameters:
        -----------

        material: 
        material the layer is made of

        thickness: 
        thickness of a layer in nanometers 

        """
        _libBornAgainSample.Layer_swiginit(self, _libBornAgainSample.new_Layer(material, thickness))
    __swig_destroy__ = _libBornAgainSample.delete_Layer

    def clone(self):
        r"""
        clone(Layer self) -> Layer
        Layer * Layer::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.Layer_clone(self)

    def accept(self, visitor):
        r"""
        accept(Layer self, INodeVisitor * visitor)
        void Layer::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.Layer_accept(self, visitor)

    def setThickness(self, thickness):
        r"""
        setThickness(Layer self, double thickness)
        void Layer::setThickness(double thickness)

        Sets layer thickness in nanometers. 

        """
        return _libBornAgainSample.Layer_setThickness(self, thickness)

    def thickness(self):
        r"""
        thickness(Layer self) -> double
        double Layer::thickness() const

        """
        return _libBornAgainSample.Layer_thickness(self)

    def material(self):
        r"""
        material(Layer self) -> Material
        const Material* Layer::material() const final

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainSample.Layer_material(self)

    def setMaterial(self, material):
        r"""
        setMaterial(Layer self, Material material)
        void Layer::setMaterial(Material material)

        """
        return _libBornAgainSample.Layer_setMaterial(self, material)

    def addLayout(self, decoration):
        r"""
        addLayout(Layer self, ParticleLayout decoration)
        void Layer::addLayout(const ParticleLayout &decoration)

        """
        return _libBornAgainSample.Layer_addLayout(self, decoration)

    def numberOfLayouts(self):
        r"""
        numberOfLayouts(Layer self) -> size_t
        size_t Layer::numberOfLayouts() const

        """
        return _libBornAgainSample.Layer_numberOfLayouts(self)

    def layouts(self):
        r"""
        layouts(Layer self) -> std::vector< ParticleLayout const *,std::allocator< ParticleLayout const * > >
        std::vector< const ParticleLayout * > Layer::layouts() const

        """
        return _libBornAgainSample.Layer_layouts(self)

    def getChildren(self):
        r"""
        getChildren(Layer self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > Layer::getChildren() const final

        """
        return _libBornAgainSample.Layer_getChildren(self)

    def registerThickness(self, make_registered=True):
        r"""
        registerThickness(Layer self, bool make_registered=True)
        void Layer::registerThickness(bool make_registered=true)

        """
        return _libBornAgainSample.Layer_registerThickness(self, make_registered)

    def setNumberOfSlices(self, n_slices):
        r"""
        setNumberOfSlices(Layer self, unsigned int n_slices)
        void Layer::setNumberOfSlices(unsigned int n_slices)

        """
        return _libBornAgainSample.Layer_setNumberOfSlices(self, n_slices)

    def numberOfSlices(self):
        r"""
        numberOfSlices(Layer self) -> unsigned int
        unsigned int Layer::numberOfSlices() const

        """
        return _libBornAgainSample.Layer_numberOfSlices(self)

# Register Layer in _libBornAgainSample:
_libBornAgainSample.Layer_swigregister(Layer)

class MultiLayer(ISampleNode):
    r"""


    Our sample model: a stack of layers one below the other. Example of system of 4 layers (3 interfaces):

    ambience layer #0 ------ interface #0 z=0.0 Fe, 20A layer #1 ------ interface #1 z=-20.0 Cr, 40A layer #2 ------ interface #2 z=-60.0 substrate layer #3

    C++ includes: MultiLayer.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(MultiLayer self) -> MultiLayer
        MultiLayer::MultiLayer()

        """
        _libBornAgainSample.MultiLayer_swiginit(self, _libBornAgainSample.new_MultiLayer())
    __swig_destroy__ = _libBornAgainSample.delete_MultiLayer

    def clone(self):
        r"""
        clone(MultiLayer self) -> MultiLayer
        MultiLayer * MultiLayer::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.MultiLayer_clone(self)

    def accept(self, visitor):
        r"""
        accept(MultiLayer self, INodeVisitor * visitor)
        void MultiLayer::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.MultiLayer_accept(self, visitor)

    def numberOfLayers(self):
        r"""
        numberOfLayers(MultiLayer self) -> size_t
        size_t MultiLayer::numberOfLayers() const

        """
        return _libBornAgainSample.MultiLayer_numberOfLayers(self)

    def addLayer(self, layer):
        r"""
        addLayer(MultiLayer self, Layer layer)
        void MultiLayer::addLayer(const Layer &layer)

        Adds layer with default (zero) roughness. 

        """
        return _libBornAgainSample.MultiLayer_addLayer(self, layer)

    def addLayerWithTopRoughness(self, layer, roughness):
        r"""
        addLayerWithTopRoughness(MultiLayer self, Layer layer, LayerRoughness roughness)
        void MultiLayer::addLayerWithTopRoughness(const Layer &layer, const LayerRoughness &roughness)

        Adds layer with top roughness. 

        """
        return _libBornAgainSample.MultiLayer_addLayerWithTopRoughness(self, layer, roughness)

    def setRoughnessModel(self, roughnessModel):
        r"""
        setRoughnessModel(MultiLayer self, RoughnessModel roughnessModel)
        void MultiLayer::setRoughnessModel(RoughnessModel roughnessModel)

        """
        return _libBornAgainSample.MultiLayer_setRoughnessModel(self, roughnessModel)

    def setCrossCorrLength(self, crossCorrLength):
        r"""
        setCrossCorrLength(MultiLayer self, double crossCorrLength)
        void MultiLayer::setCrossCorrLength(double crossCorrLength)

        Sets cross correlation length of roughnesses between interfaces. 

        """
        return _libBornAgainSample.MultiLayer_setCrossCorrLength(self, crossCorrLength)

    def setExternalField(self, ext_field):
        r"""
        setExternalField(MultiLayer self, kvector_t ext_field)
        void MultiLayer::setExternalField(kvector_t ext_field)

        Sets the external field applied to the multilayer (units: A/m) 

        """
        return _libBornAgainSample.MultiLayer_setExternalField(self, ext_field)

    def layer(self, i_layer):
        r"""
        layer(MultiLayer self, size_t i_layer) -> Layer
        const Layer * MultiLayer::layer(size_t i_layer) const

        Returns layer with given index. 

        """
        return _libBornAgainSample.MultiLayer_layer(self, i_layer)

    def layerInterface(self, i_interface):
        r"""
        layerInterface(MultiLayer self, size_t i_interface) -> LayerInterface const *
        const LayerInterface * MultiLayer::layerInterface(size_t i_interface) const

        Returns interface with given index. 

        """
        return _libBornAgainSample.MultiLayer_layerInterface(self, i_interface)

    def roughnessModel(self):
        r"""
        roughnessModel(MultiLayer self) -> RoughnessModel
        RoughnessModel MultiLayer::roughnessModel() const

        """
        return _libBornAgainSample.MultiLayer_roughnessModel(self)

    def crossCorrLength(self):
        r"""
        crossCorrLength(MultiLayer self) -> double
        double MultiLayer::crossCorrLength() const

        Returns cross correlation length of roughnesses between interfaces. 

        """
        return _libBornAgainSample.MultiLayer_crossCorrLength(self)

    def externalField(self):
        r"""
        externalField(MultiLayer self) -> kvector_t
        kvector_t MultiLayer::externalField() const

        Returns the external field applied to the multilayer (units: A/m) 

        """
        return _libBornAgainSample.MultiLayer_externalField(self)

    def getChildren(self):
        r"""
        getChildren(MultiLayer self) -> swig_dummy_type_const_inode_vector
        std::vector< const INode * > MultiLayer::getChildren() const final

        """
        return _libBornAgainSample.MultiLayer_getChildren(self)

# Register MultiLayer in _libBornAgainSample:
_libBornAgainSample.MultiLayer_swigregister(MultiLayer)

class RoughnessModel(object):
    r"""Proxy of C++ RoughnessModelWrap class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DEFAULT = _libBornAgainSample.RoughnessModel_DEFAULT
    
    TANH = _libBornAgainSample.RoughnessModel_TANH
    
    NEVOT_CROCE = _libBornAgainSample.RoughnessModel_NEVOT_CROCE
    
    __swig_destroy__ = _libBornAgainSample.delete_RoughnessModel

# Register RoughnessModel in _libBornAgainSample:
_libBornAgainSample.RoughnessModel_swigregister(RoughnessModel)

class IFormFactorPolyhedron(IBornFF):
    r"""


    A polyhedron, for form factor computation.

    C++ includes: IFormFactorPolyhedron.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainSample.delete_IFormFactorPolyhedron

    def bottomZ(self, rotation):
        r"""
        bottomZ(IFormFactorPolyhedron self, IRotation rotation) -> double
        double IFormFactorPolyhedron::bottomZ(const IRotation &rotation) const final

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.IFormFactorPolyhedron_bottomZ(self, rotation)

    def topZ(self, rotation):
        r"""
        topZ(IFormFactorPolyhedron self, IRotation rotation) -> double
        double IFormFactorPolyhedron::topZ(const IRotation &rotation) const final

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.IFormFactorPolyhedron_topZ(self, rotation)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(IFormFactorPolyhedron self, cvector_t q) -> complex_t
        complex_t IFormFactorPolyhedron::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.IFormFactorPolyhedron_evaluate_for_q(self, q)

    def evaluate_centered(self, q):
        r"""
        evaluate_centered(IFormFactorPolyhedron self, cvector_t q) -> complex_t
        complex_t IFormFactorPolyhedron::evaluate_centered(cvector_t q) const

        """
        return _libBornAgainSample.IFormFactorPolyhedron_evaluate_centered(self, q)

    def volume(self):
        r"""
        volume(IFormFactorPolyhedron self) -> double
        double IFormFactorPolyhedron::volume() const final

        Returns the total volume of the particle of this form factor's shape. 

        """
        return _libBornAgainSample.IFormFactorPolyhedron_volume(self)

    def radialExtension(self):
        r"""
        radialExtension(IFormFactorPolyhedron self) -> double
        double IFormFactorPolyhedron::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.IFormFactorPolyhedron_radialExtension(self)

    def assert_platonic(self):
        r"""
        assert_platonic(IFormFactorPolyhedron self)
        void IFormFactorPolyhedron::assert_platonic() const

        Assertions for Platonic solid. 

        """
        return _libBornAgainSample.IFormFactorPolyhedron_assert_platonic(self)

# Register IFormFactorPolyhedron in _libBornAgainSample:
_libBornAgainSample.IFormFactorPolyhedron_swigregister(IFormFactorPolyhedron)

class IFormFactorPrism(IBornFF):
    r"""


    A prism with a polygonal base, for form factor computation.

    C++ includes: IFormFactorPrism.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainSample.delete_IFormFactorPrism

    def bottomZ(self, rotation):
        r"""
        bottomZ(IFormFactorPrism self, IRotation rotation) -> double
        double IFormFactorPrism::bottomZ(const IRotation &rotation) const final

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.IFormFactorPrism_bottomZ(self, rotation)

    def topZ(self, rotation):
        r"""
        topZ(IFormFactorPrism self, IRotation rotation) -> double
        double IFormFactorPrism::topZ(const IRotation &rotation) const final

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.IFormFactorPrism_topZ(self, rotation)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(IFormFactorPrism self, cvector_t q) -> complex_t
        complex_t IFormFactorPrism::evaluate_for_q(cvector_t q) const override

        Returns the form factor F(q) of this polyhedron, respecting the offset height/2. 

        """
        return _libBornAgainSample.IFormFactorPrism_evaluate_for_q(self, q)

    def volume(self):
        r"""
        volume(IFormFactorPrism self) -> double
        double IFormFactorPrism::volume() const override

        Returns the volume of this prism. 

        """
        return _libBornAgainSample.IFormFactorPrism_volume(self)

    def radialExtension(self):
        r"""
        radialExtension(IFormFactorPrism self) -> double
        double IFormFactorPrism::radialExtension() const override

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.IFormFactorPrism_radialExtension(self)

    def getHeight(self):
        r"""
        getHeight(IFormFactorPrism self) -> double
        double IFormFactorPrism::getHeight() const

        """
        return _libBornAgainSample.IFormFactorPrism_getHeight(self)

# Register IFormFactorPrism in _libBornAgainSample:
_libBornAgainSample.IFormFactorPrism_swigregister(IFormFactorPrism)

class IProfileRipple(IBornFF):
    r"""


    Base class for form factors with a cosine ripple profile in the yz plane.

    C++ includes: IProfileRipple.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getLength(self):
        r"""
        getLength(IProfileRipple self) -> double
        double IProfileRipple::getLength() const

        """
        return _libBornAgainSample.IProfileRipple_getLength(self)

    def getHeight(self):
        r"""
        getHeight(IProfileRipple self) -> double
        double IProfileRipple::getHeight() const

        """
        return _libBornAgainSample.IProfileRipple_getHeight(self)

    def getWidth(self):
        r"""
        getWidth(IProfileRipple self) -> double
        double IProfileRipple::getWidth() const

        """
        return _libBornAgainSample.IProfileRipple_getWidth(self)

    def radialExtension(self):
        r"""
        radialExtension(IProfileRipple self) -> double
        double IProfileRipple::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.IProfileRipple_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(IProfileRipple self, cvector_t q) -> complex_t
        complex_t IProfileRipple::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.IProfileRipple_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_IProfileRipple

# Register IProfileRipple in _libBornAgainSample:
_libBornAgainSample.IProfileRipple_swigregister(IProfileRipple)

class IProfileRectangularRipple(IProfileRipple):
    r"""


    Base class for form factors with a rectangular ripple (bar) profile in the yz plane.

    C++ includes: IProfileRipple.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainSample.delete_IProfileRectangularRipple

# Register IProfileRectangularRipple in _libBornAgainSample:
_libBornAgainSample.IProfileRectangularRipple_swigregister(IProfileRectangularRipple)

class ICosineRipple(IProfileRipple):
    r"""


    Base class for form factors with a cosine ripple profile in the yz plane.

    C++ includes: IProfileRipple.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainSample.delete_ICosineRipple

# Register ICosineRipple in _libBornAgainSample:
_libBornAgainSample.ICosineRipple_swigregister(ICosineRipple)

class ISawtoothRipple(IProfileRipple):
    r"""


    Base class for form factors with a triangular ripple profile in the yz plane.

    C++ includes: IProfileRipple.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getAsymmetry(self):
        r"""
        getAsymmetry(ISawtoothRipple self) -> double
        double ISawtoothRipple::getAsymmetry() const

        """
        return _libBornAgainSample.ISawtoothRipple_getAsymmetry(self)
    __swig_destroy__ = _libBornAgainSample.delete_ISawtoothRipple

# Register ISawtoothRipple in _libBornAgainSample:
_libBornAgainSample.ISawtoothRipple_swigregister(ISawtoothRipple)

class FormFactorAnisoPyramid(IFormFactorPolyhedron):
    r"""


    A frustum (truncated pyramid) with rectangular base.

    C++ includes: FormFactorAnisoPyramid.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorAnisoPyramid self, vdouble1d_t P) -> FormFactorAnisoPyramid
        __init__(FormFactorAnisoPyramid self, double length, double width, double height, double alpha) -> FormFactorAnisoPyramid
        FormFactorAnisoPyramid::FormFactorAnisoPyramid(double length, double width, double height, double alpha)

        """
        _libBornAgainSample.FormFactorAnisoPyramid_swiginit(self, _libBornAgainSample.new_FormFactorAnisoPyramid(*args))

    def clone(self):
        r"""
        clone(FormFactorAnisoPyramid self) -> FormFactorAnisoPyramid
        FormFactorAnisoPyramid* FormFactorAnisoPyramid::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorAnisoPyramid_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorAnisoPyramid self, INodeVisitor * visitor)
        void FormFactorAnisoPyramid::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorAnisoPyramid_accept(self, visitor)

    def getLength(self):
        r"""
        getLength(FormFactorAnisoPyramid self) -> double
        double FormFactorAnisoPyramid::getLength() const

        """
        return _libBornAgainSample.FormFactorAnisoPyramid_getLength(self)

    def getWidth(self):
        r"""
        getWidth(FormFactorAnisoPyramid self) -> double
        double FormFactorAnisoPyramid::getWidth() const

        """
        return _libBornAgainSample.FormFactorAnisoPyramid_getWidth(self)

    def getHeight(self):
        r"""
        getHeight(FormFactorAnisoPyramid self) -> double
        double FormFactorAnisoPyramid::getHeight() const

        """
        return _libBornAgainSample.FormFactorAnisoPyramid_getHeight(self)

    def getAlpha(self):
        r"""
        getAlpha(FormFactorAnisoPyramid self) -> double
        double FormFactorAnisoPyramid::getAlpha() const

        """
        return _libBornAgainSample.FormFactorAnisoPyramid_getAlpha(self)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorAnisoPyramid

# Register FormFactorAnisoPyramid in _libBornAgainSample:
_libBornAgainSample.FormFactorAnisoPyramid_swigregister(FormFactorAnisoPyramid)

class FormFactorBox(IFormFactorPrism):
    r"""


    A rectangular prism (parallelepiped).

    C++ includes: FormFactorBox.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorBox self, vdouble1d_t P) -> FormFactorBox
        __init__(FormFactorBox self, double length, double width, double height) -> FormFactorBox
        FormFactorBox::FormFactorBox(double length, double width, double height)

        """
        _libBornAgainSample.FormFactorBox_swiginit(self, _libBornAgainSample.new_FormFactorBox(*args))

    def clone(self):
        r"""
        clone(FormFactorBox self) -> FormFactorBox
        FormFactorBox* FormFactorBox::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorBox_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorBox self, INodeVisitor * visitor)
        void FormFactorBox::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorBox_accept(self, visitor)

    def getLength(self):
        r"""
        getLength(FormFactorBox self) -> double
        double FormFactorBox::getLength() const

        """
        return _libBornAgainSample.FormFactorBox_getLength(self)

    def getWidth(self):
        r"""
        getWidth(FormFactorBox self) -> double
        double FormFactorBox::getWidth() const

        """
        return _libBornAgainSample.FormFactorBox_getWidth(self)

    def volume(self):
        r"""
        volume(FormFactorBox self) -> double
        double FormFactorBox::volume() const final

        Returns the total volume of the particle of this form factor's shape. 

        """
        return _libBornAgainSample.FormFactorBox_volume(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorBox self) -> double
        double FormFactorBox::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorBox_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorBox self, cvector_t q) -> complex_t
        complex_t FormFactorBox::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorBox_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorBox

# Register FormFactorBox in _libBornAgainSample:
_libBornAgainSample.FormFactorBox_swigregister(FormFactorBox)

class FormFactorCantellatedCube(IFormFactorPolyhedron):
    r"""


    A cube, with truncation of all edges and corners, as in Croset (2017) Fig 7

    C++ includes: FormFactorCantellatedCube.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorCantellatedCube self, vdouble1d_t P) -> FormFactorCantellatedCube
        __init__(FormFactorCantellatedCube self, double length, double removed_length) -> FormFactorCantellatedCube
        FormFactorCantellatedCube::FormFactorCantellatedCube(double length, double removed_length)

        """
        _libBornAgainSample.FormFactorCantellatedCube_swiginit(self, _libBornAgainSample.new_FormFactorCantellatedCube(*args))

    def clone(self):
        r"""
        clone(FormFactorCantellatedCube self) -> FormFactorCantellatedCube
        FormFactorCantellatedCube* FormFactorCantellatedCube::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorCantellatedCube_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorCantellatedCube self, INodeVisitor * visitor)
        void FormFactorCantellatedCube::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorCantellatedCube_accept(self, visitor)

    def getLength(self):
        r"""
        getLength(FormFactorCantellatedCube self) -> double
        double FormFactorCantellatedCube::getLength() const

        """
        return _libBornAgainSample.FormFactorCantellatedCube_getLength(self)

    def getRemovedLength(self):
        r"""
        getRemovedLength(FormFactorCantellatedCube self) -> double
        double FormFactorCantellatedCube::getRemovedLength() const

        """
        return _libBornAgainSample.FormFactorCantellatedCube_getRemovedLength(self)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorCantellatedCube

# Register FormFactorCantellatedCube in _libBornAgainSample:
_libBornAgainSample.FormFactorCantellatedCube_swigregister(FormFactorCantellatedCube)

class FormFactorCone(IBornFF):
    r"""


    A conical frustum (cone truncated parallel to the base) with circular base.

    C++ includes: FormFactorCone.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorCone self, vdouble1d_t P) -> FormFactorCone
        __init__(FormFactorCone self, double radius, double height, double alpha) -> FormFactorCone
        FormFactorCone::FormFactorCone(double radius, double height, double alpha)

        """
        _libBornAgainSample.FormFactorCone_swiginit(self, _libBornAgainSample.new_FormFactorCone(*args))

    def clone(self):
        r"""
        clone(FormFactorCone self) -> FormFactorCone
        FormFactorCone* FormFactorCone::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorCone_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorCone self, INodeVisitor * visitor)
        void FormFactorCone::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorCone_accept(self, visitor)

    def getHeight(self):
        r"""
        getHeight(FormFactorCone self) -> double
        double FormFactorCone::getHeight() const

        """
        return _libBornAgainSample.FormFactorCone_getHeight(self)

    def getAlpha(self):
        r"""
        getAlpha(FormFactorCone self) -> double
        double FormFactorCone::getAlpha() const

        """
        return _libBornAgainSample.FormFactorCone_getAlpha(self)

    def getRadius(self):
        r"""
        getRadius(FormFactorCone self) -> double
        double FormFactorCone::getRadius() const

        """
        return _libBornAgainSample.FormFactorCone_getRadius(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorCone self) -> double
        double FormFactorCone::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorCone_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorCone self, cvector_t q) -> complex_t
        complex_t FormFactorCone::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorCone_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorCone

# Register FormFactorCone in _libBornAgainSample:
_libBornAgainSample.FormFactorCone_swigregister(FormFactorCone)

class FormFactorCone6(IFormFactorPolyhedron):
    r"""


    A frustum (truncated pyramid) with regular hexagonal base.

    C++ includes: FormFactorCone6.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorCone6 self, vdouble1d_t P) -> FormFactorCone6
        __init__(FormFactorCone6 self, double base_edge, double height, double alpha) -> FormFactorCone6
        FormFactorCone6::FormFactorCone6(double base_edge, double height, double alpha)

        """
        _libBornAgainSample.FormFactorCone6_swiginit(self, _libBornAgainSample.new_FormFactorCone6(*args))

    def clone(self):
        r"""
        clone(FormFactorCone6 self) -> FormFactorCone6
        FormFactorCone6* FormFactorCone6::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorCone6_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorCone6 self, INodeVisitor * visitor)
        void FormFactorCone6::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorCone6_accept(self, visitor)

    def getBaseEdge(self):
        r"""
        getBaseEdge(FormFactorCone6 self) -> double
        double FormFactorCone6::getBaseEdge() const

        """
        return _libBornAgainSample.FormFactorCone6_getBaseEdge(self)

    def getHeight(self):
        r"""
        getHeight(FormFactorCone6 self) -> double
        double FormFactorCone6::getHeight() const

        """
        return _libBornAgainSample.FormFactorCone6_getHeight(self)

    def getAlpha(self):
        r"""
        getAlpha(FormFactorCone6 self) -> double
        double FormFactorCone6::getAlpha() const

        """
        return _libBornAgainSample.FormFactorCone6_getAlpha(self)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorCone6

# Register FormFactorCone6 in _libBornAgainSample:
_libBornAgainSample.FormFactorCone6_swigregister(FormFactorCone6)

class FormFactorCosineRippleBox(ICosineRipple):
    r"""


    The form factor for a cosine ripple, with box profile in elongation direction.

    C++ includes: FormFactorCosineRipple.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorCosineRippleBox self, vdouble1d_t P) -> FormFactorCosineRippleBox
        __init__(FormFactorCosineRippleBox self, double length, double width, double height) -> FormFactorCosineRippleBox
        FormFactorCosineRippleBox::FormFactorCosineRippleBox(double length, double width, double height)

        """
        _libBornAgainSample.FormFactorCosineRippleBox_swiginit(self, _libBornAgainSample.new_FormFactorCosineRippleBox(*args))

    def clone(self):
        r"""
        clone(FormFactorCosineRippleBox self) -> FormFactorCosineRippleBox
        FormFactorCosineRippleBox * FormFactorCosineRippleBox::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorCosineRippleBox_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorCosineRippleBox self, INodeVisitor * visitor)
        void FormFactorCosineRippleBox::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorCosineRippleBox_accept(self, visitor)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorCosineRippleBox

# Register FormFactorCosineRippleBox in _libBornAgainSample:
_libBornAgainSample.FormFactorCosineRippleBox_swigregister(FormFactorCosineRippleBox)

class FormFactorCosineRippleGauss(ICosineRipple):
    r"""


    The form factor for a cosine ripple, with Gaussian profile in elongation direction.

    C++ includes: FormFactorCosineRipple.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorCosineRippleGauss self, vdouble1d_t P) -> FormFactorCosineRippleGauss
        __init__(FormFactorCosineRippleGauss self, double length, double width, double height) -> FormFactorCosineRippleGauss
        FormFactorCosineRippleGauss::FormFactorCosineRippleGauss(double length, double width, double height)

        """
        _libBornAgainSample.FormFactorCosineRippleGauss_swiginit(self, _libBornAgainSample.new_FormFactorCosineRippleGauss(*args))

    def clone(self):
        r"""
        clone(FormFactorCosineRippleGauss self) -> FormFactorCosineRippleGauss
        FormFactorCosineRippleGauss * FormFactorCosineRippleGauss::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorCosineRippleGauss_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorCosineRippleGauss self, INodeVisitor * visitor)
        void FormFactorCosineRippleGauss::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorCosineRippleGauss_accept(self, visitor)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorCosineRippleGauss

# Register FormFactorCosineRippleGauss in _libBornAgainSample:
_libBornAgainSample.FormFactorCosineRippleGauss_swigregister(FormFactorCosineRippleGauss)

class FormFactorCosineRippleLorentz(ICosineRipple):
    r"""


    The form factor for a cosine ripple, with Lorentz form factor in elongation direction.

    C++ includes: FormFactorCosineRipple.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorCosineRippleLorentz self, vdouble1d_t P) -> FormFactorCosineRippleLorentz
        __init__(FormFactorCosineRippleLorentz self, double length, double width, double height) -> FormFactorCosineRippleLorentz
        FormFactorCosineRippleLorentz::FormFactorCosineRippleLorentz(double length, double width, double height)

        """
        _libBornAgainSample.FormFactorCosineRippleLorentz_swiginit(self, _libBornAgainSample.new_FormFactorCosineRippleLorentz(*args))

    def clone(self):
        r"""
        clone(FormFactorCosineRippleLorentz self) -> FormFactorCosineRippleLorentz
        FormFactorCosineRippleLorentz * FormFactorCosineRippleLorentz::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorCosineRippleLorentz_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorCosineRippleLorentz self, INodeVisitor * visitor)
        void FormFactorCosineRippleLorentz::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorCosineRippleLorentz_accept(self, visitor)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorCosineRippleLorentz

# Register FormFactorCosineRippleLorentz in _libBornAgainSample:
_libBornAgainSample.FormFactorCosineRippleLorentz_swigregister(FormFactorCosineRippleLorentz)

class FormFactorCuboctahedron(IFormFactorPolyhedron):
    r"""


    A truncated bifrustum with quadratic base.

    C++ includes: FormFactorCuboctahedron.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorCuboctahedron self, vdouble1d_t P) -> FormFactorCuboctahedron
        __init__(FormFactorCuboctahedron self, double length, double height, double height_ratio, double alpha) -> FormFactorCuboctahedron
        FormFactorCuboctahedron::FormFactorCuboctahedron(double length, double height, double height_ratio, double alpha)

        """
        _libBornAgainSample.FormFactorCuboctahedron_swiginit(self, _libBornAgainSample.new_FormFactorCuboctahedron(*args))

    def clone(self):
        r"""
        clone(FormFactorCuboctahedron self) -> FormFactorCuboctahedron
        FormFactorCuboctahedron* FormFactorCuboctahedron::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorCuboctahedron_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorCuboctahedron self, INodeVisitor * visitor)
        void FormFactorCuboctahedron::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorCuboctahedron_accept(self, visitor)

    def getLength(self):
        r"""
        getLength(FormFactorCuboctahedron self) -> double
        double FormFactorCuboctahedron::getLength() const

        """
        return _libBornAgainSample.FormFactorCuboctahedron_getLength(self)

    def getHeight(self):
        r"""
        getHeight(FormFactorCuboctahedron self) -> double
        double FormFactorCuboctahedron::getHeight() const

        """
        return _libBornAgainSample.FormFactorCuboctahedron_getHeight(self)

    def getHeightRatio(self):
        r"""
        getHeightRatio(FormFactorCuboctahedron self) -> double
        double FormFactorCuboctahedron::getHeightRatio() const

        """
        return _libBornAgainSample.FormFactorCuboctahedron_getHeightRatio(self)

    def getAlpha(self):
        r"""
        getAlpha(FormFactorCuboctahedron self) -> double
        double FormFactorCuboctahedron::getAlpha() const

        """
        return _libBornAgainSample.FormFactorCuboctahedron_getAlpha(self)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorCuboctahedron

# Register FormFactorCuboctahedron in _libBornAgainSample:
_libBornAgainSample.FormFactorCuboctahedron_swigregister(FormFactorCuboctahedron)

class FormFactorCylinder(IBornFF):
    r"""


    A circular cylinder.

    C++ includes: FormFactorCylinder.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorCylinder self, vdouble1d_t P) -> FormFactorCylinder
        __init__(FormFactorCylinder self, double radius, double height) -> FormFactorCylinder
        FormFactorCylinder::FormFactorCylinder(double radius, double height)

        """
        _libBornAgainSample.FormFactorCylinder_swiginit(self, _libBornAgainSample.new_FormFactorCylinder(*args))

    def clone(self):
        r"""
        clone(FormFactorCylinder self) -> FormFactorCylinder
        FormFactorCylinder* FormFactorCylinder::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorCylinder_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorCylinder self, INodeVisitor * visitor)
        void FormFactorCylinder::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorCylinder_accept(self, visitor)

    def getHeight(self):
        r"""
        getHeight(FormFactorCylinder self) -> double
        double FormFactorCylinder::getHeight() const

        """
        return _libBornAgainSample.FormFactorCylinder_getHeight(self)

    def getRadius(self):
        r"""
        getRadius(FormFactorCylinder self) -> double
        double FormFactorCylinder::getRadius() const

        """
        return _libBornAgainSample.FormFactorCylinder_getRadius(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorCylinder self) -> double
        double FormFactorCylinder::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorCylinder_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorCylinder self, cvector_t q) -> complex_t
        complex_t FormFactorCylinder::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorCylinder_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorCylinder

# Register FormFactorCylinder in _libBornAgainSample:
_libBornAgainSample.FormFactorCylinder_swigregister(FormFactorCylinder)

class FormFactorDodecahedron(IFormFactorPolyhedron):
    r"""


    A regular dodecahedron.

    C++ includes: FormFactorDodecahedron.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorDodecahedron self, vdouble1d_t P) -> FormFactorDodecahedron
        __init__(FormFactorDodecahedron self, double edge) -> FormFactorDodecahedron
        FormFactorDodecahedron::FormFactorDodecahedron(double edge)

        """
        _libBornAgainSample.FormFactorDodecahedron_swiginit(self, _libBornAgainSample.new_FormFactorDodecahedron(*args))

    def clone(self):
        r"""
        clone(FormFactorDodecahedron self) -> FormFactorDodecahedron
        FormFactorDodecahedron* FormFactorDodecahedron::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorDodecahedron_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorDodecahedron self, INodeVisitor * visitor)
        void FormFactorDodecahedron::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorDodecahedron_accept(self, visitor)

    def getEdge(self):
        r"""
        getEdge(FormFactorDodecahedron self) -> double
        double FormFactorDodecahedron::getEdge() const

        """
        return _libBornAgainSample.FormFactorDodecahedron_getEdge(self)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorDodecahedron

# Register FormFactorDodecahedron in _libBornAgainSample:
_libBornAgainSample.FormFactorDodecahedron_swigregister(FormFactorDodecahedron)

class FormFactorDot(IBornFF):
    r"""


    A dot, with scattering power as a sphere of radius rscat, but with F(q)=const.

    C++ includes: FormFactorDot.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorDot self, vdouble1d_t P) -> FormFactorDot
        __init__(FormFactorDot self, double radius) -> FormFactorDot
        FormFactorDot::FormFactorDot(double radius)

        """
        _libBornAgainSample.FormFactorDot_swiginit(self, _libBornAgainSample.new_FormFactorDot(*args))

    def clone(self):
        r"""
        clone(FormFactorDot self) -> FormFactorDot
        FormFactorDot* FormFactorDot::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorDot_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorDot self, INodeVisitor * visitor)
        void FormFactorDot::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorDot_accept(self, visitor)

    def getRadius(self):
        r"""
        getRadius(FormFactorDot self) -> double
        double FormFactorDot::getRadius() const

        """
        return _libBornAgainSample.FormFactorDot_getRadius(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorDot self) -> double
        double FormFactorDot::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorDot_radialExtension(self)

    def bottomZ(self, arg2):
        r"""
        bottomZ(FormFactorDot self, IRotation arg2) -> double
        double FormFactorDot::bottomZ(const IRotation &) const final

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.FormFactorDot_bottomZ(self, arg2)

    def topZ(self, arg2):
        r"""
        topZ(FormFactorDot self, IRotation arg2) -> double
        double FormFactorDot::topZ(const IRotation &) const final

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.FormFactorDot_topZ(self, arg2)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorDot self, cvector_t q) -> complex_t
        complex_t FormFactorDot::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorDot_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorDot

# Register FormFactorDot in _libBornAgainSample:
_libBornAgainSample.FormFactorDot_swigregister(FormFactorDot)

class FormFactorEllipsoidalCylinder(IBornFF):
    r"""


    A cylinder with elliptical base.

    C++ includes: FormFactorEllipsoidalCylinder.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorEllipsoidalCylinder self, vdouble1d_t P) -> FormFactorEllipsoidalCylinder
        __init__(FormFactorEllipsoidalCylinder self, double radius_x, double radius_y, double height) -> FormFactorEllipsoidalCylinder
        FormFactorEllipsoidalCylinder::FormFactorEllipsoidalCylinder(double radius_x, double radius_y, double height)

        """
        _libBornAgainSample.FormFactorEllipsoidalCylinder_swiginit(self, _libBornAgainSample.new_FormFactorEllipsoidalCylinder(*args))

    def clone(self):
        r"""
        clone(FormFactorEllipsoidalCylinder self) -> FormFactorEllipsoidalCylinder
        FormFactorEllipsoidalCylinder* FormFactorEllipsoidalCylinder::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorEllipsoidalCylinder_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorEllipsoidalCylinder self, INodeVisitor * visitor)
        void FormFactorEllipsoidalCylinder::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorEllipsoidalCylinder_accept(self, visitor)

    def getRadiusX(self):
        r"""
        getRadiusX(FormFactorEllipsoidalCylinder self) -> double
        double FormFactorEllipsoidalCylinder::getRadiusX() const

        """
        return _libBornAgainSample.FormFactorEllipsoidalCylinder_getRadiusX(self)

    def getRadiusY(self):
        r"""
        getRadiusY(FormFactorEllipsoidalCylinder self) -> double
        double FormFactorEllipsoidalCylinder::getRadiusY() const

        """
        return _libBornAgainSample.FormFactorEllipsoidalCylinder_getRadiusY(self)

    def getHeight(self):
        r"""
        getHeight(FormFactorEllipsoidalCylinder self) -> double
        double FormFactorEllipsoidalCylinder::getHeight() const

        """
        return _libBornAgainSample.FormFactorEllipsoidalCylinder_getHeight(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorEllipsoidalCylinder self) -> double
        double FormFactorEllipsoidalCylinder::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorEllipsoidalCylinder_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorEllipsoidalCylinder self, cvector_t q) -> complex_t
        complex_t FormFactorEllipsoidalCylinder::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorEllipsoidalCylinder_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorEllipsoidalCylinder

# Register FormFactorEllipsoidalCylinder in _libBornAgainSample:
_libBornAgainSample.FormFactorEllipsoidalCylinder_swigregister(FormFactorEllipsoidalCylinder)

class FormFactorFullSphere(IBornFF):
    r"""


    A full sphere.

    C++ includes: FormFactorFullSphere.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorFullSphere self, vdouble1d_t P, bool position_at_center=False) -> FormFactorFullSphere
        __init__(FormFactorFullSphere self, double radius, bool position_at_center=False) -> FormFactorFullSphere
        FormFactorFullSphere::FormFactorFullSphere(double radius, bool position_at_center=false)

        """
        _libBornAgainSample.FormFactorFullSphere_swiginit(self, _libBornAgainSample.new_FormFactorFullSphere(*args))

    def clone(self):
        r"""
        clone(FormFactorFullSphere self) -> FormFactorFullSphere
        FormFactorFullSphere* FormFactorFullSphere::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorFullSphere_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorFullSphere self, INodeVisitor * visitor)
        void FormFactorFullSphere::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorFullSphere_accept(self, visitor)

    def getRadius(self):
        r"""
        getRadius(FormFactorFullSphere self) -> double
        double FormFactorFullSphere::getRadius() const

        """
        return _libBornAgainSample.FormFactorFullSphere_getRadius(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorFullSphere self) -> double
        double FormFactorFullSphere::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorFullSphere_radialExtension(self)

    def bottomZ(self, rotation):
        r"""
        bottomZ(FormFactorFullSphere self, IRotation rotation) -> double
        double FormFactorFullSphere::bottomZ(const IRotation &rotation) const final

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.FormFactorFullSphere_bottomZ(self, rotation)

    def topZ(self, rotation):
        r"""
        topZ(FormFactorFullSphere self, IRotation rotation) -> double
        double FormFactorFullSphere::topZ(const IRotation &rotation) const final

        Returns the z-coordinate of the lowest point in this shape after a given rotation. 

        """
        return _libBornAgainSample.FormFactorFullSphere_topZ(self, rotation)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorFullSphere self, cvector_t q) -> complex_t
        complex_t FormFactorFullSphere::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorFullSphere_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorFullSphere

# Register FormFactorFullSphere in _libBornAgainSample:
_libBornAgainSample.FormFactorFullSphere_swigregister(FormFactorFullSphere)

class FormFactorFullSpheroid(IBornFF):
    r"""


    A full spheroid (an ellipsoid with two equal axes, hence with circular cross section)

    C++ includes: FormFactorFullSpheroid.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorFullSpheroid self, vdouble1d_t P) -> FormFactorFullSpheroid
        __init__(FormFactorFullSpheroid self, double radius, double height) -> FormFactorFullSpheroid
        FormFactorFullSpheroid::FormFactorFullSpheroid(double radius, double height)

        """
        _libBornAgainSample.FormFactorFullSpheroid_swiginit(self, _libBornAgainSample.new_FormFactorFullSpheroid(*args))

    def clone(self):
        r"""
        clone(FormFactorFullSpheroid self) -> FormFactorFullSpheroid
        FormFactorFullSpheroid* FormFactorFullSpheroid::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorFullSpheroid_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorFullSpheroid self, INodeVisitor * visitor)
        void FormFactorFullSpheroid::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorFullSpheroid_accept(self, visitor)

    def getHeight(self):
        r"""
        getHeight(FormFactorFullSpheroid self) -> double
        double FormFactorFullSpheroid::getHeight() const

        """
        return _libBornAgainSample.FormFactorFullSpheroid_getHeight(self)

    def getRadius(self):
        r"""
        getRadius(FormFactorFullSpheroid self) -> double
        double FormFactorFullSpheroid::getRadius() const

        """
        return _libBornAgainSample.FormFactorFullSpheroid_getRadius(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorFullSpheroid self) -> double
        double FormFactorFullSpheroid::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorFullSpheroid_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorFullSpheroid self, cvector_t q) -> complex_t
        complex_t FormFactorFullSpheroid::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorFullSpheroid_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorFullSpheroid

# Register FormFactorFullSpheroid in _libBornAgainSample:
_libBornAgainSample.FormFactorFullSpheroid_swigregister(FormFactorFullSpheroid)

class FormFactorHemiEllipsoid(IBornFF):
    r"""


    An hemi ellipsoid, obtained by truncating a full ellipsoid in the middle plane spanned by two principal axes.

    C++ includes: FormFactorHemiEllipsoid.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorHemiEllipsoid self, vdouble1d_t P) -> FormFactorHemiEllipsoid
        __init__(FormFactorHemiEllipsoid self, double radius_x, double radius_y, double height) -> FormFactorHemiEllipsoid
        FormFactorHemiEllipsoid::FormFactorHemiEllipsoid(double radius_x, double radius_y, double height)

        """
        _libBornAgainSample.FormFactorHemiEllipsoid_swiginit(self, _libBornAgainSample.new_FormFactorHemiEllipsoid(*args))
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorHemiEllipsoid

    def clone(self):
        r"""
        clone(FormFactorHemiEllipsoid self) -> FormFactorHemiEllipsoid
        FormFactorHemiEllipsoid* FormFactorHemiEllipsoid::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorHemiEllipsoid_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorHemiEllipsoid self, INodeVisitor * visitor)
        void FormFactorHemiEllipsoid::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorHemiEllipsoid_accept(self, visitor)

    def getHeight(self):
        r"""
        getHeight(FormFactorHemiEllipsoid self) -> double
        double FormFactorHemiEllipsoid::getHeight() const

        """
        return _libBornAgainSample.FormFactorHemiEllipsoid_getHeight(self)

    def getRadiusX(self):
        r"""
        getRadiusX(FormFactorHemiEllipsoid self) -> double
        double FormFactorHemiEllipsoid::getRadiusX() const

        """
        return _libBornAgainSample.FormFactorHemiEllipsoid_getRadiusX(self)

    def getRadiusY(self):
        r"""
        getRadiusY(FormFactorHemiEllipsoid self) -> double
        double FormFactorHemiEllipsoid::getRadiusY() const

        """
        return _libBornAgainSample.FormFactorHemiEllipsoid_getRadiusY(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorHemiEllipsoid self) -> double
        double FormFactorHemiEllipsoid::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorHemiEllipsoid_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorHemiEllipsoid self, cvector_t q) -> complex_t
        complex_t FormFactorHemiEllipsoid::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorHemiEllipsoid_evaluate_for_q(self, q)

# Register FormFactorHemiEllipsoid in _libBornAgainSample:
_libBornAgainSample.FormFactorHemiEllipsoid_swigregister(FormFactorHemiEllipsoid)

class FormFactorHollowSphere(IBornFF):
    r"""


    Integrated full sphere form factor over a uniform distribution of radii.

    C++ includes: FormFactorHollowSphere.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorHollowSphere self, vdouble1d_t P) -> FormFactorHollowSphere
        __init__(FormFactorHollowSphere self, double mean, double full_width) -> FormFactorHollowSphere
        FormFactorHollowSphere::FormFactorHollowSphere(double mean, double full_width)

        """
        _libBornAgainSample.FormFactorHollowSphere_swiginit(self, _libBornAgainSample.new_FormFactorHollowSphere(*args))

    def clone(self):
        r"""
        clone(FormFactorHollowSphere self) -> FormFactorHollowSphere
        FormFactorHollowSphere* FormFactorHollowSphere::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorHollowSphere_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorHollowSphere self, INodeVisitor * visitor)
        void FormFactorHollowSphere::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorHollowSphere_accept(self, visitor)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorHollowSphere self) -> double
        double FormFactorHollowSphere::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorHollowSphere_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorHollowSphere self, cvector_t q) -> complex_t
        complex_t FormFactorHollowSphere::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorHollowSphere_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorHollowSphere

# Register FormFactorHollowSphere in _libBornAgainSample:
_libBornAgainSample.FormFactorHollowSphere_swigregister(FormFactorHollowSphere)

class FormFactorIcosahedron(IFormFactorPolyhedron):
    r"""


    A regular icosahedron.

    C++ includes: FormFactorIcosahedron.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorIcosahedron self, vdouble1d_t P) -> FormFactorIcosahedron
        __init__(FormFactorIcosahedron self, double edge) -> FormFactorIcosahedron
        FormFactorIcosahedron::FormFactorIcosahedron(double edge)

        """
        _libBornAgainSample.FormFactorIcosahedron_swiginit(self, _libBornAgainSample.new_FormFactorIcosahedron(*args))

    def clone(self):
        r"""
        clone(FormFactorIcosahedron self) -> FormFactorIcosahedron
        FormFactorIcosahedron* FormFactorIcosahedron::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorIcosahedron_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorIcosahedron self, INodeVisitor * visitor)
        void FormFactorIcosahedron::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorIcosahedron_accept(self, visitor)

    def getEdge(self):
        r"""
        getEdge(FormFactorIcosahedron self) -> double
        double FormFactorIcosahedron::getEdge() const

        """
        return _libBornAgainSample.FormFactorIcosahedron_getEdge(self)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorIcosahedron

# Register FormFactorIcosahedron in _libBornAgainSample:
_libBornAgainSample.FormFactorIcosahedron_swigregister(FormFactorIcosahedron)

class FormFactorLongBoxGauss(IBornFF):
    r"""


    The form factor for a long rectangular box.

    C++ includes: FormFactorLongBoxGauss.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorLongBoxGauss self, vdouble1d_t P) -> FormFactorLongBoxGauss
        __init__(FormFactorLongBoxGauss self, double length, double width, double height) -> FormFactorLongBoxGauss
        FormFactorLongBoxGauss::FormFactorLongBoxGauss(double length, double width, double height)

        """
        _libBornAgainSample.FormFactorLongBoxGauss_swiginit(self, _libBornAgainSample.new_FormFactorLongBoxGauss(*args))

    def clone(self):
        r"""
        clone(FormFactorLongBoxGauss self) -> FormFactorLongBoxGauss
        FormFactorLongBoxGauss* FormFactorLongBoxGauss::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorLongBoxGauss_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorLongBoxGauss self, INodeVisitor * visitor)
        void FormFactorLongBoxGauss::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorLongBoxGauss_accept(self, visitor)

    def getLength(self):
        r"""
        getLength(FormFactorLongBoxGauss self) -> double
        double FormFactorLongBoxGauss::getLength() const

        """
        return _libBornAgainSample.FormFactorLongBoxGauss_getLength(self)

    def getHeight(self):
        r"""
        getHeight(FormFactorLongBoxGauss self) -> double
        double FormFactorLongBoxGauss::getHeight() const

        """
        return _libBornAgainSample.FormFactorLongBoxGauss_getHeight(self)

    def getWidth(self):
        r"""
        getWidth(FormFactorLongBoxGauss self) -> double
        double FormFactorLongBoxGauss::getWidth() const

        """
        return _libBornAgainSample.FormFactorLongBoxGauss_getWidth(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorLongBoxGauss self) -> double
        double FormFactorLongBoxGauss::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorLongBoxGauss_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorLongBoxGauss self, cvector_t q) -> complex_t
        complex_t FormFactorLongBoxGauss::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorLongBoxGauss_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorLongBoxGauss

# Register FormFactorLongBoxGauss in _libBornAgainSample:
_libBornAgainSample.FormFactorLongBoxGauss_swigregister(FormFactorLongBoxGauss)

class FormFactorLongBoxLorentz(IBornFF):
    r"""


    The form factor for a long rectangular box.

    C++ includes: FormFactorLongBoxLorentz.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorLongBoxLorentz self, vdouble1d_t P) -> FormFactorLongBoxLorentz
        __init__(FormFactorLongBoxLorentz self, double length, double width, double height) -> FormFactorLongBoxLorentz
        FormFactorLongBoxLorentz::FormFactorLongBoxLorentz(double length, double width, double height)

        """
        _libBornAgainSample.FormFactorLongBoxLorentz_swiginit(self, _libBornAgainSample.new_FormFactorLongBoxLorentz(*args))

    def clone(self):
        r"""
        clone(FormFactorLongBoxLorentz self) -> FormFactorLongBoxLorentz
        FormFactorLongBoxLorentz* FormFactorLongBoxLorentz::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorLongBoxLorentz_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorLongBoxLorentz self, INodeVisitor * visitor)
        void FormFactorLongBoxLorentz::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorLongBoxLorentz_accept(self, visitor)

    def getLength(self):
        r"""
        getLength(FormFactorLongBoxLorentz self) -> double
        double FormFactorLongBoxLorentz::getLength() const

        """
        return _libBornAgainSample.FormFactorLongBoxLorentz_getLength(self)

    def getHeight(self):
        r"""
        getHeight(FormFactorLongBoxLorentz self) -> double
        double FormFactorLongBoxLorentz::getHeight() const

        """
        return _libBornAgainSample.FormFactorLongBoxLorentz_getHeight(self)

    def getWidth(self):
        r"""
        getWidth(FormFactorLongBoxLorentz self) -> double
        double FormFactorLongBoxLorentz::getWidth() const

        """
        return _libBornAgainSample.FormFactorLongBoxLorentz_getWidth(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorLongBoxLorentz self) -> double
        double FormFactorLongBoxLorentz::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorLongBoxLorentz_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorLongBoxLorentz self, cvector_t q) -> complex_t
        complex_t FormFactorLongBoxLorentz::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorLongBoxLorentz_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorLongBoxLorentz

# Register FormFactorLongBoxLorentz in _libBornAgainSample:
_libBornAgainSample.FormFactorLongBoxLorentz_swigregister(FormFactorLongBoxLorentz)

class FormFactorPrism3(IFormFactorPrism):
    r"""


    A prism based on an equilateral triangle.

    C++ includes: FormFactorPrism3.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorPrism3 self, vdouble1d_t P) -> FormFactorPrism3
        __init__(FormFactorPrism3 self, double base_edge, double height) -> FormFactorPrism3
        FormFactorPrism3::FormFactorPrism3(double base_edge, double height)

        """
        _libBornAgainSample.FormFactorPrism3_swiginit(self, _libBornAgainSample.new_FormFactorPrism3(*args))

    def clone(self):
        r"""
        clone(FormFactorPrism3 self) -> FormFactorPrism3
        FormFactorPrism3* FormFactorPrism3::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorPrism3_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorPrism3 self, INodeVisitor * visitor)
        void FormFactorPrism3::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorPrism3_accept(self, visitor)

    def getBaseEdge(self):
        r"""
        getBaseEdge(FormFactorPrism3 self) -> double
        double FormFactorPrism3::getBaseEdge() const

        """
        return _libBornAgainSample.FormFactorPrism3_getBaseEdge(self)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorPrism3

# Register FormFactorPrism3 in _libBornAgainSample:
_libBornAgainSample.FormFactorPrism3_swigregister(FormFactorPrism3)

class FormFactorPrism6(IFormFactorPrism):
    r"""


    A prism based on a regular hexagonal.

    C++ includes: FormFactorPrism6.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorPrism6 self, vdouble1d_t P) -> FormFactorPrism6
        __init__(FormFactorPrism6 self, double base_edge, double height) -> FormFactorPrism6
        FormFactorPrism6::FormFactorPrism6(double base_edge, double height)

        """
        _libBornAgainSample.FormFactorPrism6_swiginit(self, _libBornAgainSample.new_FormFactorPrism6(*args))

    def clone(self):
        r"""
        clone(FormFactorPrism6 self) -> FormFactorPrism6
        FormFactorPrism6* FormFactorPrism6::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorPrism6_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorPrism6 self, INodeVisitor * visitor)
        void FormFactorPrism6::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorPrism6_accept(self, visitor)

    def getBaseEdge(self):
        r"""
        getBaseEdge(FormFactorPrism6 self) -> double
        double FormFactorPrism6::getBaseEdge() const

        """
        return _libBornAgainSample.FormFactorPrism6_getBaseEdge(self)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorPrism6

# Register FormFactorPrism6 in _libBornAgainSample:
_libBornAgainSample.FormFactorPrism6_swigregister(FormFactorPrism6)

class FormFactorPyramid(IFormFactorPolyhedron):
    r"""


    A frustum with a quadratic base.

    C++ includes: FormFactorPyramid.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorPyramid self, vdouble1d_t P) -> FormFactorPyramid
        __init__(FormFactorPyramid self, double base_edge, double height, double alpha) -> FormFactorPyramid
        FormFactorPyramid::FormFactorPyramid(double base_edge, double height, double alpha)

        """
        _libBornAgainSample.FormFactorPyramid_swiginit(self, _libBornAgainSample.new_FormFactorPyramid(*args))

    def clone(self):
        r"""
        clone(FormFactorPyramid self) -> FormFactorPyramid
        FormFactorPyramid* FormFactorPyramid::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorPyramid_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorPyramid self, INodeVisitor * visitor)
        void FormFactorPyramid::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorPyramid_accept(self, visitor)

    def getHeight(self):
        r"""
        getHeight(FormFactorPyramid self) -> double
        double FormFactorPyramid::getHeight() const

        """
        return _libBornAgainSample.FormFactorPyramid_getHeight(self)

    def getBaseEdge(self):
        r"""
        getBaseEdge(FormFactorPyramid self) -> double
        double FormFactorPyramid::getBaseEdge() const

        """
        return _libBornAgainSample.FormFactorPyramid_getBaseEdge(self)

    def getAlpha(self):
        r"""
        getAlpha(FormFactorPyramid self) -> double
        double FormFactorPyramid::getAlpha() const

        """
        return _libBornAgainSample.FormFactorPyramid_getAlpha(self)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorPyramid

# Register FormFactorPyramid in _libBornAgainSample:
_libBornAgainSample.FormFactorPyramid_swigregister(FormFactorPyramid)

class FormFactorSawtoothRippleBox(ISawtoothRipple):
    r"""


    The form factor for a cosine ripple, with box profile in elongation direction.

    C++ includes: FormFactorSawtoothRipple.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorSawtoothRippleBox self, vdouble1d_t P) -> FormFactorSawtoothRippleBox
        __init__(FormFactorSawtoothRippleBox self, double length, double width, double height, double asymmetry) -> FormFactorSawtoothRippleBox
        FormFactorSawtoothRippleBox::FormFactorSawtoothRippleBox(double length, double width, double height, double asymmetry)

        """
        _libBornAgainSample.FormFactorSawtoothRippleBox_swiginit(self, _libBornAgainSample.new_FormFactorSawtoothRippleBox(*args))

    def clone(self):
        r"""
        clone(FormFactorSawtoothRippleBox self) -> FormFactorSawtoothRippleBox
        FormFactorSawtoothRippleBox * FormFactorSawtoothRippleBox::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorSawtoothRippleBox_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorSawtoothRippleBox self, INodeVisitor * visitor)
        void FormFactorSawtoothRippleBox::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorSawtoothRippleBox_accept(self, visitor)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorSawtoothRippleBox

# Register FormFactorSawtoothRippleBox in _libBornAgainSample:
_libBornAgainSample.FormFactorSawtoothRippleBox_swigregister(FormFactorSawtoothRippleBox)

class FormFactorSawtoothRippleGauss(ISawtoothRipple):
    r"""


    The form factor for a cosine ripple, with Gaussian profile in elongation direction.

    C++ includes: FormFactorSawtoothRipple.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorSawtoothRippleGauss self, vdouble1d_t P) -> FormFactorSawtoothRippleGauss
        __init__(FormFactorSawtoothRippleGauss self, double length, double width, double height, double asymmetry) -> FormFactorSawtoothRippleGauss
        FormFactorSawtoothRippleGauss::FormFactorSawtoothRippleGauss(double length, double width, double height, double asymmetry)

        """
        _libBornAgainSample.FormFactorSawtoothRippleGauss_swiginit(self, _libBornAgainSample.new_FormFactorSawtoothRippleGauss(*args))

    def clone(self):
        r"""
        clone(FormFactorSawtoothRippleGauss self) -> FormFactorSawtoothRippleGauss
        FormFactorSawtoothRippleGauss * FormFactorSawtoothRippleGauss::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorSawtoothRippleGauss_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorSawtoothRippleGauss self, INodeVisitor * visitor)
        void FormFactorSawtoothRippleGauss::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorSawtoothRippleGauss_accept(self, visitor)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorSawtoothRippleGauss

# Register FormFactorSawtoothRippleGauss in _libBornAgainSample:
_libBornAgainSample.FormFactorSawtoothRippleGauss_swigregister(FormFactorSawtoothRippleGauss)

class FormFactorSawtoothRippleLorentz(ISawtoothRipple):
    r"""


    The form factor for a cosine ripple, with Lorentz form factor in elongation direction.

    C++ includes: FormFactorSawtoothRipple.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorSawtoothRippleLorentz self, vdouble1d_t P) -> FormFactorSawtoothRippleLorentz
        __init__(FormFactorSawtoothRippleLorentz self, double length, double width, double height, double asymmetry) -> FormFactorSawtoothRippleLorentz
        FormFactorSawtoothRippleLorentz::FormFactorSawtoothRippleLorentz(double length, double width, double height, double asymmetry)

        """
        _libBornAgainSample.FormFactorSawtoothRippleLorentz_swiginit(self, _libBornAgainSample.new_FormFactorSawtoothRippleLorentz(*args))

    def clone(self):
        r"""
        clone(FormFactorSawtoothRippleLorentz self) -> FormFactorSawtoothRippleLorentz
        FormFactorSawtoothRippleLorentz * FormFactorSawtoothRippleLorentz::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorSawtoothRippleLorentz_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorSawtoothRippleLorentz self, INodeVisitor * visitor)
        void FormFactorSawtoothRippleLorentz::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorSawtoothRippleLorentz_accept(self, visitor)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorSawtoothRippleLorentz

# Register FormFactorSawtoothRippleLorentz in _libBornAgainSample:
_libBornAgainSample.FormFactorSawtoothRippleLorentz_swigregister(FormFactorSawtoothRippleLorentz)

class FormFactorTetrahedron(IFormFactorPolyhedron):
    r"""


    A frustum with equilateral trigonal base.

    C++ includes: FormFactorTetrahedron.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorTetrahedron self, vdouble1d_t P) -> FormFactorTetrahedron
        __init__(FormFactorTetrahedron self, double base_edge, double height, double alpha) -> FormFactorTetrahedron
        FormFactorTetrahedron::FormFactorTetrahedron(double base_edge, double height, double alpha)

        """
        _libBornAgainSample.FormFactorTetrahedron_swiginit(self, _libBornAgainSample.new_FormFactorTetrahedron(*args))

    def clone(self):
        r"""
        clone(FormFactorTetrahedron self) -> FormFactorTetrahedron
        FormFactorTetrahedron* FormFactorTetrahedron::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorTetrahedron_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorTetrahedron self, INodeVisitor * visitor)
        void FormFactorTetrahedron::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorTetrahedron_accept(self, visitor)

    def getBaseEdge(self):
        r"""
        getBaseEdge(FormFactorTetrahedron self) -> double
        double FormFactorTetrahedron::getBaseEdge() const

        """
        return _libBornAgainSample.FormFactorTetrahedron_getBaseEdge(self)

    def getHeight(self):
        r"""
        getHeight(FormFactorTetrahedron self) -> double
        double FormFactorTetrahedron::getHeight() const

        """
        return _libBornAgainSample.FormFactorTetrahedron_getHeight(self)

    def getAlpha(self):
        r"""
        getAlpha(FormFactorTetrahedron self) -> double
        double FormFactorTetrahedron::getAlpha() const

        """
        return _libBornAgainSample.FormFactorTetrahedron_getAlpha(self)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorTetrahedron

# Register FormFactorTetrahedron in _libBornAgainSample:
_libBornAgainSample.FormFactorTetrahedron_swigregister(FormFactorTetrahedron)

class FormFactorTruncatedCube(IFormFactorPolyhedron):
    r"""


    A cube, with tetrahedral truncation of all corners

    C++ includes: FormFactorTruncatedCube.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorTruncatedCube self, vdouble1d_t P) -> FormFactorTruncatedCube
        __init__(FormFactorTruncatedCube self, double length, double removed_length) -> FormFactorTruncatedCube
        FormFactorTruncatedCube::FormFactorTruncatedCube(double length, double removed_length)

        """
        _libBornAgainSample.FormFactorTruncatedCube_swiginit(self, _libBornAgainSample.new_FormFactorTruncatedCube(*args))

    def clone(self):
        r"""
        clone(FormFactorTruncatedCube self) -> FormFactorTruncatedCube
        FormFactorTruncatedCube* FormFactorTruncatedCube::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorTruncatedCube_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorTruncatedCube self, INodeVisitor * visitor)
        void FormFactorTruncatedCube::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorTruncatedCube_accept(self, visitor)

    def getLength(self):
        r"""
        getLength(FormFactorTruncatedCube self) -> double
        double FormFactorTruncatedCube::getLength() const

        """
        return _libBornAgainSample.FormFactorTruncatedCube_getLength(self)

    def getRemovedLength(self):
        r"""
        getRemovedLength(FormFactorTruncatedCube self) -> double
        double FormFactorTruncatedCube::getRemovedLength() const

        """
        return _libBornAgainSample.FormFactorTruncatedCube_getRemovedLength(self)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorTruncatedCube

# Register FormFactorTruncatedCube in _libBornAgainSample:
_libBornAgainSample.FormFactorTruncatedCube_swigregister(FormFactorTruncatedCube)

class FormFactorTruncatedSphere(IBornFF):
    r"""


    A truncated Sphere.

    C++ includes: FormFactorTruncatedSphere.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorTruncatedSphere self, vdouble1d_t P) -> FormFactorTruncatedSphere
        __init__(FormFactorTruncatedSphere self, double radius, double height, double dh) -> FormFactorTruncatedSphere
        FormFactorTruncatedSphere::FormFactorTruncatedSphere(double radius, double height, double dh)

        """
        _libBornAgainSample.FormFactorTruncatedSphere_swiginit(self, _libBornAgainSample.new_FormFactorTruncatedSphere(*args))

    def clone(self):
        r"""
        clone(FormFactorTruncatedSphere self) -> FormFactorTruncatedSphere
        FormFactorTruncatedSphere* FormFactorTruncatedSphere::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorTruncatedSphere_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorTruncatedSphere self, INodeVisitor * visitor)
        void FormFactorTruncatedSphere::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorTruncatedSphere_accept(self, visitor)

    def getHeight(self):
        r"""
        getHeight(FormFactorTruncatedSphere self) -> double
        double FormFactorTruncatedSphere::getHeight() const

        """
        return _libBornAgainSample.FormFactorTruncatedSphere_getHeight(self)

    def getRadius(self):
        r"""
        getRadius(FormFactorTruncatedSphere self) -> double
        double FormFactorTruncatedSphere::getRadius() const

        """
        return _libBornAgainSample.FormFactorTruncatedSphere_getRadius(self)

    def getRemovedTop(self):
        r"""
        getRemovedTop(FormFactorTruncatedSphere self) -> double
        double FormFactorTruncatedSphere::getRemovedTop() const

        """
        return _libBornAgainSample.FormFactorTruncatedSphere_getRemovedTop(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorTruncatedSphere self) -> double
        double FormFactorTruncatedSphere::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorTruncatedSphere_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorTruncatedSphere self, cvector_t q) -> complex_t
        complex_t FormFactorTruncatedSphere::evaluate_for_q(cvector_t q) const final

        Complex form factor. 

        """
        return _libBornAgainSample.FormFactorTruncatedSphere_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorTruncatedSphere

# Register FormFactorTruncatedSphere in _libBornAgainSample:
_libBornAgainSample.FormFactorTruncatedSphere_swigregister(FormFactorTruncatedSphere)

class FormFactorTruncatedSpheroid(IBornFF):
    r"""


    A truncated spheroid. An ellipsoid with two equal axis, truncated by a plane perpendicular to the third axis.

    C++ includes: FormFactorTruncatedSpheroid.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorTruncatedSpheroid self, vdouble1d_t P) -> FormFactorTruncatedSpheroid
        __init__(FormFactorTruncatedSpheroid self, double radius, double height, double height_flattening, double dh) -> FormFactorTruncatedSpheroid
        FormFactorTruncatedSpheroid::FormFactorTruncatedSpheroid(double radius, double height, double height_flattening, double dh)

        """
        _libBornAgainSample.FormFactorTruncatedSpheroid_swiginit(self, _libBornAgainSample.new_FormFactorTruncatedSpheroid(*args))

    def clone(self):
        r"""
        clone(FormFactorTruncatedSpheroid self) -> FormFactorTruncatedSpheroid
        FormFactorTruncatedSpheroid* FormFactorTruncatedSpheroid::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorTruncatedSpheroid_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorTruncatedSpheroid self, INodeVisitor * visitor)
        void FormFactorTruncatedSpheroid::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorTruncatedSpheroid_accept(self, visitor)

    def getRadius(self):
        r"""
        getRadius(FormFactorTruncatedSpheroid self) -> double
        double FormFactorTruncatedSpheroid::getRadius() const

        """
        return _libBornAgainSample.FormFactorTruncatedSpheroid_getRadius(self)

    def getHeight(self):
        r"""
        getHeight(FormFactorTruncatedSpheroid self) -> double
        double FormFactorTruncatedSpheroid::getHeight() const

        """
        return _libBornAgainSample.FormFactorTruncatedSpheroid_getHeight(self)

    def getHeightFlattening(self):
        r"""
        getHeightFlattening(FormFactorTruncatedSpheroid self) -> double
        double FormFactorTruncatedSpheroid::getHeightFlattening() const

        """
        return _libBornAgainSample.FormFactorTruncatedSpheroid_getHeightFlattening(self)

    def getRemovedTop(self):
        r"""
        getRemovedTop(FormFactorTruncatedSpheroid self) -> double
        double FormFactorTruncatedSpheroid::getRemovedTop() const

        """
        return _libBornAgainSample.FormFactorTruncatedSpheroid_getRemovedTop(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorTruncatedSpheroid self) -> double
        double FormFactorTruncatedSpheroid::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorTruncatedSpheroid_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorTruncatedSpheroid self, cvector_t q) -> complex_t
        complex_t FormFactorTruncatedSpheroid::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorTruncatedSpheroid_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorTruncatedSpheroid

# Register FormFactorTruncatedSpheroid in _libBornAgainSample:
_libBornAgainSample.FormFactorTruncatedSpheroid_swigregister(FormFactorTruncatedSpheroid)

class FormFactorGaussSphere(IBornFF):
    r"""


    The form factor of a Gaussian sphere.

    C++ includes: FormFactorGauss.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorGaussSphere self, vdouble1d_t P) -> FormFactorGaussSphere
        __init__(FormFactorGaussSphere self, double mean_radius) -> FormFactorGaussSphere
        FormFactorGaussSphere::FormFactorGaussSphere(double mean_radius)

        """
        _libBornAgainSample.FormFactorGaussSphere_swiginit(self, _libBornAgainSample.new_FormFactorGaussSphere(*args))

    def clone(self):
        r"""
        clone(FormFactorGaussSphere self) -> FormFactorGaussSphere
        FormFactorGaussSphere* FormFactorGaussSphere::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorGaussSphere_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorGaussSphere self, INodeVisitor * visitor)
        void FormFactorGaussSphere::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorGaussSphere_accept(self, visitor)

    def getMeanRadius(self):
        r"""
        getMeanRadius(FormFactorGaussSphere self) -> double
        double FormFactorGaussSphere::getMeanRadius() const

        """
        return _libBornAgainSample.FormFactorGaussSphere_getMeanRadius(self)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorGaussSphere self) -> double
        double FormFactorGaussSphere::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorGaussSphere_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorGaussSphere self, cvector_t q) -> complex_t
        complex_t FormFactorGaussSphere::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorGaussSphere_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorGaussSphere

# Register FormFactorGaussSphere in _libBornAgainSample:
_libBornAgainSample.FormFactorGaussSphere_swigregister(FormFactorGaussSphere)

class FormFactorSphereGaussianRadius(IBornFF):
    r"""


    A sphere with gaussian radius distribution.

    C++ includes: FormFactorSphereGaussianRadius.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorSphereGaussianRadius self, vdouble1d_t P) -> FormFactorSphereGaussianRadius
        __init__(FormFactorSphereGaussianRadius self, double mean, double sigma) -> FormFactorSphereGaussianRadius
        FormFactorSphereGaussianRadius::FormFactorSphereGaussianRadius(double mean, double sigma)

        """
        _libBornAgainSample.FormFactorSphereGaussianRadius_swiginit(self, _libBornAgainSample.new_FormFactorSphereGaussianRadius(*args))

    def clone(self):
        r"""
        clone(FormFactorSphereGaussianRadius self) -> FormFactorSphereGaussianRadius
        FormFactorSphereGaussianRadius* FormFactorSphereGaussianRadius::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorSphereGaussianRadius_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorSphereGaussianRadius self, INodeVisitor * visitor)
        void FormFactorSphereGaussianRadius::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorSphereGaussianRadius_accept(self, visitor)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorSphereGaussianRadius self) -> double
        double FormFactorSphereGaussianRadius::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorSphereGaussianRadius_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorSphereGaussianRadius self, cvector_t q) -> complex_t
        complex_t FormFactorSphereGaussianRadius::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorSphereGaussianRadius_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorSphereGaussianRadius

# Register FormFactorSphereGaussianRadius in _libBornAgainSample:
_libBornAgainSample.FormFactorSphereGaussianRadius_swigregister(FormFactorSphereGaussianRadius)

class FormFactorSphereLogNormalRadius(IBornFF):
    r"""


    A sphere with log normal radius distribution.

    C++ includes: FormFactorSphereLogNormalRadius.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FormFactorSphereLogNormalRadius self, vdouble1d_t P, size_t n_samples=0) -> FormFactorSphereLogNormalRadius
        __init__(FormFactorSphereLogNormalRadius self, double mean, double scale_param, size_t n_samples) -> FormFactorSphereLogNormalRadius
        FormFactorSphereLogNormalRadius::FormFactorSphereLogNormalRadius(double mean, double scale_param, size_t n_samples)

        """
        _libBornAgainSample.FormFactorSphereLogNormalRadius_swiginit(self, _libBornAgainSample.new_FormFactorSphereLogNormalRadius(*args))

    def clone(self):
        r"""
        clone(FormFactorSphereLogNormalRadius self) -> FormFactorSphereLogNormalRadius
        FormFactorSphereLogNormalRadius * FormFactorSphereLogNormalRadius::clone() const final

        Returns a clone of this  ISampleNode object. 

        """
        return _libBornAgainSample.FormFactorSphereLogNormalRadius_clone(self)

    def accept(self, visitor):
        r"""
        accept(FormFactorSphereLogNormalRadius self, INodeVisitor * visitor)
        void FormFactorSphereLogNormalRadius::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.FormFactorSphereLogNormalRadius_accept(self, visitor)

    def radialExtension(self):
        r"""
        radialExtension(FormFactorSphereLogNormalRadius self) -> double
        double FormFactorSphereLogNormalRadius::radialExtension() const final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainSample.FormFactorSphereLogNormalRadius_radialExtension(self)

    def evaluate_for_q(self, q):
        r"""
        evaluate_for_q(FormFactorSphereLogNormalRadius self, cvector_t q) -> complex_t
        complex_t FormFactorSphereLogNormalRadius::evaluate_for_q(cvector_t q) const final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainSample.FormFactorSphereLogNormalRadius_evaluate_for_q(self, q)
    __swig_destroy__ = _libBornAgainSample.delete_FormFactorSphereLogNormalRadius

# Register FormFactorSphereLogNormalRadius in _libBornAgainSample:
_libBornAgainSample.FormFactorSphereLogNormalRadius_swigregister(FormFactorSphereLogNormalRadius)

class ISelectionRule(object):
    r"""


    Abstract base class for selection rules.

    C++ includes: ISelectionRule.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainSample.delete_ISelectionRule

    def clone(self):
        r"""
        clone(ISelectionRule self) -> ISelectionRule
        virtual ISelectionRule* ISelectionRule::clone() const =0

        """
        return _libBornAgainSample.ISelectionRule_clone(self)

    def coordinateSelected(self, coordinate):
        r"""
        coordinateSelected(ISelectionRule self, ivector_t const & coordinate) -> bool
        virtual bool ISelectionRule::coordinateSelected(const ivector_t &coordinate) const =0

        """
        return _libBornAgainSample.ISelectionRule_coordinateSelected(self, coordinate)

# Register ISelectionRule in _libBornAgainSample:
_libBornAgainSample.ISelectionRule_swigregister(ISelectionRule)

class SimpleSelectionRule(ISelectionRule):
    r"""


    Selection rule (v*q)modulus!=0, defined by vector v(a,b,c) and modulus.

    C++ includes: ISelectionRule.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, a, b, c, modulus):
        r"""
        __init__(SimpleSelectionRule self, int a, int b, int c, int modulus) -> SimpleSelectionRule
        SimpleSelectionRule::SimpleSelectionRule(int a, int b, int c, int modulus)

        """
        _libBornAgainSample.SimpleSelectionRule_swiginit(self, _libBornAgainSample.new_SimpleSelectionRule(a, b, c, modulus))
    __swig_destroy__ = _libBornAgainSample.delete_SimpleSelectionRule

    def clone(self):
        r"""
        clone(SimpleSelectionRule self) -> SimpleSelectionRule
        SimpleSelectionRule * SimpleSelectionRule::clone() const

        """
        return _libBornAgainSample.SimpleSelectionRule_clone(self)

    def coordinateSelected(self, coordinate):
        r"""
        coordinateSelected(SimpleSelectionRule self, ivector_t const & coordinate) -> bool
        bool SimpleSelectionRule::coordinateSelected(const ivector_t &coordinate) const

        """
        return _libBornAgainSample.SimpleSelectionRule_coordinateSelected(self, coordinate)

# Register SimpleSelectionRule in _libBornAgainSample:
_libBornAgainSample.SimpleSelectionRule_swigregister(SimpleSelectionRule)

class Lattice3D(libBornAgainParam.INode):
    r"""


    A Bravais lattice, characterized by three basis vectors, and optionally an  ISelectionRule.

    C++ includes: Lattice3D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Lattice3D self, kvector_t a, kvector_t b, kvector_t c) -> Lattice3D
        __init__(Lattice3D self, Lattice3D lattice) -> Lattice3D
        Lattice3D::Lattice3D(const Lattice3D &lattice)

        """
        _libBornAgainSample.Lattice3D_swiginit(self, _libBornAgainSample.new_Lattice3D(*args))
    __swig_destroy__ = _libBornAgainSample.delete_Lattice3D

    def accept(self, visitor):
        r"""
        accept(Lattice3D self, INodeVisitor * visitor)
        void Lattice3D::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainSample.Lattice3D_accept(self, visitor)

    def transformed(self, transform):
        r"""
        transformed(Lattice3D self, Transform3D const & transform) -> Lattice3D
        Lattice3D Lattice3D::transformed(const Transform3D &transform) const

        Creates transformed lattice. 

        """
        return _libBornAgainSample.Lattice3D_transformed(self, transform)

    def initialize(self):
        r"""
        initialize(Lattice3D self)
        void Lattice3D::initialize()

        Initializes cached data. 

        """
        return _libBornAgainSample.Lattice3D_initialize(self)

    def getBasisVectorA(self):
        r"""
        getBasisVectorA(Lattice3D self) -> kvector_t
        kvector_t Lattice3D::getBasisVectorA() const

        Returns basis vector a. 

        """
        return _libBornAgainSample.Lattice3D_getBasisVectorA(self)

    def getBasisVectorB(self):
        r"""
        getBasisVectorB(Lattice3D self) -> kvector_t
        kvector_t Lattice3D::getBasisVectorB() const

        Returns basis vector b. 

        """
        return _libBornAgainSample.Lattice3D_getBasisVectorB(self)

    def getBasisVectorC(self):
        r"""
        getBasisVectorC(Lattice3D self) -> kvector_t
        kvector_t Lattice3D::getBasisVectorC() const

        Returns basis vector c. 

        """
        return _libBornAgainSample.Lattice3D_getBasisVectorC(self)

    def getMillerDirection(self, h, k, l):
        r"""
        getMillerDirection(Lattice3D self, double h, double k, double l) -> kvector_t
        kvector_t Lattice3D::getMillerDirection(double h, double k, double l) const

        Returns normalized direction corresponding to the given Miller indices.

        Currently unused but may be useful for checks. 

        """
        return _libBornAgainSample.Lattice3D_getMillerDirection(self, h, k, l)

    def unitCellVolume(self):
        r"""
        unitCellVolume(Lattice3D self) -> double
        double Lattice3D::unitCellVolume() const

        Returns the volume of the unit cell. 

        """
        return _libBornAgainSample.Lattice3D_unitCellVolume(self)

    def getReciprocalLatticeBasis(self, ra, rb, rc):
        r"""
        getReciprocalLatticeBasis(Lattice3D self, kvector_t ra, kvector_t rb, kvector_t rc)
        void Lattice3D::getReciprocalLatticeBasis(kvector_t &ra, kvector_t &rb, kvector_t &rc) const

        Returns the reciprocal basis vectors.

        Currently only used in tests. 

        """
        return _libBornAgainSample.Lattice3D_getReciprocalLatticeBasis(self, ra, rb, rc)

    def getNearestReciprocalLatticeVectorCoordinates(self, q):
        r"""
        getNearestReciprocalLatticeVectorCoordinates(Lattice3D self, kvector_t q) -> ivector_t
        ivector_t Lattice3D::getNearestReciprocalLatticeVectorCoordinates(const kvector_t q) const

        Returns the nearest reciprocal lattice point from a given vector. 

        """
        return _libBornAgainSample.Lattice3D_getNearestReciprocalLatticeVectorCoordinates(self, q)

    def reciprocalLatticeVectorsWithinRadius(self, q, dq):
        r"""
        reciprocalLatticeVectorsWithinRadius(Lattice3D self, kvector_t q, double dq) -> vector_kvector_t
        std::vector< kvector_t > Lattice3D::reciprocalLatticeVectorsWithinRadius(const kvector_t q, double dq) const

        Returns a list of reciprocal lattice vectors within distance dq of a vector q. 

        """
        return _libBornAgainSample.Lattice3D_reciprocalLatticeVectorsWithinRadius(self, q, dq)

    def setSelectionRule(self, selection_rule):
        r"""
        setSelectionRule(Lattice3D self, ISelectionRule selection_rule)
        void Lattice3D::setSelectionRule(const ISelectionRule &selection_rule)

        Sets a selection rule for the reciprocal vectors. 

        """
        return _libBornAgainSample.Lattice3D_setSelectionRule(self, selection_rule)

# Register Lattice3D in _libBornAgainSample:
_libBornAgainSample.Lattice3D_swigregister(Lattice3D)

class Lattice2D(libBornAgainBase.ICloneable, libBornAgainParam.INode):
    r"""


    A two-dimensional Bravais lattice.

    C++ includes: Lattice2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        r"""
        clone(Lattice2D self) -> Lattice2D
        virtual Lattice2D* Lattice2D::clone() const =0

        """
        return _libBornAgainSample.Lattice2D_clone(self)

    def length1(self):
        r"""
        length1(Lattice2D self) -> double
        virtual double Lattice2D::length1() const =0

        """
        return _libBornAgainSample.Lattice2D_length1(self)

    def length2(self):
        r"""
        length2(Lattice2D self) -> double
        virtual double Lattice2D::length2() const =0

        """
        return _libBornAgainSample.Lattice2D_length2(self)

    def latticeAngle(self):
        r"""
        latticeAngle(Lattice2D self) -> double
        virtual double Lattice2D::latticeAngle() const =0

        """
        return _libBornAgainSample.Lattice2D_latticeAngle(self)

    def unitCellArea(self):
        r"""
        unitCellArea(Lattice2D self) -> double
        virtual double Lattice2D::unitCellArea() const =0

        """
        return _libBornAgainSample.Lattice2D_unitCellArea(self)

    def rotationAngle(self):
        r"""
        rotationAngle(Lattice2D self) -> double
        double Lattice2D::rotationAngle() const

        """
        return _libBornAgainSample.Lattice2D_rotationAngle(self)

    def reciprocalBases(self):
        r"""
        reciprocalBases(Lattice2D self) -> Lattice2D::ReciprocalBases
        Lattice2D::ReciprocalBases Lattice2D::reciprocalBases() const

        """
        return _libBornAgainSample.Lattice2D_reciprocalBases(self)

    def setRotationEnabled(self, enabled):
        r"""
        setRotationEnabled(Lattice2D self, bool enabled)
        void Lattice2D::setRotationEnabled(bool enabled)

        """
        return _libBornAgainSample.Lattice2D_setRotationEnabled(self, enabled)
    __swig_destroy__ = _libBornAgainSample.delete_Lattice2D

# Register Lattice2D in _libBornAgainSample:
_libBornAgainSample.Lattice2D_swigregister(Lattice2D)

class BasicLattice2D(Lattice2D):
    r"""


    A two-dimensional Bravais lattice with no special symmetry.

    C++ includes: Lattice2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length1, length2, angle, xi):
        r"""
        __init__(BasicLattice2D self, double length1, double length2, double angle, double xi) -> BasicLattice2D
        BasicLattice2D::BasicLattice2D(double length1, double length2, double angle, double xi)

        """
        _libBornAgainSample.BasicLattice2D_swiginit(self, _libBornAgainSample.new_BasicLattice2D(length1, length2, angle, xi))

    def clone(self):
        r"""
        clone(BasicLattice2D self) -> BasicLattice2D
        BasicLattice2D * BasicLattice2D::clone() const

        """
        return _libBornAgainSample.BasicLattice2D_clone(self)

    def accept(self, visitor):
        r"""
        accept(BasicLattice2D self, INodeVisitor * visitor)
        void BasicLattice2D::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.BasicLattice2D_accept(self, visitor)

    def length1(self):
        r"""
        length1(BasicLattice2D self) -> double
        virtual double BasicLattice2D::length1() const

        """
        return _libBornAgainSample.BasicLattice2D_length1(self)

    def length2(self):
        r"""
        length2(BasicLattice2D self) -> double
        virtual double BasicLattice2D::length2() const

        """
        return _libBornAgainSample.BasicLattice2D_length2(self)

    def latticeAngle(self):
        r"""
        latticeAngle(BasicLattice2D self) -> double
        virtual double BasicLattice2D::latticeAngle() const

        """
        return _libBornAgainSample.BasicLattice2D_latticeAngle(self)

    def unitCellArea(self):
        r"""
        unitCellArea(BasicLattice2D self) -> double
        double BasicLattice2D::unitCellArea() const

        """
        return _libBornAgainSample.BasicLattice2D_unitCellArea(self)
    __swig_destroy__ = _libBornAgainSample.delete_BasicLattice2D

# Register BasicLattice2D in _libBornAgainSample:
_libBornAgainSample.BasicLattice2D_swigregister(BasicLattice2D)

class SquareLattice2D(Lattice2D):
    r"""


    A two-dimensional Bravais lattice with square unit cell.

    C++ includes: Lattice2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length, xi=0.0):
        r"""
        __init__(SquareLattice2D self, double length, double xi=0.0) -> SquareLattice2D
        SquareLattice2D::SquareLattice2D(double length, double xi=0.0)

        """
        _libBornAgainSample.SquareLattice2D_swiginit(self, _libBornAgainSample.new_SquareLattice2D(length, xi))

    def clone(self):
        r"""
        clone(SquareLattice2D self) -> SquareLattice2D
        SquareLattice2D * SquareLattice2D::clone() const

        """
        return _libBornAgainSample.SquareLattice2D_clone(self)

    def accept(self, visitor):
        r"""
        accept(SquareLattice2D self, INodeVisitor * visitor)
        void SquareLattice2D::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.SquareLattice2D_accept(self, visitor)

    def length1(self):
        r"""
        length1(SquareLattice2D self) -> double
        virtual double SquareLattice2D::length1() const

        """
        return _libBornAgainSample.SquareLattice2D_length1(self)

    def length2(self):
        r"""
        length2(SquareLattice2D self) -> double
        virtual double SquareLattice2D::length2() const

        """
        return _libBornAgainSample.SquareLattice2D_length2(self)

    def latticeAngle(self):
        r"""
        latticeAngle(SquareLattice2D self) -> double
        double SquareLattice2D::latticeAngle() const

        """
        return _libBornAgainSample.SquareLattice2D_latticeAngle(self)

    def unitCellArea(self):
        r"""
        unitCellArea(SquareLattice2D self) -> double
        double SquareLattice2D::unitCellArea() const

        """
        return _libBornAgainSample.SquareLattice2D_unitCellArea(self)
    __swig_destroy__ = _libBornAgainSample.delete_SquareLattice2D

# Register SquareLattice2D in _libBornAgainSample:
_libBornAgainSample.SquareLattice2D_swigregister(SquareLattice2D)

class HexagonalLattice2D(Lattice2D):
    r"""


    A two-dimensional Bravais lattice with hexagonal symmetry.

    C++ includes: Lattice2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length, xi):
        r"""
        __init__(HexagonalLattice2D self, double length, double xi) -> HexagonalLattice2D
        HexagonalLattice2D::HexagonalLattice2D(double length, double xi)

        """
        _libBornAgainSample.HexagonalLattice2D_swiginit(self, _libBornAgainSample.new_HexagonalLattice2D(length, xi))

    def clone(self):
        r"""
        clone(HexagonalLattice2D self) -> HexagonalLattice2D
        HexagonalLattice2D * HexagonalLattice2D::clone() const

        """
        return _libBornAgainSample.HexagonalLattice2D_clone(self)

    def accept(self, visitor):
        r"""
        accept(HexagonalLattice2D self, INodeVisitor * visitor)
        void HexagonalLattice2D::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainSample.HexagonalLattice2D_accept(self, visitor)

    def length1(self):
        r"""
        length1(HexagonalLattice2D self) -> double
        virtual double HexagonalLattice2D::length1() const

        """
        return _libBornAgainSample.HexagonalLattice2D_length1(self)

    def length2(self):
        r"""
        length2(HexagonalLattice2D self) -> double
        virtual double HexagonalLattice2D::length2() const

        """
        return _libBornAgainSample.HexagonalLattice2D_length2(self)

    def latticeAngle(self):
        r"""
        latticeAngle(HexagonalLattice2D self) -> double
        double HexagonalLattice2D::latticeAngle() const

        """
        return _libBornAgainSample.HexagonalLattice2D_latticeAngle(self)

    def unitCellArea(self):
        r"""
        unitCellArea(HexagonalLattice2D self) -> double
        double HexagonalLattice2D::unitCellArea() const

        """
        return _libBornAgainSample.HexagonalLattice2D_unitCellArea(self)
    __swig_destroy__ = _libBornAgainSample.delete_HexagonalLattice2D

# Register HexagonalLattice2D in _libBornAgainSample:
_libBornAgainSample.HexagonalLattice2D_swigregister(HexagonalLattice2D)


def CubicLattice(a):
    r"""
    CubicLattice(double a) -> Lattice3D
    Lattice3D bake::CubicLattice(double a)

    Returns a primitive cubic (cP) lattice with edge length a. 

    """
    return _libBornAgainSample.CubicLattice(a)

def FCCLattice(a):
    r"""
    FCCLattice(double a) -> Lattice3D
    Lattice3D bake::FCCLattice(double a)

    Returns a face-centered cubic (cF) lattice with edge length a. 

    """
    return _libBornAgainSample.FCCLattice(a)

def HexagonalLattice(a, c):
    r"""
    HexagonalLattice(double a, double c) -> Lattice3D
    Lattice3D bake::HexagonalLattice(double a, double c)

    Returns a primitive hexagonal (hP) lattice with hexagonal edge a and height c. 

    """
    return _libBornAgainSample.HexagonalLattice(a, c)

def HCPLattice(a, c):
    r"""
    HCPLattice(double a, double c) -> Lattice3D
    Lattice3D bake::HCPLattice(double a, double c)

    TODO: Clarify how this is meant: HCP is not a Bravais lattice. 

    """
    return _libBornAgainSample.HCPLattice(a, c)

def TetragonalLattice(a, c):
    r"""
    TetragonalLattice(double a, double c) -> Lattice3D
    Lattice3D bake::TetragonalLattice(double a, double c)

    Returns a primitive tetragonal (tP) lattice with square base edge a and height c. 

    """
    return _libBornAgainSample.TetragonalLattice(a, c)

def BCTLattice(a, c):
    r"""
    BCTLattice(double a, double c) -> Lattice3D
    Lattice3D bake::BCTLattice(double a, double c)

    Returns a body-centered cubic (cI) lattice with edge length a. TODO: Clarify meaning of c 

    """
    return _libBornAgainSample.BCTLattice(a, c)
class ISampleBuilder(libBornAgainParam.IParametricComponent):
    r"""


    Interface to the class capable to build samples to simulate.

    C++ includes: ISampleBuilder.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(ISampleBuilder self) -> ISampleBuilder
        ISampleBuilder::ISampleBuilder()

        """
        if self.__class__ == ISampleBuilder:
            _self = None
        else:
            _self = self
        _libBornAgainSample.ISampleBuilder_swiginit(self, _libBornAgainSample.new_ISampleBuilder(_self, ))
    __swig_destroy__ = _libBornAgainSample.delete_ISampleBuilder

    def buildSample(self):
        r"""
        buildSample(ISampleBuilder self) -> MultiLayer
        virtual MultiLayer* ISampleBuilder::buildSample() const =0

        """
        return _libBornAgainSample.ISampleBuilder_buildSample(self)

    def createSampleByIndex(self, arg0):
        r"""
        createSampleByIndex(ISampleBuilder self, size_t arg0) -> MultiLayer
        virtual MultiLayer* ISampleBuilder::createSampleByIndex(size_t)

        """
        return _libBornAgainSample.ISampleBuilder_createSampleByIndex(self, arg0)

    def size(self):
        r"""
        size(ISampleBuilder self) -> size_t
        virtual size_t ISampleBuilder::size()

        """
        return _libBornAgainSample.ISampleBuilder_size(self)

    def registerParameter(self, name, parpointer):
        r"""registerParameter(ISampleBuilder self, std::string const & name, int64_t parpointer) -> RealParameter *"""
        return _libBornAgainSample.ISampleBuilder_registerParameter(self, name, parpointer)

    def setParameterValue(self, name, value):
        r"""setParameterValue(ISampleBuilder self, std::string const & name, double value)"""
        return _libBornAgainSample.ISampleBuilder_setParameterValue(self, name, value)

    def parametersToString(self):
        r"""parametersToString(ISampleBuilder self) -> std::string"""
        return _libBornAgainSample.ISampleBuilder_parametersToString(self)

    def createParameterTree(self):
        r"""createParameterTree(ISampleBuilder self) -> ParameterPool"""
        return _libBornAgainSample.ISampleBuilder_createParameterTree(self)

    def parameterPool(self):
        r"""parameterPool(ISampleBuilder self) -> ParameterPool"""
        return _libBornAgainSample.ISampleBuilder_parameterPool(self)

    def onChange(self):
        r"""onChange(ISampleBuilder self)"""
        return _libBornAgainSample.ISampleBuilder_onChange(self)
    def __disown__(self):
        self.this.disown()
        _libBornAgainSample.disown_ISampleBuilder(self)
        return weakref.proxy(self)

# Register ISampleBuilder in _libBornAgainSample:
_libBornAgainSample.ISampleBuilder_swigregister(ISampleBuilder)

class SampleBuilderFactory(SampleBuilderFactoryTemp):
    r"""


    Factory to create standard pre-defined samples

    C++ includes: SampleBuilderFactory.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(SampleBuilderFactory self) -> SampleBuilderFactory
        SampleBuilderFactory::SampleBuilderFactory()

        """
        _libBornAgainSample.SampleBuilderFactory_swiginit(self, _libBornAgainSample.new_SampleBuilderFactory())

    def createSampleByName(self, name):
        r"""
        createSampleByName(SampleBuilderFactory self, std::string const & name) -> MultiLayer
        MultiLayer * SampleBuilderFactory::createSampleByName(const std::string &name)

        Retrieves a SampleBuilder from the registry, does the build, and returns the result. 

        """
        return _libBornAgainSample.SampleBuilderFactory_createSampleByName(self, name)
    __swig_destroy__ = _libBornAgainSample.delete_SampleBuilderFactory

# Register SampleBuilderFactory in _libBornAgainSample:
_libBornAgainSample.SampleBuilderFactory_swigregister(SampleBuilderFactory)


def materialProfile(multilayer, n_points=400, z_min=None, z_max=None):
    """
    Creates a material profile from the given multilayer. If no limits are given,
    it will provide sensible default values, considering the included particles and
    interface roughnesses.
    :param multilayer: bornagain.MultiLayer object
    :param n_points: number of points to generate
    :param z_min: starting value for z
    :param z_max: ending value for z
    :return: numpy arrays containing z positions and the complex material values in those positions
    """
    def_z_min, def_z_max = defaultMaterialProfileLimits(multilayer)
    z_min = def_z_min if z_min is None else z_min
    z_max = def_z_max if z_max is None else z_max
    z_points = generateZValues(n_points, z_min, z_max)
    material_values = materialProfileSLD(multilayer, n_points, z_min, z_max)
    return (z_points, material_values)


