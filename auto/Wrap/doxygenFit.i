
// File: index.xml

// File: classROOT_1_1Minuit2_1_1ABObj.xml
%feature("docstring") ROOT::Minuit2::ABObj "";

%feature("docstring")  ROOT::Minuit2::ABObj::ABObj "ROOT::Minuit2::ABObj< mtype, M, T >::ABObj(const M &obj)
";

%feature("docstring")  ROOT::Minuit2::ABObj::ABObj "ROOT::Minuit2::ABObj< mtype, M, T >::ABObj(const M &obj, T factor)
";

%feature("docstring")  ROOT::Minuit2::ABObj::~ABObj "ROOT::Minuit2::ABObj< mtype, M, T >::~ABObj()
";

%feature("docstring")  ROOT::Minuit2::ABObj::ABObj "ROOT::Minuit2::ABObj< mtype, M, T >::ABObj(const ABObj &obj)
";

%feature("docstring")  ROOT::Minuit2::ABObj::ABObj "ROOT::Minuit2::ABObj< mtype, M, T >::ABObj(const ABObj< mtype, b, c > &obj)
";

%feature("docstring")  ROOT::Minuit2::ABObj::Obj "const M& ROOT::Minuit2::ABObj< mtype, M, T >::Obj() const
";

%feature("docstring")  ROOT::Minuit2::ABObj::f "T ROOT::Minuit2::ABObj< mtype, M, T >::f() const
";


// File: classROOT_1_1Minuit2_1_1ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4.xml
%feature("docstring") ROOT::Minuit2::ABObj< sym, LASymMatrix, double > "
";

%feature("docstring")  ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::ABObj "
ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::ABObj(const LASymMatrix &obj)
";

%feature("docstring")  ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::ABObj "
ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::ABObj(const LASymMatrix &obj, double factor)
";

%feature("docstring")  ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::~ABObj "
ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::~ABObj()
";

%feature("docstring")  ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::ABObj "
ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::ABObj(const ABObj &obj)
";

%feature("docstring")  ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::ABObj "
ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::ABObj(const ABObj< vec, LASymMatrix, c > &obj)
";

%feature("docstring")  ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::Obj "
const LASymMatrix& ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::Obj() const
";

%feature("docstring")  ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::f "
double ROOT::Minuit2::ABObj< sym, LASymMatrix, double >::f() const
";


// File: classROOT_1_1Minuit2_1_1ABObj_3_01vec_00_01LAVector_00_01double_01_4.xml
%feature("docstring") ROOT::Minuit2::ABObj< vec, LAVector, double > "
";

%feature("docstring")  ROOT::Minuit2::ABObj< vec, LAVector, double >::ABObj "
ROOT::Minuit2::ABObj< vec, LAVector, double >::ABObj(const LAVector &obj)
";

%feature("docstring")  ROOT::Minuit2::ABObj< vec, LAVector, double >::ABObj "
ROOT::Minuit2::ABObj< vec, LAVector, double >::ABObj(const LAVector &obj, double factor)
";

%feature("docstring")  ROOT::Minuit2::ABObj< vec, LAVector, double >::~ABObj "
ROOT::Minuit2::ABObj< vec, LAVector, double >::~ABObj()
";

%feature("docstring")  ROOT::Minuit2::ABObj< vec, LAVector, double >::ABObj "
ROOT::Minuit2::ABObj< vec, LAVector, double >::ABObj(const ABObj< vec, LAVector, c > &obj)
";

%feature("docstring")  ROOT::Minuit2::ABObj< vec, LAVector, double >::Obj "
const LAVector& ROOT::Minuit2::ABObj< vec, LAVector, double >::Obj() const
";

%feature("docstring")  ROOT::Minuit2::ABObj< vec, LAVector, double >::f "
double ROOT::Minuit2::ABObj< vec, LAVector, double >::f() const
";


// File: classROOT_1_1Minuit2_1_1ABProd.xml
%feature("docstring") ROOT::Minuit2::ABProd "";

%feature("docstring")  ROOT::Minuit2::ABProd::ABProd "ROOT::Minuit2::ABProd< M1, M2 >::ABProd(const M1 &a, const M2 &b)
";

%feature("docstring")  ROOT::Minuit2::ABProd::~ABProd "ROOT::Minuit2::ABProd< M1, M2 >::~ABProd()
";

%feature("docstring")  ROOT::Minuit2::ABProd::ABProd "ROOT::Minuit2::ABProd< M1, M2 >::ABProd(const ABProd &prod)
";

%feature("docstring")  ROOT::Minuit2::ABProd::ABProd "ROOT::Minuit2::ABProd< M1, M2 >::ABProd(const ABProd< MI1, MI2 > &prod)
";

%feature("docstring")  ROOT::Minuit2::ABProd::A "const M1& ROOT::Minuit2::ABProd< M1, M2 >::A() const
";

%feature("docstring")  ROOT::Minuit2::ABProd::B "const M2& ROOT::Minuit2::ABProd< M1, M2 >::B() const
";


// File: classROOT_1_1Minuit2_1_1ABSum.xml
%feature("docstring") ROOT::Minuit2::ABSum "";

%feature("docstring")  ROOT::Minuit2::ABSum::ABSum "ROOT::Minuit2::ABSum< M1, M2 >::ABSum(const M1 &a, const M2 &b)
";

%feature("docstring")  ROOT::Minuit2::ABSum::~ABSum "ROOT::Minuit2::ABSum< M1, M2 >::~ABSum()
";

%feature("docstring")  ROOT::Minuit2::ABSum::ABSum "ROOT::Minuit2::ABSum< M1, M2 >::ABSum(const ABSum &sum)
";

%feature("docstring")  ROOT::Minuit2::ABSum::ABSum "ROOT::Minuit2::ABSum< M1, M2 >::ABSum(const ABSum< MI1, MI2 > &sum)
";

%feature("docstring")  ROOT::Minuit2::ABSum::A "const M1& ROOT::Minuit2::ABSum< M1, M2 >::A() const
";

%feature("docstring")  ROOT::Minuit2::ABSum::B "const M2& ROOT::Minuit2::ABSum< M1, M2 >::B() const
";


// File: classROOT_1_1Minuit2_1_1AlgebraicProdType.xml
%feature("docstring") ROOT::Minuit2::AlgebraicProdType "";


// File: classROOT_1_1Minuit2_1_1AlgebraicProdType_3_01gen_00_01gen_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicProdType< gen, gen > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicProdType_3_01gen_00_01sym_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicProdType< gen, sym > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicProdType_3_01gen_00_01vec_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicProdType< gen, vec > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicProdType_3_01sym_00_01gen_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicProdType< sym, gen > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicProdType_3_01sym_00_01sym_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicProdType< sym, sym > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicProdType_3_01sym_00_01vec_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicProdType< sym, vec > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicProdType_3_01T_00_01T_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicProdType< T, T > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicProdType_3_01vec_00_01gen_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicProdType< vec, gen > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicProdType_3_01vec_00_01sym_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicProdType< vec, sym > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicSumType.xml
%feature("docstring") ROOT::Minuit2::AlgebraicSumType "";


// File: classROOT_1_1Minuit2_1_1AlgebraicSumType_3_01gen_00_01vec_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicSumType< gen, vec > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicSumType_3_01sym_00_01vec_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicSumType< sym, vec > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicSumType_3_01T_00_01T_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicSumType< T, T > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicSumType_3_01vec_00_01gen_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicSumType< vec, gen > "
";


// File: classROOT_1_1Minuit2_1_1AlgebraicSumType_3_01vec_00_01sym_01_4.xml
%feature("docstring") ROOT::Minuit2::AlgebraicSumType< vec, sym > "
";


// File: classAlgorithmInfo.xml
%feature("docstring") AlgorithmInfo "

A name and a description.

C++ includes: MinimizerInfo.h
";

%feature("docstring")  AlgorithmInfo::AlgorithmInfo "AlgorithmInfo::AlgorithmInfo()=delete
";

%feature("docstring")  AlgorithmInfo::AlgorithmInfo "AlgorithmInfo::AlgorithmInfo(const std::string &itemName, const std::string &itemDescription)
";

%feature("docstring")  AlgorithmInfo::name "std::string AlgorithmInfo::name() const
";

%feature("docstring")  AlgorithmInfo::description "std::string AlgorithmInfo::description() const
";


// File: classROOT_1_1Minuit2_1_1AnalyticalGradientCalculator.xml
%feature("docstring") ROOT::Minuit2::AnalyticalGradientCalculator "";

%feature("docstring")  ROOT::Minuit2::AnalyticalGradientCalculator::AnalyticalGradientCalculator "ROOT::Minuit2::AnalyticalGradientCalculator::AnalyticalGradientCalculator(const FCNGradientBase &fcn, const MnUserTransformation &state)
";

%feature("docstring")  ROOT::Minuit2::AnalyticalGradientCalculator::~AnalyticalGradientCalculator "ROOT::Minuit2::AnalyticalGradientCalculator::~AnalyticalGradientCalculator()
";

%feature("docstring")  ROOT::Minuit2::AnalyticalGradientCalculator::CheckGradient "virtual bool ROOT::Minuit2::AnalyticalGradientCalculator::CheckGradient() const
";


// File: classAttLimits.xml
%feature("docstring") AttLimits "

Attributes and limits of a fit parameter, and coupling between these properties.

C++ includes: AttLimits.h
";

%feature("docstring")  AttLimits::AttLimits "AttLimits::AttLimits()
";

%feature("docstring")  AttLimits::isFixed "bool AttLimits::isFixed() const
";

%feature("docstring")  AttLimits::isLimited "bool AttLimits::isLimited() const
";

%feature("docstring")  AttLimits::isUpperLimited "bool AttLimits::isUpperLimited() const
";

%feature("docstring")  AttLimits::isLowerLimited "bool AttLimits::isLowerLimited() const
";

%feature("docstring")  AttLimits::isLimitless "bool AttLimits::isLimitless() const
";

%feature("docstring")  AttLimits::lowerLimit "double AttLimits::lowerLimit() const
";

%feature("docstring")  AttLimits::upperLimit "double AttLimits::upperLimit() const
";

%feature("docstring")  AttLimits::setFixed "void AttLimits::setFixed(bool isFixed)
";

%feature("docstring")  AttLimits::toString "std::string AttLimits::toString() const
";


// File: classAttLimitsTest.xml
%feature("docstring") AttLimitsTest "";


// File: classAttributes.xml
%feature("docstring") Attributes "

Attributes for a fit parameter. Currently, the only attribute is fixed/free.

C++ includes: Attributes.h
";

%feature("docstring")  Attributes::Attributes "Attributes::Attributes()
";

%feature("docstring")  Attributes::setFixed "void Attributes::setFixed(bool is_fixed)
";

%feature("docstring")  Attributes::isFixed "bool Attributes::isFixed() const
";

%feature("docstring")  Attributes::isFree "bool Attributes::isFree() const
";


// File: classROOT_1_1Math_1_1BasicFitMethodFunction.xml
%feature("docstring") ROOT::Math::BasicFitMethodFunction "

FitMethodFunction class Interface for objective functions (like chi2 and likelihood used in the fit) In addition to normal function interface provide interface for calculating each data contrinution to the function which is required by some algorithm (like Fumili)

C++ includes: FitMethodFunction.h
";

%feature("docstring")  ROOT::Math::BasicFitMethodFunction::BasicFitMethodFunction "ROOT::Math::BasicFitMethodFunction< FunctionType >::BasicFitMethodFunction(int dim, int npoint)
";

%feature("docstring")  ROOT::Math::BasicFitMethodFunction::~BasicFitMethodFunction "virtual ROOT::Math::BasicFitMethodFunction< FunctionType >::~BasicFitMethodFunction()

Virtual Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::BasicFitMethodFunction::NDim "virtual unsigned int ROOT::Math::BasicFitMethodFunction< FunctionType >::NDim() const

Number of dimension (parameters) . From IGenMultiFunction interface 
";

%feature("docstring")  ROOT::Math::BasicFitMethodFunction::DataElement "virtual double ROOT::Math::BasicFitMethodFunction< FunctionType >::DataElement(const double *x, unsigned int i, double *g=0) const =0

method returning the data i-th contribution to the fit objective function For example the residual for the least square functions or the pdf element for the likelihood functions. Estimating eventually also the gradient of the data element if the passed pointer is not null 
";

%feature("docstring")  ROOT::Math::BasicFitMethodFunction::NPoints "virtual unsigned int ROOT::Math::BasicFitMethodFunction< FunctionType >::NPoints() const

return the number of data points used in evaluating the function 
";

%feature("docstring")  ROOT::Math::BasicFitMethodFunction::Type "virtual Type_t ROOT::Math::BasicFitMethodFunction< FunctionType >::Type() const

return the type of method, override if needed 
";

%feature("docstring")  ROOT::Math::BasicFitMethodFunction::NCalls "virtual unsigned int ROOT::Math::BasicFitMethodFunction< FunctionType >::NCalls() const

return the total number of function calls (overrided if needed) 
";

%feature("docstring")  ROOT::Math::BasicFitMethodFunction::UpdateNCalls "virtual void ROOT::Math::BasicFitMethodFunction< FunctionType >::UpdateNCalls() const

update number of calls 
";

%feature("docstring")  ROOT::Math::BasicFitMethodFunction::ResetNCalls "virtual void ROOT::Math::BasicFitMethodFunction< FunctionType >::ResetNCalls()

reset number of function calls 
";


// File: classROOT_1_1Minuit2_1_1BasicFunctionGradient.xml
%feature("docstring") ROOT::Minuit2::BasicFunctionGradient "";

%feature("docstring")  ROOT::Minuit2::BasicFunctionGradient::BasicFunctionGradient "ROOT::Minuit2::BasicFunctionGradient::BasicFunctionGradient(unsigned int n)
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionGradient::BasicFunctionGradient "ROOT::Minuit2::BasicFunctionGradient::BasicFunctionGradient(const MnAlgebraicVector &grd)
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionGradient::BasicFunctionGradient "ROOT::Minuit2::BasicFunctionGradient::BasicFunctionGradient(const MnAlgebraicVector &grd, const MnAlgebraicVector &g2, const MnAlgebraicVector &gstep)
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionGradient::~BasicFunctionGradient "ROOT::Minuit2::BasicFunctionGradient::~BasicFunctionGradient()
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionGradient::BasicFunctionGradient "ROOT::Minuit2::BasicFunctionGradient::BasicFunctionGradient(const BasicFunctionGradient &grad)
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionGradient::Grad "const MnAlgebraicVector& ROOT::Minuit2::BasicFunctionGradient::Grad() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionGradient::Vec "const MnAlgebraicVector& ROOT::Minuit2::BasicFunctionGradient::Vec() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionGradient::IsValid "bool ROOT::Minuit2::BasicFunctionGradient::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionGradient::IsAnalytical "bool ROOT::Minuit2::BasicFunctionGradient::IsAnalytical() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionGradient::G2 "const MnAlgebraicVector& ROOT::Minuit2::BasicFunctionGradient::G2() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionGradient::Gstep "const MnAlgebraicVector& ROOT::Minuit2::BasicFunctionGradient::Gstep() const
";


// File: classROOT_1_1Minuit2_1_1BasicFunctionMinimum.xml
%feature("docstring") ROOT::Minuit2::BasicFunctionMinimum "

result of the minimization; both internal and external ( MnUserParameterState) representation available For the parameters at the Minimum

C++ includes: BasicFunctionMinimum.h
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::BasicFunctionMinimum "ROOT::Minuit2::BasicFunctionMinimum::BasicFunctionMinimum(const MinimumSeed &seed, double up)

constructor from only  MinimumSeed. Minimum is only from seed result not the full minimization 
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::BasicFunctionMinimum "ROOT::Minuit2::BasicFunctionMinimum::BasicFunctionMinimum(const MinimumSeed &seed, const std::vector< MinimumState > &states, double up)

constructor at the end of a successfull minimization from seed and vector of states 
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::BasicFunctionMinimum "ROOT::Minuit2::BasicFunctionMinimum::BasicFunctionMinimum(const MinimumSeed &seed, const std::vector< MinimumState > &states, double up, MnReachedCallLimit)

constructor at the end of a failed minimization due to exceeding function call limit 
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::BasicFunctionMinimum "ROOT::Minuit2::BasicFunctionMinimum::BasicFunctionMinimum(const MinimumSeed &seed, const std::vector< MinimumState > &states, double up, MnAboveMaxEdm)

constructor at the end of a failed minimization due to edm above maximum value 
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::BasicFunctionMinimum "ROOT::Minuit2::BasicFunctionMinimum::BasicFunctionMinimum(const BasicFunctionMinimum &min)

copy constructor 
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::~BasicFunctionMinimum "ROOT::Minuit2::BasicFunctionMinimum::~BasicFunctionMinimum()
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::Add "void ROOT::Minuit2::BasicFunctionMinimum::Add(const MinimumState &state)

add latest minimization state (for example add Hesse result after Migrad) 
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::Add "void ROOT::Minuit2::BasicFunctionMinimum::Add(const MinimumState &state, MnAboveMaxEdm)

Add a new state and flag that edm is above maximum. 
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::Seed "const MinimumSeed& ROOT::Minuit2::BasicFunctionMinimum::Seed() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::States "const std::vector<MinimumState>& ROOT::Minuit2::BasicFunctionMinimum::States() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::UserState "const MnUserParameterState& ROOT::Minuit2::BasicFunctionMinimum::UserState() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::UserParameters "const MnUserParameters& ROOT::Minuit2::BasicFunctionMinimum::UserParameters() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::UserCovariance "const MnUserCovariance& ROOT::Minuit2::BasicFunctionMinimum::UserCovariance() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::State "const MinimumState& ROOT::Minuit2::BasicFunctionMinimum::State() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::Parameters "const MinimumParameters& ROOT::Minuit2::BasicFunctionMinimum::Parameters() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::Error "const MinimumError& ROOT::Minuit2::BasicFunctionMinimum::Error() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::Grad "const FunctionGradient& ROOT::Minuit2::BasicFunctionMinimum::Grad() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::Fval "double ROOT::Minuit2::BasicFunctionMinimum::Fval() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::Edm "double ROOT::Minuit2::BasicFunctionMinimum::Edm() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::NFcn "int ROOT::Minuit2::BasicFunctionMinimum::NFcn() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::Up "double ROOT::Minuit2::BasicFunctionMinimum::Up() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::IsValid "bool ROOT::Minuit2::BasicFunctionMinimum::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::HasValidParameters "bool ROOT::Minuit2::BasicFunctionMinimum::HasValidParameters() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::HasValidCovariance "bool ROOT::Minuit2::BasicFunctionMinimum::HasValidCovariance() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::HasAccurateCovar "bool ROOT::Minuit2::BasicFunctionMinimum::HasAccurateCovar() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::HasPosDefCovar "bool ROOT::Minuit2::BasicFunctionMinimum::HasPosDefCovar() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::HasMadePosDefCovar "bool ROOT::Minuit2::BasicFunctionMinimum::HasMadePosDefCovar() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::HesseFailed "bool ROOT::Minuit2::BasicFunctionMinimum::HesseFailed() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::HasCovariance "bool ROOT::Minuit2::BasicFunctionMinimum::HasCovariance() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::IsAboveMaxEdm "bool ROOT::Minuit2::BasicFunctionMinimum::IsAboveMaxEdm() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::HasReachedCallLimit "bool ROOT::Minuit2::BasicFunctionMinimum::HasReachedCallLimit() const
";

%feature("docstring")  ROOT::Minuit2::BasicFunctionMinimum::SetErrorDef "void ROOT::Minuit2::BasicFunctionMinimum::SetErrorDef(double up)
";


// File: classROOT_1_1Math_1_1BasicMinimizer.xml
%feature("docstring") ROOT::Math::BasicMinimizer "

Base  Minimizer class, which defines the basic funcionality of various minimizer implementations (apart from Minuit and Minuit2) It provides support for storing parameter values, step size, parameter transofrmation etc.. in case real minimizer impelmentations do not provide such functionality. This is an internal class and should not be used directly by the user

C++ includes: BasicMinimizer.h
";

%feature("docstring")  ROOT::Math::BasicMinimizer::BasicMinimizer "ROOT::Math::BasicMinimizer::BasicMinimizer()

Default constructor 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::~BasicMinimizer "virtual ROOT::Math::BasicMinimizer::~BasicMinimizer()

Destructor 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetFunction "virtual void ROOT::Math::BasicMinimizer::SetFunction(const ROOT::Math::IMultiGenFunction &func)

set the function to minimize 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetFunction "virtual void ROOT::Math::BasicMinimizer::SetFunction(const ROOT::Math::IMultiGradFunction &func)

set gradient the function to minimize 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetVariable "virtual bool ROOT::Math::BasicMinimizer::SetVariable(unsigned int ivar, const std::string &name, double val, double step)

set free variable 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetLowerLimitedVariable "virtual bool ROOT::Math::BasicMinimizer::SetLowerLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double lower)

set lower limit variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetUpperLimitedVariable "virtual bool ROOT::Math::BasicMinimizer::SetUpperLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double upper)

set upper limit variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetLimitedVariable "virtual bool ROOT::Math::BasicMinimizer::SetLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double, double)

set upper/lower limited variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetFixedVariable "virtual bool ROOT::Math::BasicMinimizer::SetFixedVariable(unsigned int, const std::string &, double)

set fixed variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetVariableValue "virtual bool ROOT::Math::BasicMinimizer::SetVariableValue(unsigned int ivar, double val)

set the value of an existing variable 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetVariableValues "virtual bool ROOT::Math::BasicMinimizer::SetVariableValues(const double *x)

set the values of all existing variables (array must be dimensioned to the size of existing parameters) 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetVariableStepSize "virtual bool ROOT::Math::BasicMinimizer::SetVariableStepSize(unsigned int ivar, double step)

set the step size of an already existing variable 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetVariableLowerLimit "virtual bool ROOT::Math::BasicMinimizer::SetVariableLowerLimit(unsigned int ivar, double lower)

set the lower-limit of an already existing variable 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetVariableUpperLimit "virtual bool ROOT::Math::BasicMinimizer::SetVariableUpperLimit(unsigned int ivar, double upper)

set the upper-limit of an already existing variable 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::SetVariableLimits "virtual bool ROOT::Math::BasicMinimizer::SetVariableLimits(unsigned int ivar, double lower, double upper)

set the limits of an already existing variable 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::FixVariable "virtual bool ROOT::Math::BasicMinimizer::FixVariable(unsigned int ivar)

fix an existing variable 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::ReleaseVariable "virtual bool ROOT::Math::BasicMinimizer::ReleaseVariable(unsigned int ivar)

release an existing variable 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::IsFixedVariable "virtual bool ROOT::Math::BasicMinimizer::IsFixedVariable(unsigned int ivar) const

query if an existing variable is fixed (i.e. considered constant in the minimization) note that by default all variables are not fixed 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::GetVariableSettings "virtual bool ROOT::Math::BasicMinimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings &varObj) const

get variable settings in a variable object (like ROOT::Fit::ParamsSettings) 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::VariableName "virtual std::string ROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const

get name of variables (override if minimizer support storing of variable names) 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::VariableIndex "virtual int ROOT::Math::BasicMinimizer::VariableIndex(const std::string &name) const

get index of variable given a variable given a name return -1 if variable is not found 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::Minimize "virtual bool ROOT::Math::BasicMinimizer::Minimize()

method to perform the minimization 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::MinValue "virtual double ROOT::Math::BasicMinimizer::MinValue() const

return minimum function value 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::X "virtual const double* ROOT::Math::BasicMinimizer::X() const

return pointer to X values at the minimum 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::NDim "virtual unsigned int ROOT::Math::BasicMinimizer::NDim() const

number of dimensions 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::NFree "virtual unsigned int ROOT::Math::BasicMinimizer::NFree() const

number of free variables (real dimension of the problem) 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::NPar "virtual unsigned int ROOT::Math::BasicMinimizer::NPar() const

total number of parameter defined 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::ObjFunction "const ROOT::Math::IMultiGenFunction* ROOT::Math::BasicMinimizer::ObjFunction() const

return pointer to used objective function 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::GradObjFunction "const ROOT::Math::IMultiGradFunction* ROOT::Math::BasicMinimizer::GradObjFunction() const

return pointer to used gradient object function (NULL if gradient is not supported) 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::TransformFunction "const ROOT::Math::MinimTransformFunction* ROOT::Math::BasicMinimizer::TransformFunction() const

return transformation function (NULL if not having a transformation) 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::PrintResult "void ROOT::Math::BasicMinimizer::PrintResult() const

print result of minimization 
";

%feature("docstring")  ROOT::Math::BasicMinimizer::StepSizes "virtual const double* ROOT::Math::BasicMinimizer::StepSizes() const

accessor methods 
";


// File: classROOT_1_1Minuit2_1_1BasicMinimumError.xml
%feature("docstring") ROOT::Minuit2::BasicMinimumError "

Internal Class containing the error information on the estimated minimum : Error matrix + dcovar + additional flags for quality and validity checks

C++ includes: BasicMinimumError.h
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::BasicMinimumError "ROOT::Minuit2::BasicMinimumError::BasicMinimumError(unsigned int n)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::BasicMinimumError "ROOT::Minuit2::BasicMinimumError::BasicMinimumError(const MnAlgebraicSymMatrix &mat, double dcov)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::BasicMinimumError "ROOT::Minuit2::BasicMinimumError::BasicMinimumError(const MnAlgebraicSymMatrix &mat, MnHesseFailed)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::BasicMinimumError "ROOT::Minuit2::BasicMinimumError::BasicMinimumError(const MnAlgebraicSymMatrix &mat, MnMadePosDef)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::BasicMinimumError "ROOT::Minuit2::BasicMinimumError::BasicMinimumError(const MnAlgebraicSymMatrix &mat, MnInvertFailed)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::BasicMinimumError "ROOT::Minuit2::BasicMinimumError::BasicMinimumError(const MnAlgebraicSymMatrix &mat, MnNotPosDef)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::~BasicMinimumError "ROOT::Minuit2::BasicMinimumError::~BasicMinimumError()
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::BasicMinimumError "ROOT::Minuit2::BasicMinimumError::BasicMinimumError(const BasicMinimumError &e)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::Matrix "MnAlgebraicSymMatrix ROOT::Minuit2::BasicMinimumError::Matrix() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::InvHessian "const MnAlgebraicSymMatrix& ROOT::Minuit2::BasicMinimumError::InvHessian() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::Hessian "MnAlgebraicSymMatrix ROOT::Minuit2::BasicMinimumError::Hessian() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::Dcovar "double ROOT::Minuit2::BasicMinimumError::Dcovar() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::IsAccurate "bool ROOT::Minuit2::BasicMinimumError::IsAccurate() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::IsValid "bool ROOT::Minuit2::BasicMinimumError::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::IsPosDef "bool ROOT::Minuit2::BasicMinimumError::IsPosDef() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::IsMadePosDef "bool ROOT::Minuit2::BasicMinimumError::IsMadePosDef() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::HesseFailed "bool ROOT::Minuit2::BasicMinimumError::HesseFailed() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::InvertFailed "bool ROOT::Minuit2::BasicMinimumError::InvertFailed() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumError::IsAvailable "bool ROOT::Minuit2::BasicMinimumError::IsAvailable() const
";


// File: classROOT_1_1Minuit2_1_1BasicMinimumParameters.xml
%feature("docstring") ROOT::Minuit2::BasicMinimumParameters "";

%feature("docstring")  ROOT::Minuit2::BasicMinimumParameters::BasicMinimumParameters "ROOT::Minuit2::BasicMinimumParameters::BasicMinimumParameters(unsigned int n, double fval)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumParameters::BasicMinimumParameters "ROOT::Minuit2::BasicMinimumParameters::BasicMinimumParameters(const MnAlgebraicVector &avec, double fval)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumParameters::BasicMinimumParameters "ROOT::Minuit2::BasicMinimumParameters::BasicMinimumParameters(const MnAlgebraicVector &avec, const MnAlgebraicVector &dirin, double fval)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumParameters::~BasicMinimumParameters "ROOT::Minuit2::BasicMinimumParameters::~BasicMinimumParameters()
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumParameters::BasicMinimumParameters "ROOT::Minuit2::BasicMinimumParameters::BasicMinimumParameters(const BasicMinimumParameters &par)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumParameters::Vec "const MnAlgebraicVector& ROOT::Minuit2::BasicMinimumParameters::Vec() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumParameters::Dirin "const MnAlgebraicVector& ROOT::Minuit2::BasicMinimumParameters::Dirin() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumParameters::Fval "double ROOT::Minuit2::BasicMinimumParameters::Fval() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumParameters::IsValid "bool ROOT::Minuit2::BasicMinimumParameters::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumParameters::HasStepSize "bool ROOT::Minuit2::BasicMinimumParameters::HasStepSize() const
";


// File: classROOT_1_1Minuit2_1_1BasicMinimumSeed.xml
%feature("docstring") ROOT::Minuit2::BasicMinimumSeed "";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::BasicMinimumSeed "ROOT::Minuit2::BasicMinimumSeed::BasicMinimumSeed(const MinimumState &state, const MnUserTransformation &trafo)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::~BasicMinimumSeed "ROOT::Minuit2::BasicMinimumSeed::~BasicMinimumSeed()
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::BasicMinimumSeed "ROOT::Minuit2::BasicMinimumSeed::BasicMinimumSeed(const BasicMinimumSeed &seed)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::State "const MinimumState& ROOT::Minuit2::BasicMinimumSeed::State() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::Parameters "const MinimumParameters& ROOT::Minuit2::BasicMinimumSeed::Parameters() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::Error "const MinimumError& ROOT::Minuit2::BasicMinimumSeed::Error() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::Gradient "const FunctionGradient& ROOT::Minuit2::BasicMinimumSeed::Gradient() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::Trafo "const MnUserTransformation& ROOT::Minuit2::BasicMinimumSeed::Trafo() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::Precision "const MnMachinePrecision& ROOT::Minuit2::BasicMinimumSeed::Precision() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::Fval "double ROOT::Minuit2::BasicMinimumSeed::Fval() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::Edm "double ROOT::Minuit2::BasicMinimumSeed::Edm() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::NFcn "unsigned int ROOT::Minuit2::BasicMinimumSeed::NFcn() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumSeed::IsValid "bool ROOT::Minuit2::BasicMinimumSeed::IsValid() const
";


// File: classROOT_1_1Minuit2_1_1BasicMinimumState.xml
%feature("docstring") ROOT::Minuit2::BasicMinimumState "";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::BasicMinimumState "ROOT::Minuit2::BasicMinimumState::BasicMinimumState(unsigned int n, double fval, double edm, int nfcn)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::BasicMinimumState "ROOT::Minuit2::BasicMinimumState::BasicMinimumState(const MinimumParameters &states, const MinimumError &err, const FunctionGradient &grad, double edm, int nfcn)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::BasicMinimumState "ROOT::Minuit2::BasicMinimumState::BasicMinimumState(const MinimumParameters &states, double edm, int nfcn)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::~BasicMinimumState "ROOT::Minuit2::BasicMinimumState::~BasicMinimumState()
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::BasicMinimumState "ROOT::Minuit2::BasicMinimumState::BasicMinimumState(const BasicMinimumState &state)
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::Parameters "const MinimumParameters& ROOT::Minuit2::BasicMinimumState::Parameters() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::Vec "const MnAlgebraicVector& ROOT::Minuit2::BasicMinimumState::Vec() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::size "int ROOT::Minuit2::BasicMinimumState::size() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::Error "const MinimumError& ROOT::Minuit2::BasicMinimumState::Error() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::Gradient "const FunctionGradient& ROOT::Minuit2::BasicMinimumState::Gradient() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::Fval "double ROOT::Minuit2::BasicMinimumState::Fval() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::Edm "double ROOT::Minuit2::BasicMinimumState::Edm() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::NFcn "int ROOT::Minuit2::BasicMinimumState::NFcn() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::IsValid "bool ROOT::Minuit2::BasicMinimumState::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::HasParameters "bool ROOT::Minuit2::BasicMinimumState::HasParameters() const
";

%feature("docstring")  ROOT::Minuit2::BasicMinimumState::HasCovariance "bool ROOT::Minuit2::BasicMinimumState::HasCovariance() const
";


// File: classROOT_1_1Minuit2_1_1BFGSErrorUpdator.xml
%feature("docstring") ROOT::Minuit2::BFGSErrorUpdator "

Update of the covariance matrix for the Variable Metric minimizer (MIGRAD)

C++ includes: BFGSErrorUpdator.h
";

%feature("docstring")  ROOT::Minuit2::BFGSErrorUpdator::BFGSErrorUpdator "ROOT::Minuit2::BFGSErrorUpdator::BFGSErrorUpdator()
";

%feature("docstring")  ROOT::Minuit2::BFGSErrorUpdator::~BFGSErrorUpdator "virtual ROOT::Minuit2::BFGSErrorUpdator::~BFGSErrorUpdator()
";

%feature("docstring")  ROOT::Minuit2::BFGSErrorUpdator::Update "virtual MinimumError ROOT::Minuit2::BFGSErrorUpdator::Update(const MinimumState &, const MinimumParameters &, const FunctionGradient &) const
";


// File: classROOT_1_1Minuit2_1_1BFGSMinimizerType.xml
%feature("docstring") ROOT::Minuit2::BFGSMinimizerType "";


// File: classROOT_1_1Minuit2_1_1VariableMetricMinimizer_1_1BFGSType.xml
%feature("docstring") ROOT::Minuit2::VariableMetricMinimizer::BFGSType "";


// File: classROOT_1_1Fit_1_1BinData.xml
%feature("docstring") ROOT::Fit::BinData "

Class describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options:
only coordinates and values (for binned likelihood fits) : kNoError

coordinate, values and error on values (for normal least square fits) : kValueError

coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError

corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError

In addition there is the option to construct Bindata copying the data in (using the DataVector class) or using pointer to external data (DataWrapper) class. In general is found to be more efficient to copy the data. In case of really large data sets for limiting memory consumption then the other option can be used Specialized constructor exists for data up to 3 dimensions.

When the data are copying in the number of points can be set later (or re-set) using Initialize and the data are inserted one by one using the Add method. It is mandatory to set the size before using the Add method.

C++ includes: BinData.h
";

%feature("docstring")  ROOT::Fit::BinData::BinData "ROOT::Fit::BinData::BinData(unsigned int maxpoints=0, unsigned int dim=1, ErrorType err=kValueError)

constructor from dimension of point and max number of points (to pre-allocate vector) Give a zero value and then use Initialize later one if the size is not known 
";

%feature("docstring")  ROOT::Fit::BinData::BinData "ROOT::Fit::BinData::BinData(const DataOptions &opt, unsigned int maxpoints=0, unsigned int dim=1, ErrorType err=kValueError)

constructor from option and default range 
";

%feature("docstring")  ROOT::Fit::BinData::BinData "ROOT::Fit::BinData::BinData(const DataOptions &opt, const DataRange &range, unsigned int maxpoints=0, unsigned int dim=1, ErrorType err=kValueError)

constructor from options and range efault is 1D and value errors 
";

%feature("docstring")  ROOT::Fit::BinData::BinData "ROOT::Fit::BinData::BinData(unsigned int n, const double *dataX, const double *val, const double *ex, const double *eval)

constructurs using external data constructor from external data for 1D with errors on coordinate and value 
";

%feature("docstring")  ROOT::Fit::BinData::BinData "ROOT::Fit::BinData::BinData(unsigned int n, const double *dataX, const double *dataY, const double *val, const double *ex, const double *ey, const double *eval)

constructor from external data for 2D with errors on coordinate and value 
";

%feature("docstring")  ROOT::Fit::BinData::BinData "ROOT::Fit::BinData::BinData(unsigned int n, const double *dataX, const double *dataY, const double *dataZ, const double *val, const double *ex, const double *ey, const double *ez, const double *eval)

constructor from external data for 3D with errors on coordinate and value 
";

%feature("docstring")  ROOT::Fit::BinData::~BinData "virtual ROOT::Fit::BinData::~BinData()

destructor 
";

%feature("docstring")  ROOT::Fit::BinData::BinData "ROOT::Fit::BinData::BinData(const BinData &rhs)

copy constructors 
";

%feature("docstring")  ROOT::Fit::BinData::Append "void ROOT::Fit::BinData::Append(unsigned int newPoints, unsigned int dim=1, ErrorType err=kValueError)

preallocate a data set with given size , dimension and error type (to get the full point size) If the data set already exists and it is having the compatible point size space for the new points is created in the data sets, while if not compatible the old data are erased and new space of new size is allocated. (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints) 
";

%feature("docstring")  ROOT::Fit::BinData::Initialize "void ROOT::Fit::BinData::Initialize(unsigned int newPoints, unsigned int dim=1, ErrorType err=kValueError)
";

%feature("docstring")  ROOT::Fit::BinData::HaveCoordErrors "bool ROOT::Fit::BinData::HaveCoordErrors() const

flag to control if data provides error on the coordinates 
";

%feature("docstring")  ROOT::Fit::BinData::HaveAsymErrors "bool ROOT::Fit::BinData::HaveAsymErrors() const

flag to control if data provides asymmetric errors on the value 
";

%feature("docstring")  ROOT::Fit::BinData::LogTransform "BinData& ROOT::Fit::BinData::LogTransform()

apply a Log transformation of the data values can be used for example when fitting an exponential or gaussian Transform the data in place need to copy if want to preserve original data The data sets must not contain negative values. IN case it does, an empty data set is returned 
";

%feature("docstring")  ROOT::Fit::BinData::Add "void ROOT::Fit::BinData::Add(double x, double y)

add one dim data with only coordinate and values 
";

%feature("docstring")  ROOT::Fit::BinData::Add "void ROOT::Fit::BinData::Add(double x, double y, double ey)

add one dim data with no error in the coordinate (x) in this case store the inverse of the error in the value (y) 
";

%feature("docstring")  ROOT::Fit::BinData::Add "void ROOT::Fit::BinData::Add(double x, double y, double ex, double ey)

add one dim data with error in the coordinate (x) in this case store the value (y) error and not the inverse 
";

%feature("docstring")  ROOT::Fit::BinData::Add "void ROOT::Fit::BinData::Add(double x, double y, double ex, double eyl, double eyh)

add one dim data with error in the coordinate (x) and asymmetric errors in the value (y) in this case store the y errors and not the inverse 
";

%feature("docstring")  ROOT::Fit::BinData::Add "void ROOT::Fit::BinData::Add(const double *x, double val)

add multi-dim coordinate data with only value 
";

%feature("docstring")  ROOT::Fit::BinData::Add "void ROOT::Fit::BinData::Add(const double *x, double val, double eval)

add multi-dim coordinate data with only error in value 
";

%feature("docstring")  ROOT::Fit::BinData::Add "void ROOT::Fit::BinData::Add(const double *x, double val, const double *ex, double eval)

add multi-dim coordinate data with both error in coordinates and value 
";

%feature("docstring")  ROOT::Fit::BinData::Add "void ROOT::Fit::BinData::Add(const double *x, double val, const double *ex, double elval, double ehval)

add multi-dim coordinate data with both error in coordinates and value 
";

%feature("docstring")  ROOT::Fit::BinData::AddBinUpEdge "void ROOT::Fit::BinData::AddBinUpEdge(const double *xup)

add the bin width data, a pointer to an array with the bin upper edge information. This is needed when fitting with integral options The information is added for the previously inserted point.  BinData::Add must be called before 
";

%feature("docstring")  ROOT::Fit::BinData::Value "double ROOT::Fit::BinData::Value(unsigned int ipoint) const

return the value for the given fit point 
";

%feature("docstring")  ROOT::Fit::BinData::ValuePtr "const double* ROOT::Fit::BinData::ValuePtr(unsigned int ipoint) const

return a pointer to the value for the given fit point 
";

%feature("docstring")  ROOT::Fit::BinData::ErrorPtr "const double* ROOT::Fit::BinData::ErrorPtr(unsigned int ipoint) const

return error on the value for the given fit point Safe (but slower) method returning correctly the error on the value in case of asymm errors return the average 0.5(eu + el) 
";

%feature("docstring")  ROOT::Fit::BinData::Error "double ROOT::Fit::BinData::Error(unsigned int ipoint) const
";

%feature("docstring")  ROOT::Fit::BinData::GetAsymError "void ROOT::Fit::BinData::GetAsymError(unsigned int ipoint, double &lowError, double &highError) const
";

%feature("docstring")  ROOT::Fit::BinData::InvError "double ROOT::Fit::BinData::InvError(unsigned int ipoint) const

Return the inverse of error on the value for the given fit point useful when error in the coordinates are not stored and then this is used directly this as the weight in the least square function 
";

%feature("docstring")  ROOT::Fit::BinData::GetPoint "const double* ROOT::Fit::BinData::GetPoint(unsigned int ipoint, double &value) const

retrieve at the same time a pointer to the coordinate data and the fit value More efficient than calling Coords(i) and Value(i) 
";

%feature("docstring")  ROOT::Fit::BinData::GetCoordErrorComponent "double ROOT::Fit::BinData::GetCoordErrorComponent(unsigned int ipoint, unsigned int icoord) const

returns a single coordinate error component of a point. This function is threadsafe in contrast to Coords(...) and can easily get vectorized by the compiler in loops running over the ipoint-index. 
";

%feature("docstring")  ROOT::Fit::BinData::CoordErrors "const double* ROOT::Fit::BinData::CoordErrors(unsigned int ipoint) const

Return a pointer to the errors in the coordinates for the given fit point 
";

%feature("docstring")  ROOT::Fit::BinData::GetPoint "const double* ROOT::Fit::BinData::GetPoint(unsigned int ipoint, double &value, double &invError) const

retrieve in a single call a pointer to the coordinate data, value and inverse error for the given fit point. To be used only when type is kValueError or kNoError. In the last case the value 1 is returned for the error. 
";

%feature("docstring")  ROOT::Fit::BinData::GetPointError "const double* ROOT::Fit::BinData::GetPointError(unsigned int ipoint, double &errvalue) const

Retrieve the errors on the point (coordinate and value) for the given fit point It must be called only when the coordinate errors are stored otherwise it will produce an assert. 
";

%feature("docstring")  ROOT::Fit::BinData::GetPointError "const double* ROOT::Fit::BinData::GetPointError(unsigned int ipoint, double &errlow, double &errhigh) const

Get errors on the point (coordinate errors and asymmetric value errors) for the given fit point. It must be called only when the coordinate errors and asymmetric errors are stored otherwise it will produce an assert. 
";

%feature("docstring")  ROOT::Fit::BinData::GetBinUpEdgeComponent "double ROOT::Fit::BinData::GetBinUpEdgeComponent(unsigned int ipoint, unsigned int icoord) const

returns a single coordinate error component of a point. This function is threadsafe in contrast to Coords(...) and can easily get vectorized by the compiler in loops running over the ipoint-index. 
";

%feature("docstring")  ROOT::Fit::BinData::BinUpEdge "const double* ROOT::Fit::BinData::BinUpEdge(unsigned int ipoint) const

return an array containing the upper edge of the bin for coordinate i In case of empty bin they could be merged in a single larger bin Return a NULL pointer if the bin width is not stored 
";

%feature("docstring")  ROOT::Fit::BinData::HasBinEdges "bool ROOT::Fit::BinData::HasBinEdges() const

query if the data store the bin edges instead of the center 
";

%feature("docstring")  ROOT::Fit::BinData::RefVolume "double ROOT::Fit::BinData::RefVolume() const

retrieve the reference volume used to normalize the data when the option bin volume is set 
";

%feature("docstring")  ROOT::Fit::BinData::SetRefVolume "void ROOT::Fit::BinData::SetRefVolume(double value)

set the reference volume used to normalize the data when the option bin volume is set 
";

%feature("docstring")  ROOT::Fit::BinData::GetErrorType "ErrorType ROOT::Fit::BinData::GetErrorType() const

retrieve the errortype 
";

%feature("docstring")  ROOT::Fit::BinData::SumOfContent "double ROOT::Fit::BinData::SumOfContent() const

compute the total sum of the data content (sum of weights in case of weighted data set) 
";

%feature("docstring")  ROOT::Fit::BinData::SumOfError2 "double ROOT::Fit::BinData::SumOfError2() const

compute the total sum of the error square (sum of weight square in case of a weighted data set) 
";

%feature("docstring")  ROOT::Fit::BinData::IsWeighted "bool ROOT::Fit::BinData::IsWeighted() const

return true if the data set is weighted We cannot compute ourselfs because sometimes errors are filled with 1 instead of zero (as in ROOT::Fit::FillData ) 
";


// File: classROOT_1_1Fit_1_1Chi2FCN.xml
%feature("docstring") ROOT::Fit::Chi2FCN "

Chi2FCN class for binnned fits using the least square methods

C++ includes: Chi2FCN.h
";

%feature("docstring")  ROOT::Fit::Chi2FCN::Chi2FCN "ROOT::Fit::Chi2FCN< DerivFunType, ModelFunType >::Chi2FCN(const std::shared_ptr< BinData > &data, const std::shared_ptr< IModelFunction > &func, const ::ROOT::Fit::ExecutionPolicy &executionPolicy=::ROOT::Fit::ExecutionPolicy::kSerial)

Constructor from data set (binned ) and model function 
";

%feature("docstring")  ROOT::Fit::Chi2FCN::Chi2FCN "ROOT::Fit::Chi2FCN< DerivFunType, ModelFunType >::Chi2FCN(const BinData &data, const IModelFunction &func, const ::ROOT::Fit::ExecutionPolicy &executionPolicy=::ROOT::Fit::ExecutionPolicy::kSerial)

Same Constructor from data set (binned ) and model function but now managed by the user we clone the function but not the data 
";

%feature("docstring")  ROOT::Fit::Chi2FCN::~Chi2FCN "virtual ROOT::Fit::Chi2FCN< DerivFunType, ModelFunType >::~Chi2FCN()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Fit::Chi2FCN::Chi2FCN "ROOT::Fit::Chi2FCN< DerivFunType, ModelFunType >::Chi2FCN(const Chi2FCN &f)

Copy constructor 
";

%feature("docstring")  ROOT::Fit::Chi2FCN::Clone "virtual BaseFunction* ROOT::Fit::Chi2FCN< DerivFunType, ModelFunType >::Clone() const
";

%feature("docstring")  ROOT::Fit::Chi2FCN::DataElement "virtual double ROOT::Fit::Chi2FCN< DerivFunType, ModelFunType >::DataElement(const double *x, unsigned int i, double *g) const

i-th chi-square residual 
";

%feature("docstring")  ROOT::Fit::Chi2FCN::Gradient "virtual void ROOT::Fit::Chi2FCN< DerivFunType, ModelFunType >::Gradient(const double *x, double *g) const
";

%feature("docstring")  ROOT::Fit::Chi2FCN::Type "virtual BaseObjFunction::Type_t ROOT::Fit::Chi2FCN< DerivFunType, ModelFunType >::Type() const

get type of fit method function 
";


// File: classROOT_1_1Minuit2_1_1CombinedMinimizer.xml
%feature("docstring") ROOT::Minuit2::CombinedMinimizer "

Combined minimizer: combination of Migrad and Simplex. I If the Migrad method fails at first attempt, a simplex minimization is performed and then migrad is tried again.

C++ includes: CombinedMinimizer.h
";

%feature("docstring")  ROOT::Minuit2::CombinedMinimizer::CombinedMinimizer "ROOT::Minuit2::CombinedMinimizer::CombinedMinimizer()
";

%feature("docstring")  ROOT::Minuit2::CombinedMinimizer::~CombinedMinimizer "ROOT::Minuit2::CombinedMinimizer::~CombinedMinimizer()
";

%feature("docstring")  ROOT::Minuit2::CombinedMinimizer::SeedGenerator "const MinimumSeedGenerator& ROOT::Minuit2::CombinedMinimizer::SeedGenerator() const
";

%feature("docstring")  ROOT::Minuit2::CombinedMinimizer::Builder "const MinimumBuilder& ROOT::Minuit2::CombinedMinimizer::Builder() const
";

%feature("docstring")  ROOT::Minuit2::CombinedMinimizer::Builder "MinimumBuilder& ROOT::Minuit2::CombinedMinimizer::Builder()
";


// File: classROOT_1_1Minuit2_1_1CombinedMinimumBuilder.xml
%feature("docstring") ROOT::Minuit2::CombinedMinimumBuilder "";

%feature("docstring")  ROOT::Minuit2::CombinedMinimumBuilder::CombinedMinimumBuilder "ROOT::Minuit2::CombinedMinimumBuilder::CombinedMinimumBuilder()
";

%feature("docstring")  ROOT::Minuit2::CombinedMinimumBuilder::~CombinedMinimumBuilder "ROOT::Minuit2::CombinedMinimumBuilder::~CombinedMinimumBuilder()
";

%feature("docstring")  ROOT::Minuit2::CombinedMinimumBuilder::Minimum "virtual FunctionMinimum ROOT::Minuit2::CombinedMinimumBuilder::Minimum(const MnFcn &, const GradientCalculator &, const MinimumSeed &, const MnStrategy &, unsigned int, double) const
";

%feature("docstring")  ROOT::Minuit2::CombinedMinimumBuilder::SetPrintLevel "virtual void ROOT::Minuit2::CombinedMinimumBuilder::SetPrintLevel(int level)
";

%feature("docstring")  ROOT::Minuit2::CombinedMinimumBuilder::SetStorageLevel "virtual void ROOT::Minuit2::CombinedMinimumBuilder::SetStorageLevel(int level)
";

%feature("docstring")  ROOT::Minuit2::CombinedMinimumBuilder::SetTraceObject "virtual void ROOT::Minuit2::CombinedMinimumBuilder::SetTraceObject(MnTraceObject &obj)
";


// File: structCompareAsc.xml
%feature("docstring") CompareAsc "";

%feature("docstring")  CompareAsc::CompareAsc "CompareAsc< T >::CompareAsc(T d)
";


// File: structCompareDesc.xml
%feature("docstring") CompareDesc "";

%feature("docstring")  CompareDesc::CompareDesc "CompareDesc< T >::CompareDesc(T d)
";


// File: classROOT_1_1Minuit2_1_1ContoursError.xml
%feature("docstring") ROOT::Minuit2::ContoursError "";

%feature("docstring")  ROOT::Minuit2::ContoursError::ContoursError "ROOT::Minuit2::ContoursError::ContoursError(unsigned int parx, unsigned int pary, const std::vector< std::pair< double, double > > &points, const MinosError &xmnos, const MinosError &ymnos, unsigned int nfcn)
";

%feature("docstring")  ROOT::Minuit2::ContoursError::~ContoursError "ROOT::Minuit2::ContoursError::~ContoursError()
";

%feature("docstring")  ROOT::Minuit2::ContoursError::ContoursError "ROOT::Minuit2::ContoursError::ContoursError(const ContoursError &cont)
";

%feature("docstring")  ROOT::Minuit2::ContoursError::XMinos "std::pair<double,double> ROOT::Minuit2::ContoursError::XMinos() const
";

%feature("docstring")  ROOT::Minuit2::ContoursError::YMinos "std::pair<double,double> ROOT::Minuit2::ContoursError::YMinos() const
";

%feature("docstring")  ROOT::Minuit2::ContoursError::Xpar "unsigned int ROOT::Minuit2::ContoursError::Xpar() const
";

%feature("docstring")  ROOT::Minuit2::ContoursError::Ypar "unsigned int ROOT::Minuit2::ContoursError::Ypar() const
";

%feature("docstring")  ROOT::Minuit2::ContoursError::XMinosError "const MinosError& ROOT::Minuit2::ContoursError::XMinosError() const
";

%feature("docstring")  ROOT::Minuit2::ContoursError::YMinosError "const MinosError& ROOT::Minuit2::ContoursError::YMinosError() const
";

%feature("docstring")  ROOT::Minuit2::ContoursError::NFcn "unsigned int ROOT::Minuit2::ContoursError::NFcn() const
";

%feature("docstring")  ROOT::Minuit2::ContoursError::XMin "double ROOT::Minuit2::ContoursError::XMin() const
";

%feature("docstring")  ROOT::Minuit2::ContoursError::YMin "double ROOT::Minuit2::ContoursError::YMin() const
";


// File: classROOT_1_1Minuit2_1_1MnCross_1_1CrossFcnLimit.xml
%feature("docstring") ROOT::Minuit2::MnCross::CrossFcnLimit "";


// File: classROOT_1_1Minuit2_1_1MnCross_1_1CrossNewMin.xml
%feature("docstring") ROOT::Minuit2::MnCross::CrossNewMin "";


// File: classROOT_1_1Minuit2_1_1MnCross_1_1CrossParLimit.xml
%feature("docstring") ROOT::Minuit2::MnCross::CrossParLimit "";


// File: structROOT_1_1Fit_1_1DataOptions.xml
%feature("docstring") ROOT::Fit::DataOptions "

DataOptions : simple structure holding the options on how the data are filled

C++ includes: DataOptions.h
";

%feature("docstring")  ROOT::Fit::DataOptions::DataOptions "ROOT::Fit::DataOptions::DataOptions()

Default constructor: use the default options 
";


// File: classROOT_1_1Fit_1_1DataRange.xml
%feature("docstring") ROOT::Fit::DataRange "

class describing the range in the coordinates it supports multiple range in a coordinate. The rnage dimension is the dimension of the coordinate, its size is the number of interval for each coordinate. Default range is -inf, inf Range can be modified with the add range method

C++ includes: DataRange.h
";

%feature("docstring")  ROOT::Fit::DataRange::DataRange "ROOT::Fit::DataRange::DataRange(unsigned int dim=1)

Default constructor (infinite range) 
";

%feature("docstring")  ROOT::Fit::DataRange::DataRange "ROOT::Fit::DataRange::DataRange(double xmin, double xmax)

construct a range for [xmin, xmax] 
";

%feature("docstring")  ROOT::Fit::DataRange::DataRange "ROOT::Fit::DataRange::DataRange(double xmin, double xmax, double ymin, double ymax)

construct a range for [xmin, xmax] , [ymin, ymax] 
";

%feature("docstring")  ROOT::Fit::DataRange::DataRange "ROOT::Fit::DataRange::DataRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)

construct a range for [xmin, xmax] , [ymin, ymax] , [zmin, zmax] 
";

%feature("docstring")  ROOT::Fit::DataRange::NDim "unsigned int ROOT::Fit::DataRange::NDim() const

get range dimension 
";

%feature("docstring")  ROOT::Fit::DataRange::Size "unsigned int ROOT::Fit::DataRange::Size(unsigned int icoord=0) const

return range size for coordinate icoord (starts from zero) Size == 0 indicates no range is present [-inf, + inf] 
";

%feature("docstring")  ROOT::Fit::DataRange::IsSet "bool ROOT::Fit::DataRange::IsSet() const

return true if a range has been set in any of the coordinates i.e. when it is not [-inf,+inf] for all coordinates Avoid in case of multi-dim to loop on all the coordinated and ask the size 
";

%feature("docstring")  ROOT::Fit::DataRange::Ranges "const RangeSet& ROOT::Fit::DataRange::Ranges(unsigned int icoord=0) const

return the vector of ranges for the coordinate icoord 
";

%feature("docstring")  ROOT::Fit::DataRange::GetRange "void ROOT::Fit::DataRange::GetRange(unsigned int irange, unsigned int icoord, double &xmin, double &xmax) const

get the i-th range for given coordinate. If range does not exist return -inf, +inf 
";

%feature("docstring")  ROOT::Fit::DataRange::GetRange "void ROOT::Fit::DataRange::GetRange(unsigned int icoord, double &xmin, double &xmax) const

get the first range for given coordinate. If range does not exist return -inf, +inf 
";

%feature("docstring")  ROOT::Fit::DataRange::GetRange "void ROOT::Fit::DataRange::GetRange(double &xmin, double &xmax, unsigned int irange=0) const

get first range for the x - coordinate 
";

%feature("docstring")  ROOT::Fit::DataRange::GetRange "void ROOT::Fit::DataRange::GetRange(double &xmin, double &xmax, double &ymin, double &ymax, unsigned int irange=0) const

get range for the x and y coordinates 
";

%feature("docstring")  ROOT::Fit::DataRange::GetRange "void ROOT::Fit::DataRange::GetRange(double &xmin, double &xmax, double &ymin, double &ymax, double &zmin, double &zmax, unsigned int irange=0) const

get range for the x and y and z coordinates 
";

%feature("docstring")  ROOT::Fit::DataRange::GetRange "void ROOT::Fit::DataRange::GetRange(double *xmin, double *xmax, unsigned int irange=0) const

get range for coordinates and fill the vector 
";

%feature("docstring")  ROOT::Fit::DataRange::~DataRange "ROOT::Fit::DataRange::~DataRange()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Fit::DataRange::AddRange "void ROOT::Fit::DataRange::AddRange(unsigned int icoord, double xmin, double xmax)

add a range [xmin,xmax] for the new coordinate icoord Adding a range does not delete existing one, but takes the OR with existing ranges. if want to replace range use method SetRange, which replace range with existing one 
";

%feature("docstring")  ROOT::Fit::DataRange::AddRange "void ROOT::Fit::DataRange::AddRange(double xmin, double xmax)

add a range [xmin,xmax] for the first coordinate icoord 
";

%feature("docstring")  ROOT::Fit::DataRange::AddRange "void ROOT::Fit::DataRange::AddRange(double xmin, double xmax, double ymin, double ymax)

add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate 
";

%feature("docstring")  ROOT::Fit::DataRange::AddRange "void ROOT::Fit::DataRange::AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)

add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and [zmin,zmax] for the third coordinate 
";

%feature("docstring")  ROOT::Fit::DataRange::SetRange "void ROOT::Fit::DataRange::SetRange(unsigned int icoord, double xmin, double xmax)

set a range [xmin,xmax] for the new coordinate icoord If more range exists for other coordinates, delete the existing one and use it the new one Use Add range if want to keep the union of the existing ranges 
";

%feature("docstring")  ROOT::Fit::DataRange::SetRange "void ROOT::Fit::DataRange::SetRange(double xmin, double xmax)

set a range [xmin,xmax] for the first coordinate icoord 
";

%feature("docstring")  ROOT::Fit::DataRange::SetRange "void ROOT::Fit::DataRange::SetRange(double xmin, double xmax, double ymin, double ymax)

set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate 
";

%feature("docstring")  ROOT::Fit::DataRange::SetRange "void ROOT::Fit::DataRange::SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)

set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and [zmin,zmax] for the third coordinate 
";

%feature("docstring")  ROOT::Fit::DataRange::Clear "void ROOT::Fit::DataRange::Clear(unsigned int icoord=0)

clear all ranges in one coordinate (is now -inf, +inf) 
";

%feature("docstring")  ROOT::Fit::DataRange::IsInside "bool ROOT::Fit::DataRange::IsInside(double x, unsigned int icoord=0) const

check if a point is inside the range for the given coordinate 
";

%feature("docstring")  ROOT::Fit::DataRange::IsInside "bool ROOT::Fit::DataRange::IsInside(const double *x) const

check if a multi-dimpoint is inside the range 
";


// File: classROOT_1_1Minuit2_1_1DavidonErrorUpdator.xml
%feature("docstring") ROOT::Minuit2::DavidonErrorUpdator "

Update of the covariance matrix for the Variable Metric minimizer (MIGRAD)

C++ includes: DavidonErrorUpdator.h
";

%feature("docstring")  ROOT::Minuit2::DavidonErrorUpdator::DavidonErrorUpdator "ROOT::Minuit2::DavidonErrorUpdator::DavidonErrorUpdator()
";

%feature("docstring")  ROOT::Minuit2::DavidonErrorUpdator::~DavidonErrorUpdator "virtual ROOT::Minuit2::DavidonErrorUpdator::~DavidonErrorUpdator()
";

%feature("docstring")  ROOT::Minuit2::DavidonErrorUpdator::Update "virtual MinimumError ROOT::Minuit2::DavidonErrorUpdator::Update(const MinimumState &, const MinimumParameters &, const FunctionGradient &) const
";


// File: classDecayingSinPlan.xml
%feature("docstring") DecayingSinPlan "

Settings for standalone fit using Minimizer's residual interface. \"Decaying sin\" objective function from lmfit tutorial is used.

C++ includes: PlanCases.h
";

%feature("docstring")  DecayingSinPlan::DecayingSinPlan "DecayingSinPlan::DecayingSinPlan()
";


// File: classDecayingSinPlanV2.xml
%feature("docstring") DecayingSinPlanV2 "

Same as  DecayingSinPlan with fewer fit parameters.

C++ includes: PlanCases.h
";

%feature("docstring")  DecayingSinPlanV2::DecayingSinPlanV2 "DecayingSinPlanV2::DecayingSinPlanV2()
";


// File: classROOT_1_1Math_1_1Derivator.xml
%feature("docstring") ROOT::Math::Derivator "

Class for computing numerical derivative of a function. Presently this class is implemented only using the numerical derivatives algorithms provided by GSL using the implementation class  ROOT::Math::GSLDerivator

This class does not support copying

C++ includes: Derivator.h
";

%feature("docstring")  ROOT::Math::Derivator::Derivator "ROOT::Math::Derivator::Derivator()

Empty Construct for a  Derivator class Need to set the function afterwards with  Derivator::SetFunction
";

%feature("docstring")  ROOT::Math::Derivator::Derivator "ROOT::Math::Derivator::Derivator(const IGenFunction &f)

Construct using a ROOT::Math::IGenFunction interface 
";

%feature("docstring")  ROOT::Math::Derivator::Derivator "ROOT::Math::Derivator::Derivator(const GSLFuncPointer &f, void *p=0)

Construct using a GSL function pointer type

Parameters:
-----------

f: 
: free function pointer of the GSL required type

p: 
: pointer to the object carrying the function state (for example the function object itself) 
";

%feature("docstring")  ROOT::Math::Derivator::~Derivator "virtual ROOT::Math::Derivator::~Derivator()

destructor 
";

%feature("docstring")  ROOT::Math::Derivator::SetFunction "void ROOT::Math::Derivator::SetFunction(const IGenFunction &f)

Set the function for calculating the derivatives. The function must implement the ROOT::Math::IGenFunction signature 
";

%feature("docstring")  ROOT::Math::Derivator::SetFunction "void ROOT::Math::Derivator::SetFunction(const GSLFuncPointer &f, void *p=0)

Set the function f for evaluating the derivative using a GSL function pointer type

Parameters:
-----------

f: 
: free function pointer of the GSL required type

p: 
: pointer to the object carrying the function state (for example the function object itself) 
";

%feature("docstring")  ROOT::Math::Derivator::Eval "double ROOT::Math::Derivator::Eval(double x, double h=1E-8) const

Computes the numerical derivative of a function f at a point x. It uses  Derivator::EvalCentral to compute the derivative using an adaptive central difference algorithm with a step size h 
";

%feature("docstring")  ROOT::Math::Derivator::EvalCentral "double ROOT::Math::Derivator::EvalCentral(double x, double h=1E-8) const

Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. 
";

%feature("docstring")  ROOT::Math::Derivator::EvalForward "double ROOT::Math::Derivator::EvalForward(double x, double h=1E-8) const

Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. The function is evaluated only at points greater than x and at x itself. 
";

%feature("docstring")  ROOT::Math::Derivator::EvalBackward "double ROOT::Math::Derivator::EvalBackward(double x, double h=1E-8) const

Computes the numerical derivative at a point x using an adaptive backward difference algorithm with a step size h. The function is evaluated only at points less than x and at x itself. 
";


// File: classEasyRosenbrockPlan.xml
%feature("docstring") EasyRosenbrockPlan "

Setting for standalone fit of Rosenbrock function. Fit parameter limits are made small here to help stochastic minimizer to converge in reasonable time.

C++ includes: PlanCases.h
";

%feature("docstring")  EasyRosenbrockPlan::EasyRosenbrockPlan "EasyRosenbrockPlan::EasyRosenbrockPlan()
";


// File: classEasyWoodFourPlan.xml
%feature("docstring") EasyWoodFourPlan "

Setting for standalone fit of WoodFour function. Fit parameter limits are made small here to help stochastic minimizer to converge in reasonable time.

C++ includes: PlanCases.h
";

%feature("docstring")  EasyWoodFourPlan::EasyWoodFourPlan "EasyWoodFourPlan::EasyWoodFourPlan()
";


// File: structROOT_1_1Fit_1_1FitUtil_1_1Evaluate.xml
%feature("docstring") ROOT::Fit::FitUtil::Evaluate "";


// File: structROOT_1_1Math_1_1EvaluatorOneDim.xml
%feature("docstring") ROOT::Math::EvaluatorOneDim "";


// File: structROOT_1_1Math_1_1EvaluatorOneDim_3_01const_01ROOT_1_1Math_1_1IParamMultiFunction_01_6_01_4.xml
%feature("docstring") ROOT::Math::EvaluatorOneDim< const ROOT::Math::IParamMultiFunction & > "
";


// File: classROOT_1_1Fit_1_1FcnAdapter.xml
%feature("docstring") ROOT::Fit::FcnAdapter "";

%feature("docstring")  ROOT::Fit::FcnAdapter::FcnAdapter "ROOT::Fit::FcnAdapter::FcnAdapter(void(*fcn)(int &, double *, double &, double *, int), int dim=0)
";

%feature("docstring")  ROOT::Fit::FcnAdapter::~FcnAdapter "virtual ROOT::Fit::FcnAdapter::~FcnAdapter()
";

%feature("docstring")  ROOT::Fit::FcnAdapter::NDim "virtual unsigned int ROOT::Fit::FcnAdapter::NDim() const

Retrieve the dimension of the function 
";

%feature("docstring")  ROOT::Fit::FcnAdapter::Clone "ROOT::Math::IMultiGenFunction* ROOT::Fit::FcnAdapter::Clone() const

Clone a function. Each derived class must implement their version of the Clone method 
";

%feature("docstring")  ROOT::Fit::FcnAdapter::SetDimension "void ROOT::Fit::FcnAdapter::SetDimension(int dim)
";


// File: classROOT_1_1Minuit2_1_1FCNAdapter.xml
%feature("docstring") ROOT::Minuit2::FCNAdapter "

template wrapped class for adapting to  FCNBase signature

Lorenzo Moneta

C++ includes: FCNAdapter.h
";

%feature("docstring")  ROOT::Minuit2::FCNAdapter::FCNAdapter "ROOT::Minuit2::FCNAdapter< Function >::FCNAdapter(const Function &f, double up=1.)
";

%feature("docstring")  ROOT::Minuit2::FCNAdapter::~FCNAdapter "ROOT::Minuit2::FCNAdapter< Function >::~FCNAdapter()
";

%feature("docstring")  ROOT::Minuit2::FCNAdapter::Up "double ROOT::Minuit2::FCNAdapter< Function >::Up() const

Error definition of the function. MINUIT defines Parameter errors as the change in Parameter Value required to change the function Value by up. Normally, for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5. If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4, as Chi2(x+n*sigma) = Chi2(x) + n*n.

Todo
Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for  ErrorDef()
";

%feature("docstring")  ROOT::Minuit2::FCNAdapter::SetErrorDef "void ROOT::Minuit2::FCNAdapter< Function >::SetErrorDef(double up)

add interface to set dynamically a new error definition Re-implement this function if needed. 
";


// File: classROOT_1_1Minuit2_1_1FCNBase.xml
%feature("docstring") ROOT::Minuit2::FCNBase "

Interface (abstract class) defining the function to be minimized, which has to be implemented by the user.

Fred James and Matthias Winkler; modified by Andras Zsenei and Lorenzo Moneta

C++ includes: FCNBase.h
";

%feature("docstring")  ROOT::Minuit2::FCNBase::~FCNBase "virtual ROOT::Minuit2::FCNBase::~FCNBase()
";

%feature("docstring")  ROOT::Minuit2::FCNBase::ErrorDef "virtual double ROOT::Minuit2::FCNBase::ErrorDef() const

Error definition of the function. MINUIT defines Parameter errors as the change in Parameter Value required to change the function Value by up. Normally, for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5. If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4, as Chi2(x+n*sigma) = Chi2(x) + n*n.

Comment a little bit better with links!!!!!!!!!!!!!!!!! 
";

%feature("docstring")  ROOT::Minuit2::FCNBase::Up "virtual double ROOT::Minuit2::FCNBase::Up() const =0

Error definition of the function. MINUIT defines Parameter errors as the change in Parameter Value required to change the function Value by up. Normally, for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5. If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4, as Chi2(x+n*sigma) = Chi2(x) + n*n.

Todo
Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for  ErrorDef()
";

%feature("docstring")  ROOT::Minuit2::FCNBase::SetErrorDef "virtual void ROOT::Minuit2::FCNBase::SetErrorDef(double)

add interface to set dynamically a new error definition Re-implement this function if needed. 
";


// File: classROOT_1_1Minuit2_1_1FCNGradAdapter.xml
%feature("docstring") ROOT::Minuit2::FCNGradAdapter "

template wrapped class for adapting to  FCNBase signature a IGradFunction

Lorenzo Moneta

C++ includes: FCNGradAdapter.h
";

%feature("docstring")  ROOT::Minuit2::FCNGradAdapter::FCNGradAdapter "ROOT::Minuit2::FCNGradAdapter< Function >::FCNGradAdapter(const Function &f, double up=1.)
";

%feature("docstring")  ROOT::Minuit2::FCNGradAdapter::~FCNGradAdapter "ROOT::Minuit2::FCNGradAdapter< Function >::~FCNGradAdapter()
";

%feature("docstring")  ROOT::Minuit2::FCNGradAdapter::Up "double ROOT::Minuit2::FCNGradAdapter< Function >::Up() const

Error definition of the function. MINUIT defines Parameter errors as the change in Parameter Value required to change the function Value by up. Normally, for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5. If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4, as Chi2(x+n*sigma) = Chi2(x) + n*n.

Todo
Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for  ErrorDef()
";

%feature("docstring")  ROOT::Minuit2::FCNGradAdapter::Gradient "std::vector<double> ROOT::Minuit2::FCNGradAdapter< Function >::Gradient(const std::vector< double > &v) const
";

%feature("docstring")  ROOT::Minuit2::FCNGradAdapter::CheckGradient "bool ROOT::Minuit2::FCNGradAdapter< Function >::CheckGradient() const
";


// File: classROOT_1_1Minuit2_1_1FCNGradientBase.xml
%feature("docstring") ROOT::Minuit2::FCNGradientBase "

Extension of the  FCNBase for providing the analytical Gradient of the function. The user-Gradient is checked at the beginning of the minimization against the Minuit internal numerical Gradient in order to spot problems in the analytical Gradient calculation. This can be turned off by overriding CheckGradient() to make it return \"false\". The size of the output Gradient vector must be equal to the size of the input Parameter vector. Minuit does a check of the user Gradient at the beginning, if this is not wanted the method \"CheckGradient()\" has to be overridden to return \"false\".

C++ includes: FCNGradientBase.h
";

%feature("docstring")  ROOT::Minuit2::FCNGradientBase::~FCNGradientBase "virtual ROOT::Minuit2::FCNGradientBase::~FCNGradientBase()
";

%feature("docstring")  ROOT::Minuit2::FCNGradientBase::Gradient "virtual std::vector<double> ROOT::Minuit2::FCNGradientBase::Gradient(const std::vector< double > &) const =0
";

%feature("docstring")  ROOT::Minuit2::FCNGradientBase::CheckGradient "virtual bool ROOT::Minuit2::FCNGradientBase::CheckGradient() const
";


// File: classROOT_1_1Fit_1_1FitConfig.xml
%feature("docstring") ROOT::Fit::FitConfig "

Class describing the configuration of the fit, options and parameter settings using the  ROOT::Fit::ParameterSettings class

C++ includes: FitConfig.h
";

%feature("docstring")  ROOT::Fit::FitConfig::FitConfig "ROOT::Fit::FitConfig::FitConfig(unsigned int npar=0)

Default constructor 
";

%feature("docstring")  ROOT::Fit::FitConfig::FitConfig "ROOT::Fit::FitConfig::FitConfig(const FitConfig &rhs)
";

%feature("docstring")  ROOT::Fit::FitConfig::~FitConfig "ROOT::Fit::FitConfig::~FitConfig()

Destructor 
";

%feature("docstring")  ROOT::Fit::FitConfig::ParSettings "const ParameterSettings& ROOT::Fit::FitConfig::ParSettings(unsigned int i) const

get the parameter settings for the i-th parameter (const method) 
";

%feature("docstring")  ROOT::Fit::FitConfig::ParSettings "ParameterSettings& ROOT::Fit::FitConfig::ParSettings(unsigned int i)

get the parameter settings for the i-th parameter (non-const method) 
";

%feature("docstring")  ROOT::Fit::FitConfig::ParamsSettings "const std::vector<ROOT::Fit::ParameterSettings>& ROOT::Fit::FitConfig::ParamsSettings() const

get the vector of parameter settings (const method) 
";

%feature("docstring")  ROOT::Fit::FitConfig::ParamsSettings "std::vector<ROOT::Fit::ParameterSettings>& ROOT::Fit::FitConfig::ParamsSettings()

get the vector of parameter settings (non-const method) 
";

%feature("docstring")  ROOT::Fit::FitConfig::NPar "unsigned int ROOT::Fit::FitConfig::NPar() const

number of parameters settings 
";

%feature("docstring")  ROOT::Fit::FitConfig::ParamsValues "std::vector<double> ROOT::Fit::FitConfig::ParamsValues() const

return a vector of stored parameter values (i.e initial fit parameters) 
";

%feature("docstring")  ROOT::Fit::FitConfig::CreateParamsSettings "void ROOT::Fit::FitConfig::CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)

set the parameter settings from a model function. Create always new parameter setting list from a given model function 
";

%feature("docstring")  ROOT::Fit::FitConfig::SetParamsSettings "void ROOT::Fit::FitConfig::SetParamsSettings(unsigned int npar, const double *params, const double *vstep=0)

set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. 
";

%feature("docstring")  ROOT::Fit::FitConfig::SetParamsSettings "void ROOT::Fit::FitConfig::SetParamsSettings(const std::vector< ROOT::Fit::ParameterSettings > &pars)
";

%feature("docstring")  ROOT::Fit::FitConfig::SetFromFitResult "void ROOT::Fit::FitConfig::SetFromFitResult(const FitResult &rhs)
";

%feature("docstring")  ROOT::Fit::FitConfig::CreateMinimizer "ROOT::Math::Minimizer* ROOT::Fit::FitConfig::CreateMinimizer()

create a new minimizer according to chosen configuration 
";

%feature("docstring")  ROOT::Fit::FitConfig::MinimizerOptions "ROOT::Math::MinimizerOptions& ROOT::Fit::FitConfig::MinimizerOptions()

access to the minimizer control parameter (non const method) 
";

%feature("docstring")  ROOT::Fit::FitConfig::SetMinimizerOptions "void ROOT::Fit::FitConfig::SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)

set all the minimizer options using class  MinimizerOptions
";

%feature("docstring")  ROOT::Fit::FitConfig::SetMinimizer "void ROOT::Fit::FitConfig::SetMinimizer(const char *type, const char *algo=0)

set minimizer type 
";

%feature("docstring")  ROOT::Fit::FitConfig::MinimizerType "const std::string& ROOT::Fit::FitConfig::MinimizerType() const

return type of minimizer package 
";

%feature("docstring")  ROOT::Fit::FitConfig::MinimizerAlgoType "const std::string& ROOT::Fit::FitConfig::MinimizerAlgoType() const

return type of minimizer algorithms 
";

%feature("docstring")  ROOT::Fit::FitConfig::NormalizeErrors "bool ROOT::Fit::FitConfig::NormalizeErrors() const

flag to check if resulting errors are be normalized according to chi2/ndf 
";

%feature("docstring")  ROOT::Fit::FitConfig::ParabErrors "bool ROOT::Fit::FitConfig::ParabErrors() const

do analysis for parabolic errors 
";

%feature("docstring")  ROOT::Fit::FitConfig::MinosErrors "bool ROOT::Fit::FitConfig::MinosErrors() const

do minos errros analysis on the parameters 
";

%feature("docstring")  ROOT::Fit::FitConfig::UpdateAfterFit "bool ROOT::Fit::FitConfig::UpdateAfterFit() const

Update configuration after a fit using the  FitResult. 
";

%feature("docstring")  ROOT::Fit::FitConfig::UseWeightCorrection "bool ROOT::Fit::FitConfig::UseWeightCorrection() const

Apply Weight correction for error matrix computation. 
";

%feature("docstring")  ROOT::Fit::FitConfig::MinosParams "const std::vector<unsigned int>& ROOT::Fit::FitConfig::MinosParams() const

return vector of parameter indeces for which the Minos Error will be computed 
";

%feature("docstring")  ROOT::Fit::FitConfig::SetNormErrors "void ROOT::Fit::FitConfig::SetNormErrors(bool on=true)

set the option to normalize the error on the result according to chi2/ndf 
";

%feature("docstring")  ROOT::Fit::FitConfig::SetParabErrors "void ROOT::Fit::FitConfig::SetParabErrors(bool on=true)

set parabolic erros 
";

%feature("docstring")  ROOT::Fit::FitConfig::SetMinosErrors "void ROOT::Fit::FitConfig::SetMinosErrors(bool on=true)

set Minos erros computation to be performed after fitting 
";

%feature("docstring")  ROOT::Fit::FitConfig::SetWeightCorrection "void ROOT::Fit::FitConfig::SetWeightCorrection(bool on=true)

apply the weight correction for error matric computation 
";

%feature("docstring")  ROOT::Fit::FitConfig::SetMinosErrors "void ROOT::Fit::FitConfig::SetMinosErrors(const std::vector< unsigned int > &paramInd)

set parameter indeces for running Minos this can be used for running Minos on a subset of parameters - otherwise is run on all of them if  MinosErrors() is set 
";

%feature("docstring")  ROOT::Fit::FitConfig::SetUpdateAfterFit "void ROOT::Fit::FitConfig::SetUpdateAfterFit(bool on=true)

Update configuration after a fit using the  FitResult. 
";


// File: classFitOptions.xml
%feature("docstring") FitOptions "

General fitting options.

C++ includes: FitOptions.h
";

%feature("docstring")  FitOptions::FitOptions "FitOptions::FitOptions()
";

%feature("docstring")  FitOptions::derivEpsilon "double FitOptions::derivEpsilon() const
";

%feature("docstring")  FitOptions::setDerivEpsilon "void FitOptions::setDerivEpsilon(double deriv_epsilon)
";

%feature("docstring")  FitOptions::stepFactor "double FitOptions::stepFactor() const
";

%feature("docstring")  FitOptions::setStepFactor "void FitOptions::setStepFactor(double step_factor)
";


// File: classROOT_1_1Fit_1_1FitResult.xml
%feature("docstring") ROOT::Fit::FitResult "

class containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values. When the fit is valid, it is constructed from a Minimizer and a model function pointer

C++ includes: FitResult.h
";

%feature("docstring")  ROOT::Fit::FitResult::FitResult "ROOT::Fit::FitResult::FitResult()

Default constructor for an empty (non valid) fit result 
";

%feature("docstring")  ROOT::Fit::FitResult::FitResult "ROOT::Fit::FitResult::FitResult(const FitConfig &fconfig)

Constructor from a fit-config for a dummy fit (e.g. when only one fcn evaluation is done) 
";

%feature("docstring")  ROOT::Fit::FitResult::FitResult "ROOT::Fit::FitResult::FitResult(const FitResult &rhs)

Copy constructor. 
";

%feature("docstring")  ROOT::Fit::FitResult::~FitResult "virtual ROOT::Fit::FitResult::~FitResult()

Destructor 
";

%feature("docstring")  ROOT::Fit::FitResult::FillResult "void ROOT::Fit::FitResult::FillResult(const std::shared_ptr< ROOT::Math::Minimizer > &min, const FitConfig &fconfig, const std::shared_ptr< IModelFunction > &f, bool isValid, unsigned int sizeOfData=0, bool binFit=true, const ROOT::Math::IMultiGenFunction *chi2func=0, unsigned int ncalls=0)

Fill the fit result from a Minimizer instance after fitting Run also Minos if requested from the configuration 
";

%feature("docstring")  ROOT::Fit::FitResult::Update "bool ROOT::Fit::FitResult::Update(const std::shared_ptr< ROOT::Math::Minimizer > &min, bool isValid, unsigned int ncalls=0)

Update the fit result with a new minimization status To be run only if same fit is performed with same configuration Note that in this case MINOS is not re-run. If one wants to run also MINOS a new result must be created 
";

%feature("docstring")  ROOT::Fit::FitResult::MinimizerType "const std::string& ROOT::Fit::FitResult::MinimizerType() const

minimizer type

minimization quantities 
";

%feature("docstring")  ROOT::Fit::FitResult::IsValid "bool ROOT::Fit::FitResult::IsValid() const

True if fit successful, otherwise false. A fit is considered successful if the minimizer succeded in finding the minimum. It could happen that subsequent operations like error analysis (e.g. Minos) failed. In that case the status can be still true if the original minimization algorithm succeeded in finding the minimum. One can query in that case the minimizer return status using  Status(). It is responability to the Minimizer class to tag a found minimum as valid or not and to produce also a status code. 
";

%feature("docstring")  ROOT::Fit::FitResult::IsEmpty "bool ROOT::Fit::FitResult::IsEmpty() const

True if a fit result does not exist (even invalid) with parameter values. 
";

%feature("docstring")  ROOT::Fit::FitResult::MinFcnValue "double ROOT::Fit::FitResult::MinFcnValue() const

Return value of the objective function (chi2 or likelihood) used in the fit. 
";

%feature("docstring")  ROOT::Fit::FitResult::NCalls "unsigned int ROOT::Fit::FitResult::NCalls() const

Number of function calls to find minimum. 
";

%feature("docstring")  ROOT::Fit::FitResult::Edm "double ROOT::Fit::FitResult::Edm() const

Expected distance from minimum. 
";

%feature("docstring")  ROOT::Fit::FitResult::NTotalParameters "unsigned int ROOT::Fit::FitResult::NTotalParameters() const

get total number of parameters 
";

%feature("docstring")  ROOT::Fit::FitResult::NPar "unsigned int ROOT::Fit::FitResult::NPar() const

total number of parameters (abbreviation) 
";

%feature("docstring")  ROOT::Fit::FitResult::NFreeParameters "unsigned int ROOT::Fit::FitResult::NFreeParameters() const

get total number of free parameters 
";

%feature("docstring")  ROOT::Fit::FitResult::Status "int ROOT::Fit::FitResult::Status() const

minimizer status code 
";

%feature("docstring")  ROOT::Fit::FitResult::CovMatrixStatus "int ROOT::Fit::FitResult::CovMatrixStatus() const

covariance matrix status code using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate 
";

%feature("docstring")  ROOT::Fit::FitResult::FittedFunction "const IModelFunction* ROOT::Fit::FitResult::FittedFunction() const

fitting quantities Return pointer to model (fit) function with fitted parameter values. Pointer is managed internally. I must not be deleted 
";

%feature("docstring")  ROOT::Fit::FitResult::FittedBinData "const BinData* ROOT::Fit::FitResult::FittedBinData() const

return  BinData used in the fit (return a nullptr in case a different fit is done or the data are not available Pointer is managed internally, it must not be deleted 
";

%feature("docstring")  ROOT::Fit::FitResult::Chi2 "double ROOT::Fit::FitResult::Chi2() const

Chi2 fit value in case of likelihood must be computed ? 
";

%feature("docstring")  ROOT::Fit::FitResult::Ndf "unsigned int ROOT::Fit::FitResult::Ndf() const

Number of degree of freedom. 
";

%feature("docstring")  ROOT::Fit::FitResult::Prob "double ROOT::Fit::FitResult::Prob() const

p value of the fit (chi2 probability) 
";

%feature("docstring")  ROOT::Fit::FitResult::Errors "const std::vector<double>& ROOT::Fit::FitResult::Errors() const

parameter errors (return st::vector) 
";

%feature("docstring")  ROOT::Fit::FitResult::GetErrors "const double* ROOT::Fit::FitResult::GetErrors() const

parameter errors (return const pointer) 
";

%feature("docstring")  ROOT::Fit::FitResult::Parameters "const std::vector<double>& ROOT::Fit::FitResult::Parameters() const

parameter values (return std::vector) 
";

%feature("docstring")  ROOT::Fit::FitResult::GetParams "const double* ROOT::Fit::FitResult::GetParams() const

parameter values (return const pointer) 
";

%feature("docstring")  ROOT::Fit::FitResult::Value "double ROOT::Fit::FitResult::Value(unsigned int i) const

parameter value by index 
";

%feature("docstring")  ROOT::Fit::FitResult::Parameter "double ROOT::Fit::FitResult::Parameter(unsigned int i) const

parameter value by index 
";

%feature("docstring")  ROOT::Fit::FitResult::Error "double ROOT::Fit::FitResult::Error(unsigned int i) const

parameter error by index 
";

%feature("docstring")  ROOT::Fit::FitResult::ParError "double ROOT::Fit::FitResult::ParError(unsigned int i) const

parameter error by index 
";

%feature("docstring")  ROOT::Fit::FitResult::ParName "std::string ROOT::Fit::FitResult::ParName(unsigned int i) const

name of the parameter 
";

%feature("docstring")  ROOT::Fit::FitResult::SetMinosError "void ROOT::Fit::FitResult::SetMinosError(unsigned int i, double elow, double eup)

set the Minos errors for parameter i (called by the  Fitter class when running Minos) 
";

%feature("docstring")  ROOT::Fit::FitResult::HasMinosError "bool ROOT::Fit::FitResult::HasMinosError(unsigned int i) const

query if parameter i has the Minos error 
";

%feature("docstring")  ROOT::Fit::FitResult::LowerError "double ROOT::Fit::FitResult::LowerError(unsigned int i) const

lower Minos error. If Minos has not run for parameter i return the parabolic error 
";

%feature("docstring")  ROOT::Fit::FitResult::UpperError "double ROOT::Fit::FitResult::UpperError(unsigned int i) const

upper Minos error. If Minos has not run for parameter i return the parabolic error 
";

%feature("docstring")  ROOT::Fit::FitResult::GlobalCC "double ROOT::Fit::FitResult::GlobalCC(unsigned int i) const

parameter global correlation coefficient 
";

%feature("docstring")  ROOT::Fit::FitResult::CovMatrix "double ROOT::Fit::FitResult::CovMatrix(unsigned int i, unsigned int j) const

retrieve covariance matrix element 
";

%feature("docstring")  ROOT::Fit::FitResult::Correlation "double ROOT::Fit::FitResult::Correlation(unsigned int i, unsigned int j) const

retrieve correlation elements 
";

%feature("docstring")  ROOT::Fit::FitResult::GetCovarianceMatrix "void ROOT::Fit::FitResult::GetCovarianceMatrix(Matrix &mat) const

fill covariance matrix elements using a generic matrix class implementing operator(i,j) the matrix must be previously allocates with right size (npar * npar) 
";

%feature("docstring")  ROOT::Fit::FitResult::GetCorrelationMatrix "void ROOT::Fit::FitResult::GetCorrelationMatrix(Matrix &mat) const

fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j) the matrix must be previously allocates with right size (npar * npar) 
";

%feature("docstring")  ROOT::Fit::FitResult::GetConfidenceIntervals "void ROOT::Fit::FitResult::GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double *x, double *ci, double cl=0.95, bool norm=false) const

get confidence intervals for an array of n points x. stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space. For 1-dim points : stride1=1, stride2=1 for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1

the confidence interval are returned in the array ci cl is the desired confidedence interval value norm is a flag to control if the intervals need to be normalized to the chi2/ndf value The intervals can be corrected optionally using the chi2/ndf value of the fit if a chi2 fit is performed. This has changed since  ROOT 6.14, before the interval were corrected by default. 
";

%feature("docstring")  ROOT::Fit::FitResult::GetConfidenceIntervals "void ROOT::Fit::FitResult::GetConfidenceIntervals(const BinData &data, double *ci, double cl=0.95, bool norm=false) const

evaluate confidence interval for the point specified in the passed data sets the confidence interval are returned in the array ci cl is the desired confidence interval value. This method is mantained for backward compatibility and will be deprecated 
";

%feature("docstring")  ROOT::Fit::FitResult::GetConfidenceIntervals "std::vector<double> ROOT::Fit::FitResult::GetConfidenceIntervals(double cl=0.95, bool norm=false) const

evaluate confidence interval for the data set used in the last fit the confidence interval are returned as a vector of data points 
";

%feature("docstring")  ROOT::Fit::FitResult::Scan "bool ROOT::Fit::FitResult::Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin=0, double xmax=0)

scan likelihood value of parameter and fill the given graph. 
";

%feature("docstring")  ROOT::Fit::FitResult::Contour "bool ROOT::Fit::FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)

create contour of two parameters around the minimum pass as option confidence level: default is a value of 0.683 
";

%feature("docstring")  ROOT::Fit::FitResult::Index "int ROOT::Fit::FitResult::Index(const std::string &name) const

get index for parameter name (return -1 if not found) 
";

%feature("docstring")  ROOT::Fit::FitResult::NormalizeErrors "void ROOT::Fit::FitResult::NormalizeErrors()

normalize errors using chi2/ndf for chi2 fits 
";

%feature("docstring")  ROOT::Fit::FitResult::NormalizedErrors "bool ROOT::Fit::FitResult::NormalizedErrors() const

flag to chek if errors are normalized 
";

%feature("docstring")  ROOT::Fit::FitResult::Print "void ROOT::Fit::FitResult::Print(std::ostream &os, bool covmat=false) const

print the result and optionaly covariance matrix and correlations 
";

%feature("docstring")  ROOT::Fit::FitResult::PrintCovMatrix "void ROOT::Fit::FitResult::PrintCovMatrix(std::ostream &os) const

print error matrix and correlations 
";

%feature("docstring")  ROOT::Fit::FitResult::IsParameterBound "bool ROOT::Fit::FitResult::IsParameterBound(unsigned int ipar) const

query if a parameter is bound 
";

%feature("docstring")  ROOT::Fit::FitResult::IsParameterFixed "bool ROOT::Fit::FitResult::IsParameterFixed(unsigned int ipar) const

query if a parameter is fixed 
";

%feature("docstring")  ROOT::Fit::FitResult::ParameterBounds "bool ROOT::Fit::FitResult::ParameterBounds(unsigned int ipar, double &lower, double &upper) const

retrieve parameter bounds - return false if parameter is not bound 
";

%feature("docstring")  ROOT::Fit::FitResult::GetParameterName "std::string ROOT::Fit::FitResult::GetParameterName(unsigned int ipar) const

get name of parameter (deprecated) 
";


// File: classROOT_1_1Fit_1_1Fitter.xml
%feature("docstring") ROOT::Fit::Fitter "

Fitter class, entry point for performing all type of fits. Fits are performed using the generic  ROOT::Fit::Fitter::Fit method. The inputs are the data points and a model function (using a ROOT::Math::IParamFunction) The result of the fit is returned and kept internally in the  ROOT::Fit::FitResult class. The configuration of the fit (parameters, options, etc...) are specified in the ROOT::Math::FitConfig class. After fitting the config of the fit will be modified to have the new values the resulting parameter of the fit with step sizes equal to the errors.  FitConfig can be preserved with initial parameters by calling FitConfig.SetUpdateAfterFit(false);

C++ includes: Fitter.h
";

%feature("docstring")  ROOT::Fit::Fitter::Fitter "ROOT::Fit::Fitter::Fitter()

Default constructor 
";

%feature("docstring")  ROOT::Fit::Fitter::Fitter "ROOT::Fit::Fitter::Fitter(const std::shared_ptr< FitResult > &result)

Constructor from a result 
";

%feature("docstring")  ROOT::Fit::Fitter::~Fitter "ROOT::Fit::Fitter::~Fitter()

Destructor 
";

%feature("docstring")  ROOT::Fit::Fitter::Fit "bool ROOT::Fit::Fitter::Fit(const Data &data, const Function &func, const ROOT::Fit::ExecutionPolicy &executionPolicy=ROOT::Fit::ExecutionPolicy::kSerial)

fit a data set using any generic model function If data set is binned a least square fit is performed If data set is unbinned a maximum likelihood fit (not extended) is done Pre-requisite on the function: it must implement the 1D or multidimensional parametric function interface 
";

%feature("docstring")  ROOT::Fit::Fitter::Fit "bool ROOT::Fit::Fitter::Fit(const BinData &data, const ROOT::Fit::ExecutionPolicy &executionPolicy=ROOT::Fit::ExecutionPolicy::kSerial)

Fit a binned data set using a least square fit (default method) 
";

%feature("docstring")  ROOT::Fit::Fitter::Fit "bool ROOT::Fit::Fitter::Fit(const std::shared_ptr< BinData > &data, const ROOT::Fit::ExecutionPolicy &executionPolicy=ROOT::Fit::ExecutionPolicy::kSerial)
";

%feature("docstring")  ROOT::Fit::Fitter::LeastSquareFit "bool ROOT::Fit::Fitter::LeastSquareFit(const BinData &data)

Fit a binned data set using a least square fit 
";

%feature("docstring")  ROOT::Fit::Fitter::Fit "bool ROOT::Fit::Fitter::Fit(const UnBinData &data, bool extended=false, const ROOT::Fit::ExecutionPolicy &executionPolicy=ROOT::Fit::ExecutionPolicy::kSerial)

fit an unbinned data set using loglikelihood method 
";

%feature("docstring")  ROOT::Fit::Fitter::LikelihoodFit "bool ROOT::Fit::Fitter::LikelihoodFit(const BinData &data, bool extended=true, const ROOT::Fit::ExecutionPolicy &executionPolicy=ROOT::Fit::ExecutionPolicy::kSerial)

Binned Likelihood fit. Default is extended 
";

%feature("docstring")  ROOT::Fit::Fitter::LikelihoodFit "bool ROOT::Fit::Fitter::LikelihoodFit(const std::shared_ptr< BinData > &data, bool extended=true, const ROOT::Fit::ExecutionPolicy &executionPolicy=ROOT::Fit::ExecutionPolicy::kSerial)
";

%feature("docstring")  ROOT::Fit::Fitter::LikelihoodFit "bool ROOT::Fit::Fitter::LikelihoodFit(const UnBinData &data, bool extended=false, const ROOT::Fit::ExecutionPolicy &executionPolicy=ROOT::Fit::ExecutionPolicy::kSerial)

Unbinned Likelihood fit. Default is not extended 
";

%feature("docstring")  ROOT::Fit::Fitter::LikelihoodFit "bool ROOT::Fit::Fitter::LikelihoodFit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::Fit::ExecutionPolicy &executionPolicy=ROOT::Fit::ExecutionPolicy::kSerial)
";

%feature("docstring")  ROOT::Fit::Fitter::LikelihoodFit "bool ROOT::Fit::Fitter::LikelihoodFit(const Data &data, const Function &func, bool extended)

fit a data set using any generic model function Pre-requisite on the function: 
";

%feature("docstring")  ROOT::Fit::Fitter::LinearFit "bool ROOT::Fit::Fitter::LinearFit(const BinData &data)

do a linear fit on a set of bin-data 
";

%feature("docstring")  ROOT::Fit::Fitter::LinearFit "bool ROOT::Fit::Fitter::LinearFit(const std::shared_ptr< BinData > &data)
";

%feature("docstring")  ROOT::Fit::Fitter::FitFCN "bool ROOT::Fit::Fitter::FitFCN(unsigned int npar, Function &fcn, const double *params=0, unsigned int dataSize=0, bool chi2fit=false)

Fit using the a generic FCN function as a C++ callable object implementing double () (const double *) Note that the function dimension (i.e. the number of parameter) is needed in this case For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..) 
";

%feature("docstring")  ROOT::Fit::Fitter::SetFCN "bool ROOT::Fit::Fitter::SetFCN(unsigned int npar, Function &fcn, const double *params=0, unsigned int dataSize=0, bool chi2fit=false)

Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that the function dimension (i.e. the number of parameter) is needed in this case For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..) 
";

%feature("docstring")  ROOT::Fit::Fitter::FitFCN "bool ROOT::Fit::Fitter::FitFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params=0, unsigned int dataSize=0, bool chi2fit=false)

Fit using the given FCN function represented by a multi-dimensional function interface (ROOT::Math::IMultiGenFunction). Give optionally the initial arameter values, data size to have the fit Ndf correctly set in the  FitResult and flag specifying if it is a chi2 fit. Note that if the parameters values are not given (params=0) the current parameter settings are used. The parameter settings can be created before by using the FitConfig::SetParamsSetting. If they have not been created they are created automatically when the params pointer is not zero. Note that passing a params != 0 will set the parameter settings to the new value AND also the step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ) 
";

%feature("docstring")  ROOT::Fit::Fitter::FitFCN "bool ROOT::Fit::Fitter::FitFCN(const ROOT::Math::FitMethodFunction &fcn, const double *params=0)

Fit using a FitMethodFunction interface. Same as method above, but now extra information can be taken from the function class 
";

%feature("docstring")  ROOT::Fit::Fitter::SetFCN "bool ROOT::Fit::Fitter::SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params=0, unsigned int dataSize=0, bool chi2fit=false)

Set the FCN function represented by a multi-dimensional function interface (ROOT::Math::IMultiGenFunction) and optionally the initial parameters See also note above for the initial parameters for FitFCN 
";

%feature("docstring")  ROOT::Fit::Fitter::SetFCN "bool ROOT::Fit::Fitter::SetFCN(const ROOT::Math::FitMethodFunction &fcn, const double *params=0)

Set the objective function (FCN) using a FitMethodFunction interface. Same as method above, but now extra information can be taken from the function class 
";

%feature("docstring")  ROOT::Fit::Fitter::FitFCN "bool ROOT::Fit::Fitter::FitFCN(const ROOT::Math::IMultiGradFunction &fcn, const double *params=0, unsigned int dataSize=0, bool chi2fit=false)

Fit using the given FCN function representing a multi-dimensional gradient function interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the gradient information provided by the function. For the options same consideration as in the previous method 
";

%feature("docstring")  ROOT::Fit::Fitter::FitFCN "bool ROOT::Fit::Fitter::FitFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=0)

Fit using a FitMethodGradFunction interface. Same as method above, but now extra information can be taken from the function class 
";

%feature("docstring")  ROOT::Fit::Fitter::SetFCN "bool ROOT::Fit::Fitter::SetFCN(const ROOT::Math::IMultiGradFunction &fcn, const double *params=0, unsigned int dataSize=0, bool chi2fit=false)

Set the FCN function represented by a multi-dimensional gradient function interface (ROOT::Math::IMultiGenFunction) and optionally the initial parameters See also note above for the initial parameters for FitFCN 
";

%feature("docstring")  ROOT::Fit::Fitter::SetFCN "bool ROOT::Fit::Fitter::SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=0)

Set the objective function (FCN) using a FitMethodGradFunction interface. Same as method above, but now extra information can be taken from the function class 
";

%feature("docstring")  ROOT::Fit::Fitter::FitFCN "bool ROOT::Fit::Fitter::FitFCN(MinuitFCN_t fcn, int npar=0, const double *params=0, unsigned int dataSize=0, bool chi2fit=false)
";

%feature("docstring")  ROOT::Fit::Fitter::SetFCN "bool ROOT::Fit::Fitter::SetFCN(MinuitFCN_t fcn, int npar=0, const double *params=0, unsigned int dataSize=0, bool chi2fit=false)

set objective function using user provided FCN with Minuit-like interface If npar = 0 it is assumed that the parameters are specified in the parameter settings created before For the options same consideration as in the previous method 
";

%feature("docstring")  ROOT::Fit::Fitter::FitFCN "bool ROOT::Fit::Fitter::FitFCN()

Perform a fit with the previously set FCN function. Require SetFCN before 
";

%feature("docstring")  ROOT::Fit::Fitter::EvalFCN "bool ROOT::Fit::Fitter::EvalFCN()

Perform a simple FCN evaluation.  FitResult will be modified and contain the value of the FCN 
";

%feature("docstring")  ROOT::Fit::Fitter::SetFunction "void ROOT::Fit::Fitter::SetFunction(const IModelFunction &func, bool useGradient=false)

Set the fitted function (model function) from a parametric function interface 
";

%feature("docstring")  ROOT::Fit::Fitter::SetFunction "void ROOT::Fit::Fitter::SetFunction(const IModel1DFunction &func, bool useGradient=false)

Set the fitted function (model function) from a vectorized parametric function interface Set the fitted function from a parametric 1D function interface 
";

%feature("docstring")  ROOT::Fit::Fitter::SetFunction "void ROOT::Fit::Fitter::SetFunction(const IGradModelFunction &func, bool useGradient=true)

Set the fitted function (model function) from a parametric gradient function interface 
";

%feature("docstring")  ROOT::Fit::Fitter::SetFunction "void ROOT::Fit::Fitter::SetFunction(const IGradModel1DFunction &func, bool useGradient=true)

Set the fitted function from 1D gradient parametric function interface 
";

%feature("docstring")  ROOT::Fit::Fitter::Result "const FitResult& ROOT::Fit::Fitter::Result() const

get fit result 
";

%feature("docstring")  ROOT::Fit::Fitter::CalculateHessErrors "bool ROOT::Fit::Fitter::CalculateHessErrors()

perform an error analysis on the result using the Hessian Errors are obtaied from the inverse of the Hessian matrix To be called only after fitting and when a minimizer supporting the Hessian calculations is used otherwise an error (false) is returned. A new  FitResult with the Hessian result will be produced 
";

%feature("docstring")  ROOT::Fit::Fitter::CalculateMinosErrors "bool ROOT::Fit::Fitter::CalculateMinosErrors()

perform an error analysis on the result using MINOS To be called only after fitting and when a minimizer supporting MINOS is used otherwise an error (false) is returned. The result will be appended in the fit result class Optionally a vector of parameter indeces can be passed for selecting the parameters to analyse using  FitConfig::SetMinosErrors
";

%feature("docstring")  ROOT::Fit::Fitter::Config "const FitConfig& ROOT::Fit::Fitter::Config() const

access to the fit configuration (const method) 
";

%feature("docstring")  ROOT::Fit::Fitter::Config "FitConfig& ROOT::Fit::Fitter::Config()

access to the configuration (non const method) 
";

%feature("docstring")  ROOT::Fit::Fitter::IsBinFit "bool ROOT::Fit::Fitter::IsBinFit() const

query if fit is binned. In cse of false teh fit can be unbinned or is not defined (like in case of fitting through a ::FitFCN) 
";

%feature("docstring")  ROOT::Fit::Fitter::GetMinimizer "ROOT::Math::Minimizer* ROOT::Fit::Fitter::GetMinimizer() const

return pointer to last used minimizer (is NULL in case fit is not yet done) This pointer is guranteed to be valid as far as the fitter class is valid and a new fit is not redone. To be used only after fitting. The pointer should not be stored and will be invalided after performing a new fitting. In this case a new instance of  ROOT::Math::Minimizer will be re-created and can be obtained calling again  GetMinimizer()
";

%feature("docstring")  ROOT::Fit::Fitter::GetFCN "ROOT::Math::IMultiGenFunction* ROOT::Fit::Fitter::GetFCN() const

return pointer to last used objective function (is NULL in case fit is not yet done) This pointer will be valid as far as the fitter class has not been deleted. To be used after the fitting. The pointer should not be stored and will be invalided after performing a new fitting. In this case a new instance of the function pointer will be re-created and can be obtained calling again  GetFCN()
";

%feature("docstring")  ROOT::Fit::Fitter::ApplyWeightCorrection "bool ROOT::Fit::Fitter::ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction &loglw2, bool minimizeW2L=false)

apply correction in the error matrix for the weights for likelihood fits This method can be called only after a fit. The passed function (loglw2) is a log-likelihood function impelemented using the sum of weight squared When using  FitConfig.SetWeightCorrection() this correction is applied automatically when doing a likelihood fit (binned or unbinned) 
";


// File: classROOT_1_1Minuit2_1_1FumiliBuilder.xml
%feature("docstring") ROOT::Minuit2::FumiliBuilder "

Builds the  FunctionMinimum using the Fumili method.

Andras Zsenei, Creation date: 29 Sep 2004

See: 
MINUIT Tutorial on function minimization, section 5
Todo
the role of the strategy in Fumili

C++ includes: FumiliBuilder.h
";

%feature("docstring")  ROOT::Minuit2::FumiliBuilder::FumiliBuilder "ROOT::Minuit2::FumiliBuilder::FumiliBuilder()
";

%feature("docstring")  ROOT::Minuit2::FumiliBuilder::~FumiliBuilder "ROOT::Minuit2::FumiliBuilder::~FumiliBuilder()
";

%feature("docstring")  ROOT::Minuit2::FumiliBuilder::Minimum "virtual FunctionMinimum ROOT::Minuit2::FumiliBuilder::Minimum(const MnFcn &fMnFcn, const GradientCalculator &fGradienCalculator, const MinimumSeed &fMinimumSeed, const MnStrategy &fMnStrategy, unsigned int maxfcn, double edmval) const

Class the member function calculating the Minimum and verifies the result depending on the strategy.

Parameters:
-----------

fMnFcn: 
the function to be minimized.

fGradienCalculator: 
not used in Fumili.

fMinimumSeed: 
the seed generator.

fMnStrategy: 
the strategy describing the number of function calls allowed for Gradient calculations.

maxfcn: 
maximum number of function calls after which the calculation will be stopped even if it has not yet converged.

edmval: 
expected vertical distance to the Minimum.

Returns the function Minimum found.
Todo
Complete the documentation by understanding what is the reason to have two Minimum methods.
";

%feature("docstring")  ROOT::Minuit2::FumiliBuilder::Minimum "FunctionMinimum ROOT::Minuit2::FumiliBuilder::Minimum(const MnFcn &fMnFcn, const GradientCalculator &fGradienCalculator, const MinimumSeed &fMinimumSeed, std::vector< MinimumState > &states, unsigned int maxfcn, double edmval) const

Calculates the Minimum based on the Fumili method

Parameters:
-----------

fMnFcn: 
the function to be minimized.

fGradienCalculator: 
not used in Fumili

fMinimumSeed: 
the seed generator.

states: 
vector containing the state result of each iteration

maxfcn: 
maximum number of function calls after which the calculation will be stopped even if it has not yet converged.

edmval: 
expected vertical distance to the Minimum

Returns the function Minimum found.

See: 
MINUIT Tutorial on function minimization, section 5
Todo
some nice Latex based formula here...
";

%feature("docstring")  ROOT::Minuit2::FumiliBuilder::Estimator "const VariableMetricEDMEstimator& ROOT::Minuit2::FumiliBuilder::Estimator() const

Accessor to the EDM (expected vertical distance to the Minimum) estimator.

The EDM estimator used in the builder.
Todo
Maybe a little explanation concerning EDM in all relevant classes.
";

%feature("docstring")  ROOT::Minuit2::FumiliBuilder::ErrorUpdator "const FumiliErrorUpdator& ROOT::Minuit2::FumiliBuilder::ErrorUpdator() const

Accessor to the Error updator of the builder.

The  FumiliErrorUpdator used by the  FumiliBuilder. 
";


// File: classROOT_1_1Minuit2_1_1FumiliChi2FCN.xml
%feature("docstring") ROOT::Minuit2::FumiliChi2FCN "

Extension of the  FCNBase for the Fumili method. Fumili applies only to minimization problems used for fitting. The method is based on a linearization of the model function negleting second derivatives. User needs to provide the model function. The figure-of-merit describing the difference between the model function and the actual measurements in the case of chi-square is the sum of the squares of the figures-of-merit calculated for each measurement point, which is implemented by the operator() member function. The user still has to implement the calculation of the individual figures-of-merit (which in the majority of the cases will be the (measured Value - the Value predicted by the model)/standard deviation implemeted by the  FumiliStandardChi2FCN; however this form can become more complicated (see for an example Numerical Recipes' section on \"Straight-Line Data with Errors in Both Coordinates\")).

Andras Zsenei and Lorenzo Moneta, Creation date: 24 Aug 2004

See: 
MINUIT Tutorial on function minimization, section 5

See: 
 FumiliStandardChi2FCN

C++ includes: FumiliChi2FCN.h
";

%feature("docstring")  ROOT::Minuit2::FumiliChi2FCN::FumiliChi2FCN "ROOT::Minuit2::FumiliChi2FCN::FumiliChi2FCN()
";

%feature("docstring")  ROOT::Minuit2::FumiliChi2FCN::~FumiliChi2FCN "virtual ROOT::Minuit2::FumiliChi2FCN::~FumiliChi2FCN()
";

%feature("docstring")  ROOT::Minuit2::FumiliChi2FCN::SetModelFunction "void ROOT::Minuit2::FumiliChi2FCN::SetModelFunction(const ParametricFunction &modelFCN)

Sets the model function for the data (for example gaussian+linear for a peak)

Parameters:
-----------

modelFunction: 
a reference to the model function. 
";

%feature("docstring")  ROOT::Minuit2::FumiliChi2FCN::ModelFunction "const ParametricFunction* ROOT::Minuit2::FumiliChi2FCN::ModelFunction() const

Returns the model function used for the data.

Returns a pointer to the model function. 
";

%feature("docstring")  ROOT::Minuit2::FumiliChi2FCN::Elements "virtual std::vector<double> ROOT::Minuit2::FumiliChi2FCN::Elements(const std::vector< double > &par) const =0

Evaluates the model function for the different measurement points and the Parameter values supplied, calculates a figure-of-merit for each measurement and returns a vector containing the result of this evaluation.

Parameters:
-----------

par: 
vector of Parameter values to feed to the model function.

A vector containing the figures-of-merit for the model function evaluated for each set of measurements. 
";

%feature("docstring")  ROOT::Minuit2::FumiliChi2FCN::GetMeasurement "virtual const std::vector<double>& ROOT::Minuit2::FumiliChi2FCN::GetMeasurement(int Index) const =0

Accessor to the parameters of a given measurement. For example in the case of a chi-square fit with a one-dimensional Gaussian, the Parameter characterizing the measurement will be the position. It is the Parameter that is feeded to the model function.

Parameters:
-----------

Index: 
Index of the measueremnt the parameters of which to return

A reference to a vector containing the values characterizing a measurement 
";

%feature("docstring")  ROOT::Minuit2::FumiliChi2FCN::GetNumberOfMeasurements "virtual int ROOT::Minuit2::FumiliChi2FCN::GetNumberOfMeasurements() const =0

Accessor to the number of measurements used for calculating the present figure of merit.

the number of measurements 
";

%feature("docstring")  ROOT::Minuit2::FumiliChi2FCN::Up "virtual double ROOT::Minuit2::FumiliChi2FCN::Up() const

!!!!!!!!!!!! to be commented 
";


// File: classROOT_1_1Minuit2_1_1FumiliErrorUpdator.xml
%feature("docstring") ROOT::Minuit2::FumiliErrorUpdator "

In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. (In some sense the Name Updator is a little bit misleading as the Error matrix is not calculated by iteratively updating, like in Davidon's or other similar variable metric methods, but by recalculating each time).

Andras Zsenei and Lorenzo Moneta, Creation date: 28 Sep 2004

See: 
MINUIT Tutorial on function minimization, section 5

See: 
 DavidonErrorUpdator

C++ includes: FumiliErrorUpdator.h
";

%feature("docstring")  ROOT::Minuit2::FumiliErrorUpdator::FumiliErrorUpdator "ROOT::Minuit2::FumiliErrorUpdator::FumiliErrorUpdator()
";

%feature("docstring")  ROOT::Minuit2::FumiliErrorUpdator::~FumiliErrorUpdator "ROOT::Minuit2::FumiliErrorUpdator::~FumiliErrorUpdator()
";

%feature("docstring")  ROOT::Minuit2::FumiliErrorUpdator::Update "virtual MinimumError ROOT::Minuit2::FumiliErrorUpdator::Update(const MinimumState &fMinimumState, const MinimumParameters &fMinimumParameters, const GradientCalculator &fGradientCalculator, double lambda) const

Member function that calculates the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) using a linearization of the model function negleting second derivatives.

Parameters:
-----------

fMinimumState: 
used to calculate the change in the covariance matrix between the two iterations

fMinimumParameters: 
the parameters at the present iteration

fGradientCalculator: 
the Gradient calculator used to retrieved the Parameter transformation

fFumiliFCNBase: 
the function calculating the figure of merit.

Todo
Some nice latex mathematical formuli...
";

%feature("docstring")  ROOT::Minuit2::FumiliErrorUpdator::Update "virtual MinimumError ROOT::Minuit2::FumiliErrorUpdator::Update(const MinimumState &, const MinimumParameters &, const FunctionGradient &) const

Member function which is only present due to the design already in place of the software. As all classes calculating the Error matrix are supposed inherit from the  MinimumErrorUpdator they must inherit this method. In some methods calculating the aforementioned matrix some of these parameters are not needed and other parameters are necessary... Hopefully, a more elegant solution will be found in the future.

Todo
How to get rid of this dummy method which is only due to the inheritance
";


// File: classROOT_1_1Minuit2_1_1FumiliFCNAdapter.xml
%feature("docstring") ROOT::Minuit2::FumiliFCNAdapter "

template wrapped class for adapting to  FumiliFCNBase signature

Lorenzo Moneta

C++ includes: FumiliFCNAdapter.h
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNAdapter::FumiliFCNAdapter "ROOT::Minuit2::FumiliFCNAdapter< Function >::FumiliFCNAdapter(const Function &f, unsigned int ndim, double up=1.)
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNAdapter::~FumiliFCNAdapter "ROOT::Minuit2::FumiliFCNAdapter< Function >::~FumiliFCNAdapter()
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNAdapter::Up "double ROOT::Minuit2::FumiliFCNAdapter< Function >::Up() const

Error definition of the function. MINUIT defines Parameter errors as the change in Parameter Value required to change the function Value by up. Normally, for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5. If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4, as Chi2(x+n*sigma) = Chi2(x) + n*n.

Todo
Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for  ErrorDef()
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNAdapter::SetErrorDef "void ROOT::Minuit2::FumiliFCNAdapter< Function >::SetErrorDef(double up)

add interface to set dynamically a new error definition Re-implement this function if needed. 
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNAdapter::EvaluateAll "void ROOT::Minuit2::FumiliFCNAdapter< Function >::EvaluateAll(const std::vector< double > &v)

evaluate gradient hessian and function value needed by fumili 
";


// File: classROOT_1_1Minuit2_1_1FumiliFCNBase.xml
%feature("docstring") ROOT::Minuit2::FumiliFCNBase "

Extension of the  FCNBase for the Fumili method. Fumili applies only to minimization problems used for fitting. The method is based on a linearization of the model function negleting second derivatives. User needs to provide the model function. The figure-of-merit describing the difference between the model function and the actual measurements has to be implemented by the user in a subclass of  FumiliFCNBase. For an example see the  FumiliChi2FCN and  FumiliStandardChi2FCN classes.

Andras Zsenei and Lorenzo Moneta, Creation date: 23 Aug 2004

See: 
MINUIT Tutorial on function minimization, section 5

See: 
 FumiliChi2FCN

See: 
 FumiliStandardChi2FCN

C++ includes: FumiliFCNBase.h
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNBase::FumiliFCNBase "ROOT::Minuit2::FumiliFCNBase::FumiliFCNBase()

Default Constructor. Need in this case to create when implementing EvaluateAll the Gradient and Hessian vectors with the right size 
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNBase::FumiliFCNBase "ROOT::Minuit2::FumiliFCNBase::FumiliFCNBase(unsigned int npar)

Constructor which initializes the class with the function provided by the user for modeling the data.

Parameters:
-----------

npar: 
the number of parameters 
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNBase::~FumiliFCNBase "virtual ROOT::Minuit2::FumiliFCNBase::~FumiliFCNBase()
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNBase::EvaluateAll "virtual void ROOT::Minuit2::FumiliFCNBase::EvaluateAll(const std::vector< double > &par)=0

Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p The resul is cached inside and is return from the  FumiliFCNBase::Value ,  FumiliFCNBase::Gradient and  FumiliFCNBase::Hessian methods

Parameters:
-----------

par: 
vector of parameters 
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNBase::Value "virtual double ROOT::Minuit2::FumiliFCNBase::Value() const

Return cached Value of objective function estimated previously using the  FumiliFCNBase::EvaluateAll method 
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNBase::Gradient "virtual const std::vector<double>& ROOT::Minuit2::FumiliFCNBase::Gradient() const

Return cached Value of function Gradient estimated previously using the  FumiliFCNBase::EvaluateAll method 
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNBase::Hessian "virtual double ROOT::Minuit2::FumiliFCNBase::Hessian(unsigned int row, unsigned int col) const

Return Value of the i-th j-th element of the Hessian matrix estimated previously using the  FumiliFCNBase::EvaluateAll method

Parameters:
-----------

row: 
row Index of the matrix

col: 
col Index of the matrix 
";

%feature("docstring")  ROOT::Minuit2::FumiliFCNBase::Dimension "virtual unsigned int ROOT::Minuit2::FumiliFCNBase::Dimension()

return number of function variable (parameters) , i.e. function dimension 
";


// File: classROOT_1_1Minuit2_1_1FumiliGradientCalculator.xml
%feature("docstring") ROOT::Minuit2::FumiliGradientCalculator "";

%feature("docstring")  ROOT::Minuit2::FumiliGradientCalculator::FumiliGradientCalculator "ROOT::Minuit2::FumiliGradientCalculator::FumiliGradientCalculator(const FumiliFCNBase &fcn, const MnUserTransformation &state, int n)
";

%feature("docstring")  ROOT::Minuit2::FumiliGradientCalculator::~FumiliGradientCalculator "ROOT::Minuit2::FumiliGradientCalculator::~FumiliGradientCalculator()
";

%feature("docstring")  ROOT::Minuit2::FumiliGradientCalculator::Trafo "const MnUserTransformation& ROOT::Minuit2::FumiliGradientCalculator::Trafo() const
";

%feature("docstring")  ROOT::Minuit2::FumiliGradientCalculator::Hessian "const MnAlgebraicSymMatrix& ROOT::Minuit2::FumiliGradientCalculator::Hessian() const
";


// File: classROOT_1_1Minuit2_1_1FumiliMaximumLikelihoodFCN.xml
%feature("docstring") ROOT::Minuit2::FumiliMaximumLikelihoodFCN "

Extension of the  FCNBase for the Fumili method. Fumili applies only to minimization problems used for fitting. The method is based on a linearization of the model function negleting second derivatives. User needs to provide the model function. In this cased the function to be minimized is the sum of the logarithms of the model function for the different measurements times -1.

Andras Zsenei and Lorenzo Moneta, Creation date: 3 Sep 2004

See: 
MINUIT Tutorial on function minimization, section 5

See: 
 FumiliStandardMaximumLikelihoodFCN
Todo
Insert a nice latex formula...

C++ includes: FumiliMaximumLikelihoodFCN.h
";

%feature("docstring")  ROOT::Minuit2::FumiliMaximumLikelihoodFCN::FumiliMaximumLikelihoodFCN "ROOT::Minuit2::FumiliMaximumLikelihoodFCN::FumiliMaximumLikelihoodFCN()
";

%feature("docstring")  ROOT::Minuit2::FumiliMaximumLikelihoodFCN::~FumiliMaximumLikelihoodFCN "virtual ROOT::Minuit2::FumiliMaximumLikelihoodFCN::~FumiliMaximumLikelihoodFCN()
";

%feature("docstring")  ROOT::Minuit2::FumiliMaximumLikelihoodFCN::SetModelFunction "void ROOT::Minuit2::FumiliMaximumLikelihoodFCN::SetModelFunction(const ParametricFunction &modelFCN)

Sets the model function for the data (for example gaussian+linear for a peak)

Parameters:
-----------

modelFunction: 
a reference to the model function. 
";

%feature("docstring")  ROOT::Minuit2::FumiliMaximumLikelihoodFCN::ModelFunction "const ParametricFunction* ROOT::Minuit2::FumiliMaximumLikelihoodFCN::ModelFunction() const

Returns the model function used for the data.

Returns a pointer to the model function. 
";

%feature("docstring")  ROOT::Minuit2::FumiliMaximumLikelihoodFCN::Elements "virtual std::vector<double> ROOT::Minuit2::FumiliMaximumLikelihoodFCN::Elements(const std::vector< double > &par) const =0

Evaluates the model function for the different measurement points and the Parameter values supplied, calculates a figure-of-merit for each measurement and returns a vector containing the result of this evaluation.

Parameters:
-----------

par: 
vector of Parameter values to feed to the model function.

A vector containing the figures-of-merit for the model function evaluated for each set of measurements. 
";

%feature("docstring")  ROOT::Minuit2::FumiliMaximumLikelihoodFCN::GetMeasurement "virtual const std::vector<double>& ROOT::Minuit2::FumiliMaximumLikelihoodFCN::GetMeasurement(int Index) const =0

Accessor to the parameters of a given measurement. For example in the case of a chi-square fit with a one-dimensional Gaussian, the Parameter characterizing the measurement will be the position. It is the Parameter that is feeded to the model function.

Parameters:
-----------

Index: 
Index of the measueremnt the parameters of which to return

A vector containing the values characterizing a measurement 
";

%feature("docstring")  ROOT::Minuit2::FumiliMaximumLikelihoodFCN::GetNumberOfMeasurements "virtual int ROOT::Minuit2::FumiliMaximumLikelihoodFCN::GetNumberOfMeasurements() const =0

Accessor to the number of measurements used for calculating the present figure of merit.

the number of measurements 
";

%feature("docstring")  ROOT::Minuit2::FumiliMaximumLikelihoodFCN::Up "virtual double ROOT::Minuit2::FumiliMaximumLikelihoodFCN::Up() const

!!!!!!!!!!!! to be commented 
";


// File: classROOT_1_1Minuit2_1_1FumiliMinimizer.xml
%feature("docstring") ROOT::Minuit2::FumiliMinimizer "

Instantiates the seed generator and Minimum builder for the Fumili minimization method. Produces the Minimum via the  Minimize methods inherited from  ModularFunctionMinimizer.

Andras Zsenei and Lorenzo Moneta, Creation date: 28 Sep 2004

C++ includes: FumiliMinimizer.h
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::FumiliMinimizer "ROOT::Minuit2::FumiliMinimizer::FumiliMinimizer()

Constructor initializing the  FumiliMinimizer by instantiatiating the SeedGenerator and  MinimumBuilder for the Fumili minimization method.

See: 
 MnSeedGenerator

See: 
 FumiliBuilder
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::~FumiliMinimizer "ROOT::Minuit2::FumiliMinimizer::~FumiliMinimizer()
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::SeedGenerator "const MinimumSeedGenerator& ROOT::Minuit2::FumiliMinimizer::SeedGenerator() const

Accessor to the seed generator of the minimizer.

A reference to the seed generator used by the minimizer 
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Builder "const FumiliBuilder& ROOT::Minuit2::FumiliMinimizer::Builder() const

Accessor to the Minimum builder of the minimizer.

a reference to the Minimum builder. 
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Builder "FumiliBuilder& ROOT::Minuit2::FumiliMinimizer::Builder()
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Minimize "FunctionMinimum ROOT::Minuit2::FumiliMinimizer::Minimize(const FCNBase &, const MnUserParameterState &, const MnStrategy &, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FumiliMinimizer::Minimize(const FCNGradientBase &, const MnUserParameterState &, const MnStrategy &, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FumiliMinimizer::Minimize(const FCNBase &fcn, const std::vector< double > &par, const std::vector< double > &err, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FumiliMinimizer::Minimize(const FCNGradientBase &fcn, const std::vector< double > &par, const std::vector< double > &err, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FumiliMinimizer::Minimize(const FCNBase &fcn, const std::vector< double > &par, unsigned int nrow, const std::vector< double > &cov, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FumiliMinimizer::Minimize(const FCNGradientBase &fcn, const std::vector< double > &par, unsigned int nrow, const std::vector< double > &cov, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FumiliMinimizer::Minimize(const FCNBase &fcn, const MnUserParameters &par, const MnStrategy &stra, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FumiliMinimizer::Minimize(const FCNGradientBase &fcn, const MnUserParameters &par, const MnStrategy &stra, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FumiliMinimizer::Minimize(const FCNBase &fcn, const MnUserParameters &par, const MnUserCovariance &cov, const MnStrategy &stra, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FumiliMinimizer::Minimize(const FCNGradientBase &fcn, const MnUserParameters &par, const MnUserCovariance &cov, const MnStrategy &stra, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::FumiliMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FumiliMinimizer::Minimize(const MnFcn &mfcn, const GradientCalculator &gc, const MinimumSeed &seed, const MnStrategy &stra, unsigned int maxfcn, double toler) const
";


// File: classROOT_1_1Minuit2_1_1FumiliStandardChi2FCN.xml
%feature("docstring") ROOT::Minuit2::FumiliStandardChi2FCN "

Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation.

Andras Zsenei and Lorenzo Moneta, Creation date: 31 Aug 2004

See: 
 FumiliChi2FCN
Todo
nice formula for the documentation...

C++ includes: FumiliStandardChi2FCN.h
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardChi2FCN::FumiliStandardChi2FCN "ROOT::Minuit2::FumiliStandardChi2FCN::FumiliStandardChi2FCN(const ParametricFunction &modelFCN, const std::vector< double > &meas, const std::vector< double > &pos, const std::vector< double > &mvar)

Constructor which initializes chi square function for one-dimensional model function

Parameters:
-----------

modelFCN: 
the model function used for describing the data.

meas: 
vector containing the measured values.

pos: 
vector containing the x values corresponding to the measurements

mvar: 
vector containing the variances corresponding to each measurement (where the variance equals the standard deviation squared). If the variances are zero, a Value of 1 is used (as it is done in ROOT/PAW) 
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardChi2FCN::FumiliStandardChi2FCN "ROOT::Minuit2::FumiliStandardChi2FCN::FumiliStandardChi2FCN(const ParametricFunction &modelFCN, const std::vector< double > &meas, const std::vector< std::vector< double > > &pos, const std::vector< double > &mvar)

Constructor which initializes the multi-dimensional model function.

Parameters:
-----------

modelFCN: 
the model function used for describing the data.

meas: 
vector containing the measured values.

pos: 
vector containing the x values corresponding to the measurements

mvar: 
vector containing the variances corresponding to each measurement (where the variance equals the standard deviation squared). If the variances are zero, a Value of 1 is used (as it is done in ROOT/PAW) 
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardChi2FCN::~FumiliStandardChi2FCN "ROOT::Minuit2::FumiliStandardChi2FCN::~FumiliStandardChi2FCN()
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardChi2FCN::Elements "std::vector<double> ROOT::Minuit2::FumiliStandardChi2FCN::Elements(const std::vector< double > &par) const

Evaluates the model function for the different measurement points and the Parameter values supplied, calculates a figure-of-merit for each measurement and returns a vector containing the result of this evaluation. The figure-of-merit is (Value predicted by the model function-measured Value)/standard deviation.

Parameters:
-----------

par: 
vector of Parameter values to feed to the model function.

A vector containing the figures-of-merit for the model function evaluated for each set of measurements.
Todo
What to do when the variances are 0???!! (right now just pushes back 0...)
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardChi2FCN::GetMeasurement "virtual const std::vector<double>& ROOT::Minuit2::FumiliStandardChi2FCN::GetMeasurement(int Index) const

Accessor to the position of the measurement (x coordinate).

Parameters:
-----------

Index: 
Index of the measuerement the position of which to return.

the position of the measurement. 
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardChi2FCN::GetNumberOfMeasurements "virtual int ROOT::Minuit2::FumiliStandardChi2FCN::GetNumberOfMeasurements() const

Accessor to the number of measurements used for calculating the chi-square.

the number of measurements. 
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardChi2FCN::EvaluateAll "virtual void ROOT::Minuit2::FumiliStandardChi2FCN::EvaluateAll(const std::vector< double > &par)

Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p The resul is cached inside and is return from the  FumiliFCNBase::Value ,  FumiliFCNBase::Gradient and  FumiliFCNBase::Hessian methods

Parameters:
-----------

par: 
vector of parameters 
";


// File: classROOT_1_1Minuit2_1_1FumiliStandardMaximumLikelihoodFCN.xml
%feature("docstring") ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN "

Class implementing the Elements member function for the standard maximum likelihood method.

Andras Zsenei and Lorenzo Moneta, Creation date: 4 Sep 2004

See: 
 FumiliMaximumLikelihoodFCN

C++ includes: FumiliStandardMaximumLikelihoodFCN.h
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::FumiliStandardMaximumLikelihoodFCN "ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::FumiliStandardMaximumLikelihoodFCN(const ParametricFunction &modelFCN, const std::vector< double > &pos)

Constructor which initializes the measurement points for the one dimensional model function.

Parameters:
-----------

modelFCN: 
the model function used for describing the data.

pos: 
vector containing the x values corresponding to the measurements 
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::FumiliStandardMaximumLikelihoodFCN "ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::FumiliStandardMaximumLikelihoodFCN(const ParametricFunction &modelFCN, const std::vector< std::vector< double > > &pos)

Constructor which initializes the measurement points for the multi dimensional model function.

Parameters:
-----------

modelFCN: 
the model function used for describing the data.

pos: 
vector containing the x values corresponding to the measurements 
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::~FumiliStandardMaximumLikelihoodFCN "ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::~FumiliStandardMaximumLikelihoodFCN()
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::Elements "std::vector<double> ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::Elements(const std::vector< double > &par) const

Evaluates the model function for the different measurement points and the Parameter values supplied.

Parameters:
-----------

par: 
vector of Parameter values to feed to the model function.

A vector containing the model function evaluated for each measurement point. 
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::GetMeasurement "virtual const std::vector<double>& ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::GetMeasurement(int Index) const

Accessor to the position of the measurement (x coordinate).

Parameters:
-----------

Index: 
Index of the measuerement the position of which to return.

the position of the measurement. 
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::GetNumberOfMeasurements "virtual int ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::GetNumberOfMeasurements() const

Accessor to the number of measurements used for calculating the maximum likelihood.

the number of measurements. 
";

%feature("docstring")  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::EvaluateAll "virtual void ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN::EvaluateAll(const std::vector< double > &par)

Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p The resul is cached inside and is return from the  FumiliFCNBase::Value ,  FumiliFCNBase::Gradient and  FumiliFCNBase::Hessian methods

Parameters:
-----------

par: 
vector of parameters 
";


// File: classROOT_1_1Minuit2_1_1FunctionGradient.xml
%feature("docstring") ROOT::Minuit2::FunctionGradient "";

%feature("docstring")  ROOT::Minuit2::FunctionGradient::FunctionGradient "ROOT::Minuit2::FunctionGradient::FunctionGradient(unsigned int n)
";

%feature("docstring")  ROOT::Minuit2::FunctionGradient::FunctionGradient "ROOT::Minuit2::FunctionGradient::FunctionGradient(const MnAlgebraicVector &grd)
";

%feature("docstring")  ROOT::Minuit2::FunctionGradient::FunctionGradient "ROOT::Minuit2::FunctionGradient::FunctionGradient(const MnAlgebraicVector &grd, const MnAlgebraicVector &g2, const MnAlgebraicVector &gstep)
";

%feature("docstring")  ROOT::Minuit2::FunctionGradient::~FunctionGradient "ROOT::Minuit2::FunctionGradient::~FunctionGradient()
";

%feature("docstring")  ROOT::Minuit2::FunctionGradient::FunctionGradient "ROOT::Minuit2::FunctionGradient::FunctionGradient(const FunctionGradient &grad)
";

%feature("docstring")  ROOT::Minuit2::FunctionGradient::Grad "const MnAlgebraicVector& ROOT::Minuit2::FunctionGradient::Grad() const
";

%feature("docstring")  ROOT::Minuit2::FunctionGradient::Vec "const MnAlgebraicVector& ROOT::Minuit2::FunctionGradient::Vec() const
";

%feature("docstring")  ROOT::Minuit2::FunctionGradient::IsValid "bool ROOT::Minuit2::FunctionGradient::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::FunctionGradient::IsAnalytical "bool ROOT::Minuit2::FunctionGradient::IsAnalytical() const
";

%feature("docstring")  ROOT::Minuit2::FunctionGradient::G2 "const MnAlgebraicVector& ROOT::Minuit2::FunctionGradient::G2() const
";

%feature("docstring")  ROOT::Minuit2::FunctionGradient::Gstep "const MnAlgebraicVector& ROOT::Minuit2::FunctionGradient::Gstep() const
";


// File: classROOT_1_1Minuit2_1_1FunctionMinimizer.xml
%feature("docstring") ROOT::Minuit2::FunctionMinimizer "

base class for function minimizers; user may give FCN or FCN with Gradient, Parameter starting values and initial Error guess (sigma) (or \"step size\"), or Parameter starting values and initial covariance matrix; covariance matrix is stored in Upper triangular packed storage format, e.g. the Elements in the array are arranged like {a(0,0), a(0,1), a(1,1), a(0,2), a(1,2), a(2,2), ...}, the size is nrow*(nrow+1)/2 (see also  MnUserCovariance.h);

C++ includes: FunctionMinimizer.h
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimizer::~FunctionMinimizer "virtual ROOT::Minuit2::FunctionMinimizer::~FunctionMinimizer()
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FunctionMinimizer::Minimize(const FCNBase &, const std::vector< double > &par, const std::vector< double > &err, unsigned int strategy, unsigned int maxfcn, double toler) const =0
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FunctionMinimizer::Minimize(const FCNGradientBase &, const std::vector< double > &par, const std::vector< double > &err, unsigned int strategy, unsigned int maxfcn, double toler) const =0
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FunctionMinimizer::Minimize(const FCNBase &, const std::vector< double > &par, unsigned int nrow, const std::vector< double > &cov, unsigned int strategy, unsigned int maxfcn, double toler) const =0
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::FunctionMinimizer::Minimize(const FCNGradientBase &, const std::vector< double > &par, unsigned int nrow, const std::vector< double > &cov, unsigned int strategy, unsigned int maxfcn, double toler) const =0
";


// File: classROOT_1_1Minuit2_1_1FunctionMinimum.xml
%feature("docstring") ROOT::Minuit2::FunctionMinimum "

class holding the full result of the minimization; both internal and external ( MnUserParameterState) representation available for the parameters at the Minimum

C++ includes: FunctionMinimum.h
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::FunctionMinimum "ROOT::Minuit2::FunctionMinimum::FunctionMinimum(const MinimumSeed &seed, double up)

constructor from only  MinimumSeed. Minimum is only from seed result not full minimization 
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::FunctionMinimum "ROOT::Minuit2::FunctionMinimum::FunctionMinimum(const MinimumSeed &seed, const std::vector< MinimumState > &states, double up)

constructor at the end of a successfull minimization from seed and vector of states 
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::FunctionMinimum "ROOT::Minuit2::FunctionMinimum::FunctionMinimum(const MinimumSeed &seed, const std::vector< MinimumState > &states, double up, MnReachedCallLimit)

constructor at the end of a failed minimization due to exceeding function call limit 
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::FunctionMinimum "ROOT::Minuit2::FunctionMinimum::FunctionMinimum(const MinimumSeed &seed, const std::vector< MinimumState > &states, double up, MnAboveMaxEdm)

constructor at the end of a failed minimization due to edm above maximum value 
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::FunctionMinimum "ROOT::Minuit2::FunctionMinimum::FunctionMinimum(const FunctionMinimum &min)

copy constructo 
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::~FunctionMinimum "ROOT::Minuit2::FunctionMinimum::~FunctionMinimum()
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::Add "void ROOT::Minuit2::FunctionMinimum::Add(const MinimumState &state)
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::Add "void ROOT::Minuit2::FunctionMinimum::Add(const MinimumState &state, MnAboveMaxEdm)
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::Seed "const MinimumSeed& ROOT::Minuit2::FunctionMinimum::Seed() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::States "const std::vector<ROOT::Minuit2::MinimumState>& ROOT::Minuit2::FunctionMinimum::States() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::UserState "const MnUserParameterState& ROOT::Minuit2::FunctionMinimum::UserState() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::UserParameters "const MnUserParameters& ROOT::Minuit2::FunctionMinimum::UserParameters() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::UserCovariance "const MnUserCovariance& ROOT::Minuit2::FunctionMinimum::UserCovariance() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::State "const MinimumState& ROOT::Minuit2::FunctionMinimum::State() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::Parameters "const MinimumParameters& ROOT::Minuit2::FunctionMinimum::Parameters() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::Error "const MinimumError& ROOT::Minuit2::FunctionMinimum::Error() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::Grad "const FunctionGradient& ROOT::Minuit2::FunctionMinimum::Grad() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::Fval "double ROOT::Minuit2::FunctionMinimum::Fval() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::Edm "double ROOT::Minuit2::FunctionMinimum::Edm() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::NFcn "int ROOT::Minuit2::FunctionMinimum::NFcn() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::Up "double ROOT::Minuit2::FunctionMinimum::Up() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::IsValid "bool ROOT::Minuit2::FunctionMinimum::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::HasValidParameters "bool ROOT::Minuit2::FunctionMinimum::HasValidParameters() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::HasValidCovariance "bool ROOT::Minuit2::FunctionMinimum::HasValidCovariance() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::HasAccurateCovar "bool ROOT::Minuit2::FunctionMinimum::HasAccurateCovar() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::HasPosDefCovar "bool ROOT::Minuit2::FunctionMinimum::HasPosDefCovar() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::HasMadePosDefCovar "bool ROOT::Minuit2::FunctionMinimum::HasMadePosDefCovar() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::HesseFailed "bool ROOT::Minuit2::FunctionMinimum::HesseFailed() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::HasCovariance "bool ROOT::Minuit2::FunctionMinimum::HasCovariance() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::IsAboveMaxEdm "bool ROOT::Minuit2::FunctionMinimum::IsAboveMaxEdm() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::HasReachedCallLimit "bool ROOT::Minuit2::FunctionMinimum::HasReachedCallLimit() const
";

%feature("docstring")  ROOT::Minuit2::FunctionMinimum::SetErrorDef "void ROOT::Minuit2::FunctionMinimum::SetErrorDef(double up)
";


// File: classROOT_1_1Math_1_1Functor.xml
%feature("docstring") ROOT::Math::Functor "

Documentation for class  Functor class. It is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types: 
any C++ callable object implemention double operator()( const double *  )

a free C function of type double ()(const double * )

a member function with the correct signature like Foo::Eval(const double * ). In this case one pass the object pointer and a pointer to the member function (&Foo::Eval)

The function dimension is required when constructing the functor.

C++ includes: Functor.h
";

%feature("docstring")  ROOT::Math::Functor::Functor "ROOT::Math::Functor::Functor()

Default constructor 
";

%feature("docstring")  ROOT::Math::Functor::Functor "ROOT::Math::Functor::Functor(const PtrObj &p, MemFn memFn, unsigned int dim)

construct from a pointer to member function (multi-dim type) 
";

%feature("docstring")  ROOT::Math::Functor::Functor "ROOT::Math::Functor::Functor(const Func &f, unsigned int dim)

construct from a callable object of multi-dimension with the right signature (implementing operator()(double *x) 
";

%feature("docstring")  ROOT::Math::Functor::~Functor "virtual ROOT::Math::Functor::~Functor()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::Functor::Functor "ROOT::Math::Functor::Functor(const Functor &rhs)

Copy constructor for functor based on ROOT::Math::IMultiGenFunction 
";

%feature("docstring")  ROOT::Math::Functor::Clone "ImplBase* ROOT::Math::Functor::Clone() const
";

%feature("docstring")  ROOT::Math::Functor::NDim "unsigned int ROOT::Math::Functor::NDim() const
";


// File: classROOT_1_1Math_1_1Functor1D.xml
%feature("docstring") ROOT::Math::Functor1D "

Functor1D class for one-dimensional functions. It is used to wrap in a very simple and convenient way: 
any C++ callable object implemention double operator()( double  )

a free C function of type double ()(double )

a member function with the correct signature like Foo::Eval(double ). In this case one pass the object pointer and a pointer to the member function (&Foo::Eval)

C++ includes: Functor.h
";

%feature("docstring")  ROOT::Math::Functor1D::Functor1D "ROOT::Math::Functor1D::Functor1D()

Default constructor 
";

%feature("docstring")  ROOT::Math::Functor1D::Functor1D "ROOT::Math::Functor1D::Functor1D(const Func &f)

construct from a callable object with the right signature implementing operator() (double x) 
";

%feature("docstring")  ROOT::Math::Functor1D::Functor1D "ROOT::Math::Functor1D::Functor1D(const PtrObj &p, MemFn memFn)

construct from a pointer to member function (1D type) 
";

%feature("docstring")  ROOT::Math::Functor1D::~Functor1D "virtual ROOT::Math::Functor1D::~Functor1D()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::Functor1D::Functor1D "ROOT::Math::Functor1D::Functor1D(const Functor1D &rhs)

Copy constructor for  Functor based on ROOT::Math::IGenFunction 
";

%feature("docstring")  ROOT::Math::Functor1D::Clone "ImplBase* ROOT::Math::Functor1D::Clone() const

Clone a function. Each derived class will implement their version of the provate DoClone method 
";


// File: classROOT_1_1Math_1_1FunctorGradHandler.xml
%feature("docstring") ROOT::Math::FunctorGradHandler "

Functor Handler class for gradient functions where both callable objects are provided for the function evaluation (type Func) and for the gradient (type GradFunc) . It can be created from any function implementing the correct signature corresponding to the requested type In the case of one dimension the function evaluation object and the derivative function object must implement double operator() (double x). In the case of multi-dimension the function evaluation object must implement double operator() (const double * x) and the gradient function object must implement double operator() (const double * x, int icoord)

C++ includes: Functor.h
";

%feature("docstring")  ROOT::Math::FunctorGradHandler::FunctorGradHandler "ROOT::Math::FunctorGradHandler< ParentFunctor, Func, GradFunc >::FunctorGradHandler(const Func &fun, const GradFunc &gfun)
";

%feature("docstring")  ROOT::Math::FunctorGradHandler::FunctorGradHandler "ROOT::Math::FunctorGradHandler< ParentFunctor, Func, GradFunc >::FunctorGradHandler(unsigned int dim, const Func &fun, const GradFunc &gfun)
";

%feature("docstring")  ROOT::Math::FunctorGradHandler::~FunctorGradHandler "virtual ROOT::Math::FunctorGradHandler< ParentFunctor, Func, GradFunc >::~FunctorGradHandler()
";

%feature("docstring")  ROOT::Math::FunctorGradHandler::Copy "ImplFunc* ROOT::Math::FunctorGradHandler< ParentFunctor, Func, GradFunc >::Copy() const
";

%feature("docstring")  ROOT::Math::FunctorGradHandler::Clone "BaseFunc* ROOT::Math::FunctorGradHandler< ParentFunctor, Func, GradFunc >::Clone() const
";

%feature("docstring")  ROOT::Math::FunctorGradHandler::NDim "unsigned int ROOT::Math::FunctorGradHandler< ParentFunctor, Func, GradFunc >::NDim() const
";


// File: classROOT_1_1Math_1_1FunctorHandler.xml
%feature("docstring") ROOT::Math::FunctorHandler "

Functor Handler class is responsible for wrapping any other functor and pointer to free C functions. It can be created from any function implementing the correct signature corresponding to the requested type In the case of one dimension the function evaluation object must implement double operator() (double x). If it implements a method: double Derivative(double x) can be used to create a Gradient function type.

In the case of multi-dimension the function evaluation object must implement double operator()(const double *x). If it implements a method: double Derivative(const double *x, int icoord) can be used to create a Gradient function type.

C++ includes: Functor.h
";

%feature("docstring")  ROOT::Math::FunctorHandler::FunctorHandler "ROOT::Math::FunctorHandler< ParentFunctor, Func >::FunctorHandler(const Func &fun)
";

%feature("docstring")  ROOT::Math::FunctorHandler::FunctorHandler "ROOT::Math::FunctorHandler< ParentFunctor, Func >::FunctorHandler(unsigned int dim, const Func &fun)
";

%feature("docstring")  ROOT::Math::FunctorHandler::~FunctorHandler "virtual ROOT::Math::FunctorHandler< ParentFunctor, Func >::~FunctorHandler()
";

%feature("docstring")  ROOT::Math::FunctorHandler::Copy "ImplFunc* ROOT::Math::FunctorHandler< ParentFunctor, Func >::Copy() const
";

%feature("docstring")  ROOT::Math::FunctorHandler::Clone "BaseFunc* ROOT::Math::FunctorHandler< ParentFunctor, Func >::Clone() const
";

%feature("docstring")  ROOT::Math::FunctorHandler::NDim "unsigned int ROOT::Math::FunctorHandler< ParentFunctor, Func >::NDim() const
";


// File: classROOT_1_1Math_1_1FunctorImpl.xml
%feature("docstring") ROOT::Math::FunctorImpl "

FunctorImpl is a base class for the functor handler implementation class. It defines the Copy operator used to clone the functor objects

C++ includes: Functor.h
";

%feature("docstring")  ROOT::Math::FunctorImpl::FunctorImpl "ROOT::Math::FunctorImpl< IBaseFunc >::FunctorImpl()
";

%feature("docstring")  ROOT::Math::FunctorImpl::~FunctorImpl "virtual ROOT::Math::FunctorImpl< IBaseFunc >::~FunctorImpl()
";

%feature("docstring")  ROOT::Math::FunctorImpl::Copy "virtual FunctorImpl* ROOT::Math::FunctorImpl< IBaseFunc >::Copy() const =0
";


// File: classROOT_1_1Minuit2_1_1gen.xml
%feature("docstring") ROOT::Minuit2::gen "";


// File: classROOT_1_1Math_1_1GenAlgoOptions.xml
%feature("docstring") ROOT::Math::GenAlgoOptions "

class implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs

C++ includes: GenAlgoOptions.h
";

%feature("docstring")  ROOT::Math::GenAlgoOptions::GenAlgoOptions "ROOT::Math::GenAlgoOptions::GenAlgoOptions()
";

%feature("docstring")  ROOT::Math::GenAlgoOptions::~GenAlgoOptions "virtual ROOT::Math::GenAlgoOptions::~GenAlgoOptions()
";

%feature("docstring")  ROOT::Math::GenAlgoOptions::Clone "virtual IOptions* ROOT::Math::GenAlgoOptions::Clone() const

generic methods for retrivieng options 
";

%feature("docstring")  ROOT::Math::GenAlgoOptions::GetRealValue "virtual bool ROOT::Math::GenAlgoOptions::GetRealValue(const char *name, double &val) const
";

%feature("docstring")  ROOT::Math::GenAlgoOptions::GetIntValue "virtual bool ROOT::Math::GenAlgoOptions::GetIntValue(const char *name, int &val) const
";

%feature("docstring")  ROOT::Math::GenAlgoOptions::GetNamedValue "virtual bool ROOT::Math::GenAlgoOptions::GetNamedValue(const char *name, std::string &val) const
";

%feature("docstring")  ROOT::Math::GenAlgoOptions::SetRealValue "virtual void ROOT::Math::GenAlgoOptions::SetRealValue(const char *name, double val)

method wich need to be re-implemented by the derived classes 
";

%feature("docstring")  ROOT::Math::GenAlgoOptions::SetIntValue "virtual void ROOT::Math::GenAlgoOptions::SetIntValue(const char *name, int val)
";

%feature("docstring")  ROOT::Math::GenAlgoOptions::SetNamedValue "virtual void ROOT::Math::GenAlgoOptions::SetNamedValue(const char *name, const char *val)
";

%feature("docstring")  ROOT::Math::GenAlgoOptions::Print "virtual void ROOT::Math::GenAlgoOptions::Print(std::ostream &os=std::cout) const

print options 
";


// File: classROOT_1_1Minuit2_1_1GenericFunction.xml
%feature("docstring") ROOT::Minuit2::GenericFunction "

Class from which all the other classes, representing functions, inherit. That is why it defines only one method, the operator(), which allows to call the function.

Andras Zsenei and Lorenzo Moneta, Creation date: 23 Sep 2004

C++ includes: GenericFunction.h
";

%feature("docstring")  ROOT::Minuit2::GenericFunction::~GenericFunction "virtual ROOT::Minuit2::GenericFunction::~GenericFunction()
";


// File: classTMVA_1_1GeneticAlgorithm.xml
%feature("docstring") TMVA::GeneticAlgorithm "";

%feature("docstring")  TMVA::GeneticAlgorithm::GeneticAlgorithm "TMVA::GeneticAlgorithm::GeneticAlgorithm(IFitterTarget &target, Int_t populationSize, const std::vector< TMVA::Interval * > &ranges, UInt_t seed=0)
";

%feature("docstring")  TMVA::GeneticAlgorithm::~GeneticAlgorithm "virtual TMVA::GeneticAlgorithm::~GeneticAlgorithm()
";

%feature("docstring")  TMVA::GeneticAlgorithm::Init "void TMVA::GeneticAlgorithm::Init()
";

%feature("docstring")  TMVA::GeneticAlgorithm::HasConverged "virtual Bool_t TMVA::GeneticAlgorithm::HasConverged(Int_t steps=10, Double_t ratio=0.1)
";

%feature("docstring")  TMVA::GeneticAlgorithm::SpreadControl "virtual Double_t TMVA::GeneticAlgorithm::SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor)
";

%feature("docstring")  TMVA::GeneticAlgorithm::NewFitness "virtual Double_t TMVA::GeneticAlgorithm::NewFitness(Double_t oldValue, Double_t newValue)
";

%feature("docstring")  TMVA::GeneticAlgorithm::CalculateFitness "virtual Double_t TMVA::GeneticAlgorithm::CalculateFitness()
";

%feature("docstring")  TMVA::GeneticAlgorithm::Evolution "virtual void TMVA::GeneticAlgorithm::Evolution()
";

%feature("docstring")  TMVA::GeneticAlgorithm::GetGeneticPopulation "GeneticPopulation& TMVA::GeneticAlgorithm::GetGeneticPopulation()
";

%feature("docstring")  TMVA::GeneticAlgorithm::GetSpread "Double_t TMVA::GeneticAlgorithm::GetSpread() const
";

%feature("docstring")  TMVA::GeneticAlgorithm::SetSpread "void TMVA::GeneticAlgorithm::SetSpread(Double_t s)
";

%feature("docstring")  TMVA::GeneticAlgorithm::SetMakeCopies "void TMVA::GeneticAlgorithm::SetMakeCopies(Bool_t s)
";

%feature("docstring")  TMVA::GeneticAlgorithm::GetMakeCopies "Bool_t TMVA::GeneticAlgorithm::GetMakeCopies()
";


// File: classTMVA_1_1GeneticGenes.xml
%feature("docstring") TMVA::GeneticGenes "";

%feature("docstring")  TMVA::GeneticGenes::GeneticGenes "TMVA::GeneticGenes::GeneticGenes()
";

%feature("docstring")  TMVA::GeneticGenes::GeneticGenes "TMVA::GeneticGenes::GeneticGenes(std::vector< Double_t > &f)
";

%feature("docstring")  TMVA::GeneticGenes::~GeneticGenes "virtual TMVA::GeneticGenes::~GeneticGenes()
";

%feature("docstring")  TMVA::GeneticGenes::GetFactors "std::vector<Double_t>& TMVA::GeneticGenes::GetFactors()
";

%feature("docstring")  TMVA::GeneticGenes::SetFitness "void TMVA::GeneticGenes::SetFitness(Double_t fitness)
";

%feature("docstring")  TMVA::GeneticGenes::GetFitness "Double_t TMVA::GeneticGenes::GetFitness() const
";


// File: classROOT_1_1Math_1_1GeneticMinimizer.xml
%feature("docstring") ROOT::Math::GeneticMinimizer "

GeneticMinimizer

Minimizer class based on the Gentic algorithm implemented in TMVA

C++ includes: GeneticMinimizer.h
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::GeneticMinimizer "ROOT::Math::GeneticMinimizer::GeneticMinimizer(int i=0)
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::~GeneticMinimizer "virtual ROOT::Math::GeneticMinimizer::~GeneticMinimizer()
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::Clear "virtual void ROOT::Math::GeneticMinimizer::Clear()

reset for consecutive minimizations - implement if needed 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::SetFunction "virtual void ROOT::Math::GeneticMinimizer::SetFunction(const ROOT::Math::IMultiGenFunction &func)

set the function to minimize 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::SetLimitedVariable "virtual bool ROOT::Math::GeneticMinimizer::SetLimitedVariable(unsigned int, const std::string &, double, double, double, double)

set a new upper/lower limited variable (override if minimizer supports them ) otherwise as default set an unlimited variable 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::SetVariable "virtual bool ROOT::Math::GeneticMinimizer::SetVariable(unsigned int ivar, const std::string &name, double val, double step)

set a new free variable 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::SetFixedVariable "virtual bool ROOT::Math::GeneticMinimizer::SetFixedVariable(unsigned int ivar, const std::string &name, double val)

set a new fixed variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::Minimize "virtual bool ROOT::Math::GeneticMinimizer::Minimize()

method to perform the minimization 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::MinValue "virtual double ROOT::Math::GeneticMinimizer::MinValue() const

return minimum function value 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::Edm "virtual double ROOT::Math::GeneticMinimizer::Edm() const

return expected distance reached from the minimum (re-implement if minimizer provides it 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::X "virtual const double* ROOT::Math::GeneticMinimizer::X() const

return pointer to X values at the minimum 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::MinGradient "virtual const double* ROOT::Math::GeneticMinimizer::MinGradient() const

return pointer to gradient values at the minimum 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::NCalls "virtual unsigned int ROOT::Math::GeneticMinimizer::NCalls() const

number of function calls to reach the minimum 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::NDim "virtual unsigned int ROOT::Math::GeneticMinimizer::NDim() const

this is <= Function(). NDim() which is the total number of variables (free+ constrained ones) 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::NFree "virtual unsigned int ROOT::Math::GeneticMinimizer::NFree() const

number of free variables (real dimension of the problem) this is <= Function(). NDim() which is the total (re-implement if minimizer supports bounded parameters) 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::ProvidesError "virtual bool ROOT::Math::GeneticMinimizer::ProvidesError() const

minimizer provides error and error matrix 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::Errors "virtual const double* ROOT::Math::GeneticMinimizer::Errors() const

return errors at the minimum 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::CovMatrix "virtual double ROOT::Math::GeneticMinimizer::CovMatrix(unsigned int i, unsigned int j) const

return covariance matrices element for variables ivar,jvar if the variable is fixed the return value is zero The ordering of the variables is the same as in the parameter and errors vectors 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::SetParameters "void ROOT::Math::GeneticMinimizer::SetParameters(const GeneticMinimizerParameters &params)
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::SetRandomSeed "void ROOT::Math::GeneticMinimizer::SetRandomSeed(int seed)
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::MinimizerParameters "const GeneticMinimizerParameters& ROOT::Math::GeneticMinimizer::MinimizerParameters() const
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::Options "virtual ROOT::Math::MinimizerOptions ROOT::Math::GeneticMinimizer::Options() const

retrieve the minimizer options (implement derived class if needed) 
";

%feature("docstring")  ROOT::Math::GeneticMinimizer::SetOptions "virtual void ROOT::Math::GeneticMinimizer::SetOptions(const ROOT::Math::MinimizerOptions &opt)
";


// File: classGeneticMinimizer.xml
%feature("docstring") GeneticMinimizer "

Wrapper for the CERN  ROOT Genetic minimizer.

C++ includes: GeneticMinimizer.h
";

%feature("docstring")  GeneticMinimizer::GeneticMinimizer "GeneticMinimizer::GeneticMinimizer()
";

%feature("docstring")  GeneticMinimizer::~GeneticMinimizer "GeneticMinimizer::~GeneticMinimizer()
";

%feature("docstring")  GeneticMinimizer::setTolerance "void GeneticMinimizer::setTolerance(double value)

Sets tolerance on the function value at the minimum. Minimization will stop when the estimated vertical distance to the minimum (EDM) is less than 0.001*tolerance*ErrorDef. Here ErrorDef=1.0 for chi squared fit and ErrorDef=0.5 for negative log likelihood fit. 
";

%feature("docstring")  GeneticMinimizer::tolerance "double GeneticMinimizer::tolerance() const
";

%feature("docstring")  GeneticMinimizer::setPrintLevel "void GeneticMinimizer::setPrintLevel(int value)

Sets minimizer internal print level. 
";

%feature("docstring")  GeneticMinimizer::printLevel "int GeneticMinimizer::printLevel() const
";

%feature("docstring")  GeneticMinimizer::setMaxIterations "void GeneticMinimizer::setMaxIterations(int value)

Sets maximum number of iterations to try at each step. 
";

%feature("docstring")  GeneticMinimizer::maxIterations "int GeneticMinimizer::maxIterations() const
";

%feature("docstring")  GeneticMinimizer::setPopulationSize "void GeneticMinimizer::setPopulationSize(int value)

Sets population size. 
";

%feature("docstring")  GeneticMinimizer::populationSize "int GeneticMinimizer::populationSize() const
";

%feature("docstring")  GeneticMinimizer::setRandomSeed "void GeneticMinimizer::setRandomSeed(int value)

Sets random seed. 
";

%feature("docstring")  GeneticMinimizer::randomSeed "int GeneticMinimizer::randomSeed() const
";

%feature("docstring")  GeneticMinimizer::statusToString "std::string GeneticMinimizer::statusToString() const override

Returns string representation of current minimizer status. 
";

%feature("docstring")  GeneticMinimizer::statusMap "std::map< std::string, std::string > GeneticMinimizer::statusMap() const override

Returns map of string representing different minimizer statuses. 
";


// File: structROOT_1_1Math_1_1GeneticMinimizerParameters.xml
%feature("docstring") ROOT::Math::GeneticMinimizerParameters "";

%feature("docstring")  ROOT::Math::GeneticMinimizerParameters::GeneticMinimizerParameters "ROOT::Math::GeneticMinimizerParameters::GeneticMinimizerParameters()
";


// File: classTMVA_1_1GeneticPopulation.xml
%feature("docstring") TMVA::GeneticPopulation "";

%feature("docstring")  TMVA::GeneticPopulation::GeneticPopulation "TMVA::GeneticPopulation::GeneticPopulation(const std::vector< TMVA::Interval * > &ranges, Int_t size, UInt_t seed=0)
";

%feature("docstring")  TMVA::GeneticPopulation::~GeneticPopulation "virtual TMVA::GeneticPopulation::~GeneticPopulation()
";

%feature("docstring")  TMVA::GeneticPopulation::SetRandomSeed "void TMVA::GeneticPopulation::SetRandomSeed(UInt_t seed=0)
";

%feature("docstring")  TMVA::GeneticPopulation::MakeChildren "void TMVA::GeneticPopulation::MakeChildren()
";

%feature("docstring")  TMVA::GeneticPopulation::Mutate "void TMVA::GeneticPopulation::Mutate(Double_t probability=20, Int_t startIndex=0, Bool_t near=kFALSE, Double_t spread=0.1, Bool_t mirror=kFALSE)
";

%feature("docstring")  TMVA::GeneticPopulation::GetGenes "GeneticGenes* TMVA::GeneticPopulation::GetGenes(Int_t index)
";

%feature("docstring")  TMVA::GeneticPopulation::GetPopulationSize "Int_t TMVA::GeneticPopulation::GetPopulationSize() const
";

%feature("docstring")  TMVA::GeneticPopulation::GetFitness "Double_t TMVA::GeneticPopulation::GetFitness() const
";

%feature("docstring")  TMVA::GeneticPopulation::GetGenePool "const std::vector<TMVA::GeneticGenes>& TMVA::GeneticPopulation::GetGenePool() const
";

%feature("docstring")  TMVA::GeneticPopulation::GetRanges "const std::vector<TMVA::GeneticRange*>& TMVA::GeneticPopulation::GetRanges() const
";

%feature("docstring")  TMVA::GeneticPopulation::GetGenePool "std::vector<TMVA::GeneticGenes>& TMVA::GeneticPopulation::GetGenePool()
";

%feature("docstring")  TMVA::GeneticPopulation::GetRanges "std::vector<TMVA::GeneticRange*>& TMVA::GeneticPopulation::GetRanges()
";

%feature("docstring")  TMVA::GeneticPopulation::Print "void TMVA::GeneticPopulation::Print(Int_t untilIndex=-1)
";

%feature("docstring")  TMVA::GeneticPopulation::Print "void TMVA::GeneticPopulation::Print(std::ostream &out, Int_t utilIndex=-1)
";

%feature("docstring")  TMVA::GeneticPopulation::VariableDistribution "std::vector< Double_t > TMVA::GeneticPopulation::VariableDistribution(Int_t varNumber)
";

%feature("docstring")  TMVA::GeneticPopulation::MakeCopies "void TMVA::GeneticPopulation::MakeCopies(int number)
";

%feature("docstring")  TMVA::GeneticPopulation::NextGeneration "void TMVA::GeneticPopulation::NextGeneration()
";

%feature("docstring")  TMVA::GeneticPopulation::AddPopulation "void TMVA::GeneticPopulation::AddPopulation(GeneticPopulation *strangers)
";

%feature("docstring")  TMVA::GeneticPopulation::AddPopulation "void TMVA::GeneticPopulation::AddPopulation(GeneticPopulation &strangers)
";

%feature("docstring")  TMVA::GeneticPopulation::TrimPopulation "void TMVA::GeneticPopulation::TrimPopulation()
";

%feature("docstring")  TMVA::GeneticPopulation::GiveHint "void TMVA::GeneticPopulation::GiveHint(std::vector< Double_t > &hint, Double_t fitness=0)
";

%feature("docstring")  TMVA::GeneticPopulation::Sort "void TMVA::GeneticPopulation::Sort()
";


// File: classTMVA_1_1GeneticRange.xml
%feature("docstring") TMVA::GeneticRange "";

%feature("docstring")  TMVA::GeneticRange::GeneticRange "TMVA::GeneticRange::GeneticRange(TRandom3 *rnd, Interval *interval)
";

%feature("docstring")  TMVA::GeneticRange::~GeneticRange "virtual TMVA::GeneticRange::~GeneticRange()
";

%feature("docstring")  TMVA::GeneticRange::Random "Double_t TMVA::GeneticRange::Random(Bool_t near=kFALSE, Double_t value=0, Double_t spread=0.1, Bool_t mirror=kFALSE)
";

%feature("docstring")  TMVA::GeneticRange::RandomDiscrete "Double_t TMVA::GeneticRange::RandomDiscrete()
";

%feature("docstring")  TMVA::GeneticRange::GetFrom "Double_t TMVA::GeneticRange::GetFrom()
";

%feature("docstring")  TMVA::GeneticRange::GetTo "Double_t TMVA::GeneticRange::GetTo()
";

%feature("docstring")  TMVA::GeneticRange::GetTotalLength "Double_t TMVA::GeneticRange::GetTotalLength()
";


// File: classROOT_1_1Math_1_1GradFunctor.xml
%feature("docstring") ROOT::Math::GradFunctor "

GradFunctor class for Multidimensional gradient functions. It is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way: 
from an object implementing both double operator()( const double * ) for the function evaluation and double Derivative(const double *, int icoord) for the partial derivatives

from an object implementing any member function like Foo::XXX(const double *) for the function evaluation and any member function like Foo::XXX(const double *, int icoord) for the partial derivatives

from an function object implementing double operator()( const double * ) for the function evaluation and another function object implementing double operator() (const double *, int icoord) for the partial derivatives

The function dimension is required when constructing the functor.

C++ includes: Functor.h
";

%feature("docstring")  ROOT::Math::GradFunctor::GradFunctor "ROOT::Math::GradFunctor::GradFunctor()

Default constructor 
";

%feature("docstring")  ROOT::Math::GradFunctor::GradFunctor "ROOT::Math::GradFunctor::GradFunctor(const Func &f, unsigned int dim)

construct from a callable object of multi-dimension implementing operator()(const double *x) and Derivative(const double * x,icoord) 
";

%feature("docstring")  ROOT::Math::GradFunctor::GradFunctor "ROOT::Math::GradFunctor::GradFunctor(const PtrObj &p, MemFn memFn, GradMemFn gradFn, unsigned int dim)

construct from a pointer to member function and member function types for function and derivative evaluations 
";

%feature("docstring")  ROOT::Math::GradFunctor::GradFunctor "ROOT::Math::GradFunctor::GradFunctor(const Func &f, const GradFunc &g, int dim)

construct for Gradient Functions of multi-dimension Func gives the function evaluatiion, GradFunc the partial derivatives The function dimension is required 
";

%feature("docstring")  ROOT::Math::GradFunctor::~GradFunctor "virtual ROOT::Math::GradFunctor::~GradFunctor()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::GradFunctor::GradFunctor "ROOT::Math::GradFunctor::GradFunctor(const GradFunctor &rhs)

Copy constructor for functor based on ROOT::Math::IMultiGradFunction 
";

%feature("docstring")  ROOT::Math::GradFunctor::Clone "ImplBase* ROOT::Math::GradFunctor::Clone() const

Clone a function. Each derived class must implement their version of the Clone method 
";

%feature("docstring")  ROOT::Math::GradFunctor::NDim "unsigned int ROOT::Math::GradFunctor::NDim() const

Retrieve the dimension of the function 
";


// File: classROOT_1_1Math_1_1GradFunctor1D.xml
%feature("docstring") ROOT::Math::GradFunctor1D "

GradFunctor1D class for one-dimensional gradient functions. It is used to wrap in a very C++ callable object to make a 1D gradient functions. It can be constructed in three different way: 
from an object implementing both double operator()( double  ) for the function evaluation and double Derivative(double ) for the partial derivatives

from an object implementing any member function like Foo::XXX(double ) for the function evaluation and any other member function like Foo::YYY(double ) for the derivative.

from an 2 function objects implementing double operator()( double ) . One object provides the function evaluation, the other the derivative.

C++ includes: Functor.h
";

%feature("docstring")  ROOT::Math::GradFunctor1D::GradFunctor1D "ROOT::Math::GradFunctor1D::GradFunctor1D()

Default constructor 
";

%feature("docstring")  ROOT::Math::GradFunctor1D::GradFunctor1D "ROOT::Math::GradFunctor1D::GradFunctor1D(const Func &f)

construct from an object with the right signature implementing both operator() (double x) and Derivative(double x) 
";

%feature("docstring")  ROOT::Math::GradFunctor1D::GradFunctor1D "ROOT::Math::GradFunctor1D::GradFunctor1D(const PtrObj &p, MemFn memFn, GradMemFn gradFn)

construct from a pointer to class and two pointers to member functions, one for the function evaluation and the other for the derivative. The member functions must take a double as argument and return a double 
";

%feature("docstring")  ROOT::Math::GradFunctor1D::GradFunctor1D "ROOT::Math::GradFunctor1D::GradFunctor1D(const Func &f, const GradFunc &g)

construct from two 1D function objects 
";

%feature("docstring")  ROOT::Math::GradFunctor1D::~GradFunctor1D "virtual ROOT::Math::GradFunctor1D::~GradFunctor1D()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::GradFunctor1D::GradFunctor1D "ROOT::Math::GradFunctor1D::GradFunctor1D(const GradFunctor1D &rhs)

Copy constructor for  Functor based on ROOT::Math::IGradFunction 
";

%feature("docstring")  ROOT::Math::GradFunctor1D::Clone "ImplBase* ROOT::Math::GradFunctor1D::Clone() const

Clone a function. Each derived class will implement their version of the provate DoClone method 
";


// File: classROOT_1_1Minuit2_1_1GradientCalculator.xml
%feature("docstring") ROOT::Minuit2::GradientCalculator "

interface class for gradient calculators

C++ includes: GradientCalculator.h
";

%feature("docstring")  ROOT::Minuit2::GradientCalculator::~GradientCalculator "virtual ROOT::Minuit2::GradientCalculator::~GradientCalculator()
";


// File: classROOT_1_1Math_1_1GSL1DMinimizerWrapper.xml
%feature("docstring") ROOT::Math::GSL1DMinimizerWrapper "

wrapper class for gsl_min_fminimizer structure

C++ includes: GSL1DMinimizerWrapper.h
";

%feature("docstring")  ROOT::Math::GSL1DMinimizerWrapper::GSL1DMinimizerWrapper "ROOT::Math::GSL1DMinimizerWrapper::GSL1DMinimizerWrapper(const gsl_min_fminimizer_type *T)
";

%feature("docstring")  ROOT::Math::GSL1DMinimizerWrapper::~GSL1DMinimizerWrapper "virtual ROOT::Math::GSL1DMinimizerWrapper::~GSL1DMinimizerWrapper()
";

%feature("docstring")  ROOT::Math::GSL1DMinimizerWrapper::Get "gsl_min_fminimizer* ROOT::Math::GSL1DMinimizerWrapper::Get() const
";


// File: classROOT_1_1Math_1_1GSLDerivator.xml
%feature("docstring") ROOT::Math::GSLDerivator "

Class for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ).

C++ includes: GSLDerivator.h
";

%feature("docstring")  ROOT::Math::GSLDerivator::GSLDerivator "ROOT::Math::GSLDerivator::GSLDerivator()

Default Constructor of a  GSLDerivator class based on GSL numerical differentiation algorithms 
";

%feature("docstring")  ROOT::Math::GSLDerivator::~GSLDerivator "virtual ROOT::Math::GSLDerivator::~GSLDerivator()

destructor (no operations) 
";

%feature("docstring")  ROOT::Math::GSLDerivator::SetFunction "void ROOT::Math::GSLDerivator::SetFunction(const IGenFunction &f)

Set the function for calculating the derivatives. The function must implement the ROOT::Math::IGenFunction signature 
";

%feature("docstring")  ROOT::Math::GSLDerivator::SetFunction "void ROOT::Math::GSLDerivator::SetFunction(GSLFuncPointer f, void *p=0)

Set the function f for evaluating the derivative using a GSL function pointer type

Parameters:
-----------

f: 
: free function pointer of the GSL required type

p: 
: pointer to the object carrying the function state (for example the function object itself) 
";

%feature("docstring")  ROOT::Math::GSLDerivator::EvalCentral "double ROOT::Math::GSLDerivator::EvalCentral(double x, double h)

Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. 
";

%feature("docstring")  ROOT::Math::GSLDerivator::EvalForward "double ROOT::Math::GSLDerivator::EvalForward(double x, double h)

Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. The function is evaluated only at points greater than x and at x itself. 
";

%feature("docstring")  ROOT::Math::GSLDerivator::EvalBackward "double ROOT::Math::GSLDerivator::EvalBackward(double x, double h)

Computes the numerical derivative at a point x using an adaptive backward difference algorithm with a step size h. The function is evaluated only at points less than x and at x itself. 
";


// File: classROOT_1_1Math_1_1GSLFunctionAdapter.xml
%feature("docstring") ROOT::Math::GSLFunctionAdapter "

Class for adapting any C++ functor class to C function pointers used by GSL. The templated C++ function class must implement:

double operator( double x) and if the derivatives are required:   double Gradient( double x)

This class defines static methods with will be used to fill the  gsl_function and  gsl_function_fdf structs used by GSL. See for examples the GSL online manual

C++ includes: GSLFunctionAdapter.h
";

%feature("docstring")  ROOT::Math::GSLFunctionAdapter::GSLFunctionAdapter "ROOT::Math::GSLFunctionAdapter< UserFunc >::GSLFunctionAdapter()
";

%feature("docstring")  ROOT::Math::GSLFunctionAdapter::~GSLFunctionAdapter "virtual ROOT::Math::GSLFunctionAdapter< UserFunc >::~GSLFunctionAdapter()
";


// File: classROOT_1_1Math_1_1GSLFunctionDerivWrapper.xml
%feature("docstring") ROOT::Math::GSLFunctionDerivWrapper "

class to wrap a gsl_function_fdf (with derivatives)

C++ includes: GSLFunctionWrapper.h
";

%feature("docstring")  ROOT::Math::GSLFunctionDerivWrapper::GSLFunctionDerivWrapper "ROOT::Math::GSLFunctionDerivWrapper::GSLFunctionDerivWrapper()
";

%feature("docstring")  ROOT::Math::GSLFunctionDerivWrapper::SetFuncPointer "void ROOT::Math::GSLFunctionDerivWrapper::SetFuncPointer(GSLFuncPointer f)
";

%feature("docstring")  ROOT::Math::GSLFunctionDerivWrapper::SetDerivPointer "void ROOT::Math::GSLFunctionDerivWrapper::SetDerivPointer(GSLFuncPointer f)
";

%feature("docstring")  ROOT::Math::GSLFunctionDerivWrapper::SetFdfPointer "void ROOT::Math::GSLFunctionDerivWrapper::SetFdfPointer(GSLFdfPointer f)
";

%feature("docstring")  ROOT::Math::GSLFunctionDerivWrapper::SetParams "void ROOT::Math::GSLFunctionDerivWrapper::SetParams(void *p)
";

%feature("docstring")  ROOT::Math::GSLFunctionDerivWrapper::GetFunc "gsl_function_fdf* ROOT::Math::GSLFunctionDerivWrapper::GetFunc()
";

%feature("docstring")  ROOT::Math::GSLFunctionDerivWrapper::Derivative "double ROOT::Math::GSLFunctionDerivWrapper::Derivative(double x)
";

%feature("docstring")  ROOT::Math::GSLFunctionDerivWrapper::Fdf "void ROOT::Math::GSLFunctionDerivWrapper::Fdf(double x, double &f, double &df)
";

%feature("docstring")  ROOT::Math::GSLFunctionDerivWrapper::IsValid "bool ROOT::Math::GSLFunctionDerivWrapper::IsValid()

check if function is valid (has been set) 
";


// File: classROOT_1_1Math_1_1GSLFunctionWrapper.xml
%feature("docstring") ROOT::Math::GSLFunctionWrapper "

Wrapper class to the gsl_function C structure. This class to fill the GSL C structure gsl_function with the C++ function objcet. Use the class  ROOT::Math::GSLFunctionAdapter to adapt the C++ function object to the right signature (function pointer type) requested by GSL

C++ includes: GSLFunctionWrapper.h
";

%feature("docstring")  ROOT::Math::GSLFunctionWrapper::GSLFunctionWrapper "ROOT::Math::GSLFunctionWrapper::GSLFunctionWrapper()
";

%feature("docstring")  ROOT::Math::GSLFunctionWrapper::SetFuncPointer "void ROOT::Math::GSLFunctionWrapper::SetFuncPointer(GSLFuncPointer f)

set in the GSL C struct the pointer to the function evaluation 
";

%feature("docstring")  ROOT::Math::GSLFunctionWrapper::SetParams "void ROOT::Math::GSLFunctionWrapper::SetParams(void *p)

set in the GSL C struct the extra-object pointer 
";

%feature("docstring")  ROOT::Math::GSLFunctionWrapper::SetFunction "void ROOT::Math::GSLFunctionWrapper::SetFunction(const FuncType &f)

fill the GSL C struct from a generic C++ callable object implementing operator() 
";

%feature("docstring")  ROOT::Math::GSLFunctionWrapper::GetFunc "gsl_function* ROOT::Math::GSLFunctionWrapper::GetFunc()
";

%feature("docstring")  ROOT::Math::GSLFunctionWrapper::FunctionPtr "GSLFuncPointer ROOT::Math::GSLFunctionWrapper::FunctionPtr()
";

%feature("docstring")  ROOT::Math::GSLFunctionWrapper::IsValid "bool ROOT::Math::GSLFunctionWrapper::IsValid()

check if function is valid (has been set) 
";


// File: classGSLLevenbergMarquardtMinimizer.xml
%feature("docstring") GSLLevenbergMarquardtMinimizer "

It's a facade to  ROOT::Math::GSLNLSMinimizer which, in turn, is a facade to the actual GSL's gsl_multifit_fdfsolver_type (http://www.gnu.org/software/gsl/manual/html_node/Nonlinear-Least_002dSquares-Fitting.html).

C++ includes: GSLLevenbergMarquardtMinimizer.h
";

%feature("docstring")  GSLLevenbergMarquardtMinimizer::GSLLevenbergMarquardtMinimizer "GSLLevenbergMarquardtMinimizer::GSLLevenbergMarquardtMinimizer()
";

%feature("docstring")  GSLLevenbergMarquardtMinimizer::~GSLLevenbergMarquardtMinimizer "GSLLevenbergMarquardtMinimizer::~GSLLevenbergMarquardtMinimizer() override
";

%feature("docstring")  GSLLevenbergMarquardtMinimizer::setTolerance "void GSLLevenbergMarquardtMinimizer::setTolerance(double value)

Sets tolerance on the function value at the minimum. 
";

%feature("docstring")  GSLLevenbergMarquardtMinimizer::tolerance "double GSLLevenbergMarquardtMinimizer::tolerance() const
";

%feature("docstring")  GSLLevenbergMarquardtMinimizer::setPrintLevel "void GSLLevenbergMarquardtMinimizer::setPrintLevel(int value)

Sets minimizer internal print level. 
";

%feature("docstring")  GSLLevenbergMarquardtMinimizer::printLevel "int GSLLevenbergMarquardtMinimizer::printLevel() const
";

%feature("docstring")  GSLLevenbergMarquardtMinimizer::setMaxIterations "void GSLLevenbergMarquardtMinimizer::setMaxIterations(int value)

Sets maximum number of iterations. This is an internal minimizer setting which has no direct relation to the number of objective function calls (e.g. numberOfIteraction=5 might correspond to ~100 objective function calls). 
";

%feature("docstring")  GSLLevenbergMarquardtMinimizer::maxIterations "int GSLLevenbergMarquardtMinimizer::maxIterations() const
";

%feature("docstring")  GSLLevenbergMarquardtMinimizer::statusToString "std::string GSLLevenbergMarquardtMinimizer::statusToString() const override

Returns string representation of current minimizer status. 
";

%feature("docstring")  GSLLevenbergMarquardtMinimizer::statusMap "std::map< std::string, std::string > GSLLevenbergMarquardtMinimizer::statusMap() const override

Returns map of string representing different minimizer statuses. 
";

%feature("docstring")  GSLLevenbergMarquardtMinimizer::requiresResiduals "bool GSLLevenbergMarquardtMinimizer::requiresResiduals() override

Returns true if minimizer computations are residual-based, false otherwise. 
";


// File: classROOT_1_1Math_1_1GSLMinimizer.xml
%feature("docstring") ROOT::Math::GSLMinimizer "

GSLMinimizer class. Implementation of the  ROOT::Math::Minimizer interface using the GSL multi-dimensional minimization algorithms.

See GSL doc from more info on the GSL minimization algorithms.

The class implements the  ROOT::Math::Minimizer interface and can be instantiated using the  ROOT plugin manager (plugin name is \"GSLMultiMin\"). The varius minimization algorithms (conjugatefr, conjugatepr, bfgs, etc..) can be passed as enumerations and also as a string. The default algorithm is conjugatefr (Fletcher-Reeves conjugate gradient algorithm).

C++ includes: GSLMinimizer.h
";

%feature("docstring")  ROOT::Math::GSLMinimizer::GSLMinimizer "ROOT::Math::GSLMinimizer::GSLMinimizer(ROOT::Math::EGSLMinimizerType type=ROOT::Math::kConjugateFR)

Default constructor 
";

%feature("docstring")  ROOT::Math::GSLMinimizer::GSLMinimizer "ROOT::Math::GSLMinimizer::GSLMinimizer(const char *type)

Constructor with a string giving name of algorithm 
";

%feature("docstring")  ROOT::Math::GSLMinimizer::~GSLMinimizer "virtual ROOT::Math::GSLMinimizer::~GSLMinimizer()

Destructor 
";

%feature("docstring")  ROOT::Math::GSLMinimizer::SetFunction "virtual void ROOT::Math::GSLMinimizer::SetFunction(const ROOT::Math::IMultiGenFunction &func)

set the function to minimize 
";

%feature("docstring")  ROOT::Math::GSLMinimizer::SetFunction "virtual void ROOT::Math::GSLMinimizer::SetFunction(const ROOT::Math::IMultiGradFunction &func)

set the function to minimize 
";

%feature("docstring")  ROOT::Math::GSLMinimizer::Minimize "virtual bool ROOT::Math::GSLMinimizer::Minimize()

method to perform the minimization 
";

%feature("docstring")  ROOT::Math::GSLMinimizer::Edm "virtual double ROOT::Math::GSLMinimizer::Edm() const

return expected distance reached from the minimum 
";

%feature("docstring")  ROOT::Math::GSLMinimizer::MinGradient "virtual const double* ROOT::Math::GSLMinimizer::MinGradient() const

return pointer to gradient values at the minimum 
";

%feature("docstring")  ROOT::Math::GSLMinimizer::NCalls "virtual unsigned int ROOT::Math::GSLMinimizer::NCalls() const

number of function calls to reach the minimum 
";

%feature("docstring")  ROOT::Math::GSLMinimizer::ProvidesError "virtual bool ROOT::Math::GSLMinimizer::ProvidesError() const

minimizer provides error and error matrix 
";

%feature("docstring")  ROOT::Math::GSLMinimizer::Errors "virtual const double* ROOT::Math::GSLMinimizer::Errors() const

return errors at the minimum 
";

%feature("docstring")  ROOT::Math::GSLMinimizer::CovMatrix "virtual double ROOT::Math::GSLMinimizer::CovMatrix(unsigned int, unsigned int) const

return covariance matrices elements if the variable is fixed the matrix is zero The ordering of the variables is the same as in errors 
";


// File: classROOT_1_1Math_1_1GSLMinimizer1D.xml
%feature("docstring") ROOT::Math::GSLMinimizer1D "

Minimizer for arbitrary one dimensional functions.

Implemented using GSL, for detailed description see: GSL online doc

The algorithms uspported are only bracketing algorithm which do not use derivatives information. The algorithms which can be chosen at construction time are GOLDENSECTION, whic is the simplest method but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation.

This class does not support copying

C++ includes: GSLMinimizer1D.h
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::GSLMinimizer1D "ROOT::Math::GSLMinimizer1D::GSLMinimizer1D(Minim1D::Type type=Minim1D::kBRENT)

Construct the minimizer passing the minimizer type using the Minim1D::Algorithm enumeration 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::~GSLMinimizer1D "virtual ROOT::Math::GSLMinimizer1D::~GSLMinimizer1D()

Destructor: free allocated resources 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::SetFunction "void ROOT::Math::GSLMinimizer1D::SetFunction(const UserFunc &f, double xmin, double xlow, double xup)

Set, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin. The condition :  $ f(xlow) > f(xmin) < f(xup)$ must be satisfied 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::SetFunction "void ROOT::Math::GSLMinimizer1D::SetFunction(GSLFuncPointer f, void *params, double xmin, double xlow, double xup)

Set, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin. The condition :  $ f(xlow) > f(xmin) < f(xup) $ must be satisfied

Method specialized on the GSL function type 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::Iterate "int ROOT::Math::GSLMinimizer1D::Iterate()

Perform a minimizer iteration and if an unexepcted problem occurr then an error code will be returned 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::XMinimum "double ROOT::Math::GSLMinimizer1D::XMinimum() const

Return current estimate of the position of the minimum 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::XLower "double ROOT::Math::GSLMinimizer1D::XLower() const

Return current lower bound of the minimization interval 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::XUpper "double ROOT::Math::GSLMinimizer1D::XUpper() const

Return current upper bound of the minimization interval 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::FValMinimum "double ROOT::Math::GSLMinimizer1D::FValMinimum() const

Return function value at current estimate of the minimum 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::FValLower "double ROOT::Math::GSLMinimizer1D::FValLower() const

Return function value at current lower bound of the minimization interval 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::FValUpper "double ROOT::Math::GSLMinimizer1D::FValUpper() const

Return function value at current upper bound of the minimization interval 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::Minimize "bool ROOT::Math::GSLMinimizer1D::Minimize(int maxIter, double absTol, double relTol)

Find minimum position iterating until convergence specified by the absolute and relative tolerance or the maximum number of iteration is reached Return true is result is successfull @param maxIter maximum number of iteration @param absTol desired absolute error in the minimum position @param absTol desired relative error in the minimum position 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::Iterations "int ROOT::Math::GSLMinimizer1D::Iterations() const

Return number of iteration used to find minimum 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::Status "int ROOT::Math::GSLMinimizer1D::Status() const

Return status of last minimization 
";

%feature("docstring")  ROOT::Math::GSLMinimizer1D::Name "const char* ROOT::Math::GSLMinimizer1D::Name() const

Return name of minimization algorithm 
";


// File: classROOT_1_1Math_1_1GSLMultiFit.xml
%feature("docstring") ROOT::Math::GSLMultiFit "

GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting

C++ includes: GSLMultiFit.h
";

%feature("docstring")  ROOT::Math::GSLMultiFit::GSLMultiFit "ROOT::Math::GSLMultiFit::GSLMultiFit(const gsl_multifit_fdfsolver_type *type=0)

Default constructor No need to specify the type so far since only one solver exists so far 
";

%feature("docstring")  ROOT::Math::GSLMultiFit::~GSLMultiFit "ROOT::Math::GSLMultiFit::~GSLMultiFit()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::GSLMultiFit::CreateSolver "void ROOT::Math::GSLMultiFit::CreateSolver(unsigned int npoints, unsigned int npar)

create the minimizer from the type and size of number of fitting points and number of parameters 
";

%feature("docstring")  ROOT::Math::GSLMultiFit::Set "int ROOT::Math::GSLMultiFit::Set(const std::vector< Func > &funcVec, const double *x)

set the solver parameters 
";

%feature("docstring")  ROOT::Math::GSLMultiFit::Name "std::string ROOT::Math::GSLMultiFit::Name() const
";

%feature("docstring")  ROOT::Math::GSLMultiFit::Iterate "int ROOT::Math::GSLMultiFit::Iterate()
";

%feature("docstring")  ROOT::Math::GSLMultiFit::X "const double* ROOT::Math::GSLMultiFit::X() const

parameter values at the minimum 
";

%feature("docstring")  ROOT::Math::GSLMultiFit::Gradient "const double* ROOT::Math::GSLMultiFit::Gradient() const

gradient value at the minimum 
";

%feature("docstring")  ROOT::Math::GSLMultiFit::CovarMatrix "const double* ROOT::Math::GSLMultiFit::CovarMatrix() const

return covariance matrix of the parameters 
";

%feature("docstring")  ROOT::Math::GSLMultiFit::TestGradient "int ROOT::Math::GSLMultiFit::TestGradient(double absTol) const

test gradient (ask from solver gradient vector) 
";

%feature("docstring")  ROOT::Math::GSLMultiFit::TestDelta "int ROOT::Math::GSLMultiFit::TestDelta(double absTol, double relTol) const

test using abs and relative tolerance |dx| < absTol + relTol*|x| for every component 
";

%feature("docstring")  ROOT::Math::GSLMultiFit::Edm "double ROOT::Math::GSLMultiFit::Edm() const
";


// File: classROOT_1_1Math_1_1GSLMultiFitFunctionAdapter.xml
%feature("docstring") ROOT::Math::GSLMultiFitFunctionAdapter "

Class for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement:

double operator( const double *  x) and if the derivatives are required:   void Gradient( const double *   x, double * g) and   void FdF( const double *   x, double &f, double * g)

This class defines static methods with will be used to fill the  gsl_multimin_function and  gsl_multimin_function_fdf structs used by GSL. See for examples the GSL online manual

C++ includes: GSLMultiFitFunctionAdapter.h
";


// File: classROOT_1_1Math_1_1GSLMultiFitFunctionWrapper.xml
%feature("docstring") ROOT::Math::GSLMultiFitFunctionWrapper "

wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm

C++ includes: GSLMultiFitFunctionWrapper.h
";

%feature("docstring")  ROOT::Math::GSLMultiFitFunctionWrapper::GSLMultiFitFunctionWrapper "ROOT::Math::GSLMultiFitFunctionWrapper::GSLMultiFitFunctionWrapper()
";

%feature("docstring")  ROOT::Math::GSLMultiFitFunctionWrapper::SetFunction "void ROOT::Math::GSLMultiFitFunctionWrapper::SetFunction(const FuncVector &f, unsigned int nres, unsigned int npar)

Fill gsl function structure from a C++ function iterator and size and number of residuals. 
";

%feature("docstring")  ROOT::Math::GSLMultiFitFunctionWrapper::GetFunc "gsl_multifit_function_fdf* ROOT::Math::GSLMultiFitFunctionWrapper::GetFunc()
";


// File: classROOT_1_1Math_1_1GSLMultiMinDerivFunctionWrapper.xml
%feature("docstring") ROOT::Math::GSLMultiMinDerivFunctionWrapper "

Wrapper for a multi-dimensional function with derivatives used in GSL multidim minimization algorithm

C++ includes: GSLMultiMinFunctionWrapper.h
";

%feature("docstring")  ROOT::Math::GSLMultiMinDerivFunctionWrapper::GSLMultiMinDerivFunctionWrapper "ROOT::Math::GSLMultiMinDerivFunctionWrapper::GSLMultiMinDerivFunctionWrapper()
";

%feature("docstring")  ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetFuncPointer "void ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetFuncPointer(GSLMultiMinFuncPointer f)
";

%feature("docstring")  ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetDerivPointer "void ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetDerivPointer(GSLMultiMinDfPointer f)
";

%feature("docstring")  ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetFdfPointer "void ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetFdfPointer(GSLMultiMinFdfPointer f)
";

%feature("docstring")  ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetDim "void ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetDim(unsigned int n)
";

%feature("docstring")  ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetParams "void ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetParams(void *p)
";

%feature("docstring")  ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetFunction "void ROOT::Math::GSLMultiMinDerivFunctionWrapper::SetFunction(const FuncType &f)

Fill gsl function structure from a C++ Function class. 
";

%feature("docstring")  ROOT::Math::GSLMultiMinDerivFunctionWrapper::GetFunc "gsl_multimin_function_fdf* ROOT::Math::GSLMultiMinDerivFunctionWrapper::GetFunc()
";

%feature("docstring")  ROOT::Math::GSLMultiMinDerivFunctionWrapper::IsValid "bool ROOT::Math::GSLMultiMinDerivFunctionWrapper::IsValid()

check if function is valid (has been set) 
";


// File: structROOT_1_1Math_1_1GSLMultiMinFunctionAdapter.xml
%feature("docstring") ROOT::Math::GSLMultiMinFunctionAdapter "

Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. The templated C++ function class must implement:

double operator( const double *  x) and if the derivatives are required:   void Gradient( const double *   x, double * g)

This class defines static methods with will be used to fill the  gsl_multimin_function and  gsl_multimin_function_fdf structs used by GSL. See for examples the GSL online manual

C++ includes: GSLMultiMinFunctionAdapter.h
";


// File: classROOT_1_1Math_1_1GSLMultiMinFunctionWrapper.xml
%feature("docstring") ROOT::Math::GSLMultiMinFunctionWrapper "

wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm

C++ includes: GSLMultiMinFunctionWrapper.h
";

%feature("docstring")  ROOT::Math::GSLMultiMinFunctionWrapper::GSLMultiMinFunctionWrapper "ROOT::Math::GSLMultiMinFunctionWrapper::GSLMultiMinFunctionWrapper()
";

%feature("docstring")  ROOT::Math::GSLMultiMinFunctionWrapper::SetFuncPointer "void ROOT::Math::GSLMultiMinFunctionWrapper::SetFuncPointer(GSLMultiMinFuncPointer f)
";

%feature("docstring")  ROOT::Math::GSLMultiMinFunctionWrapper::SetDim "void ROOT::Math::GSLMultiMinFunctionWrapper::SetDim(unsigned int n)
";

%feature("docstring")  ROOT::Math::GSLMultiMinFunctionWrapper::SetParams "void ROOT::Math::GSLMultiMinFunctionWrapper::SetParams(void *p)
";

%feature("docstring")  ROOT::Math::GSLMultiMinFunctionWrapper::SetFunction "void ROOT::Math::GSLMultiMinFunctionWrapper::SetFunction(const FuncType &f)

Fill gsl function structure from a C++ Function class. 
";

%feature("docstring")  ROOT::Math::GSLMultiMinFunctionWrapper::GetFunc "gsl_multimin_function* ROOT::Math::GSLMultiMinFunctionWrapper::GetFunc()
";

%feature("docstring")  ROOT::Math::GSLMultiMinFunctionWrapper::IsValid "bool ROOT::Math::GSLMultiMinFunctionWrapper::IsValid()
";


// File: classGSLMultiMinimizer.xml
%feature("docstring") GSLMultiMinimizer "

Wrapper for the CERN  ROOT facade of the GSL multi minimizer family (gradient descent based).

C++ includes: GSLMultiMinimizer.h
";

%feature("docstring")  GSLMultiMinimizer::GSLMultiMinimizer "GSLMultiMinimizer::GSLMultiMinimizer(const std::string &algorithmName=\"ConjugateFR\")
";

%feature("docstring")  GSLMultiMinimizer::~GSLMultiMinimizer "GSLMultiMinimizer::~GSLMultiMinimizer()
";

%feature("docstring")  GSLMultiMinimizer::setPrintLevel "void GSLMultiMinimizer::setPrintLevel(int value)

Sets minimizer internal print level. 
";

%feature("docstring")  GSLMultiMinimizer::printLevel "int GSLMultiMinimizer::printLevel() const
";

%feature("docstring")  GSLMultiMinimizer::setMaxIterations "void GSLMultiMinimizer::setMaxIterations(int value)

Sets maximum number of iterations. This is an internal minimizer setting which has no direct relation to the number of objective function calls (e.g. numberOfIteraction=5 might correspond to ~100 objective function calls). 
";

%feature("docstring")  GSLMultiMinimizer::maxIterations "int GSLMultiMinimizer::maxIterations() const
";

%feature("docstring")  GSLMultiMinimizer::statusToString "std::string GSLMultiMinimizer::statusToString() const override

Returns string representation of current minimizer status. 
";


// File: classROOT_1_1Math_1_1GSLMultiMinimizer.xml
%feature("docstring") ROOT::Math::GSLMultiMinimizer "

GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives

C++ includes: GSLMultiMinimizer.h
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::GSLMultiMinimizer "ROOT::Math::GSLMultiMinimizer::GSLMultiMinimizer(ROOT::Math::EGSLMinimizerType type)

Default constructor 
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::~GSLMultiMinimizer "ROOT::Math::GSLMultiMinimizer::~GSLMultiMinimizer()

Destructor 
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::Set "int ROOT::Math::GSLMultiMinimizer::Set(const ROOT::Math::IMultiGradFunction &func, const double *x, double stepSize, double tol)

set the function to be minimize the initial minimizer parameters, step size and tolerance in the line search 
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::CreateMinimizer "void ROOT::Math::GSLMultiMinimizer::CreateMinimizer(unsigned int n)

create the minimizer from the type and size 
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::Name "std::string ROOT::Math::GSLMultiMinimizer::Name() const
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::Iterate "int ROOT::Math::GSLMultiMinimizer::Iterate()
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::X "double* ROOT::Math::GSLMultiMinimizer::X() const

x values at the minimum 
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::Minimum "double ROOT::Math::GSLMultiMinimizer::Minimum() const

function value at the minimum 
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::Gradient "double* ROOT::Math::GSLMultiMinimizer::Gradient() const

gradient value at the minimum 
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::Restart "int ROOT::Math::GSLMultiMinimizer::Restart()

restart minimization from current point 
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::TestGradient "int ROOT::Math::GSLMultiMinimizer::TestGradient(double absTol) const

test gradient (ask from minimizer gradient vector) 
";

%feature("docstring")  ROOT::Math::GSLMultiMinimizer::TestGradient "int ROOT::Math::GSLMultiMinimizer::TestGradient(const double *g, double absTol) const

test gradient (require a vector gradient) 
";


// File: classROOT_1_1Math_1_1GSLNLSMinimizer.xml
%feature("docstring") ROOT::Math::GSLNLSMinimizer "

GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt algorithm from GSL Non Linear Least Square fitting.

C++ includes: GSLNLSMinimizer.h
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::GSLNLSMinimizer "ROOT::Math::GSLNLSMinimizer::GSLNLSMinimizer(int type=0)

Default constructor 
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::~GSLNLSMinimizer "ROOT::Math::GSLNLSMinimizer::~GSLNLSMinimizer()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::SetFunction "virtual void ROOT::Math::GSLNLSMinimizer::SetFunction(const ROOT::Math::IMultiGenFunction &func)

set the function to minimize 
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::SetFunction "virtual void ROOT::Math::GSLNLSMinimizer::SetFunction(const ROOT::Math::IMultiGradFunction &func)

set gradient the function to minimize 
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::Minimize "virtual bool ROOT::Math::GSLNLSMinimizer::Minimize()

method to perform the minimization 
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::Edm "virtual double ROOT::Math::GSLNLSMinimizer::Edm() const

return expected distance reached from the minimum 
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::MinGradient "virtual const double* ROOT::Math::GSLNLSMinimizer::MinGradient() const

return pointer to gradient values at the minimum 
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::NCalls "virtual unsigned int ROOT::Math::GSLNLSMinimizer::NCalls() const

number of function calls to reach the minimum 
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::ProvidesError "virtual bool ROOT::Math::GSLNLSMinimizer::ProvidesError() const

minimizer provides error and error matrix

number of free variables (real dimension of the problem) this is <= Function(). NDim() which is the total 
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::Errors "virtual const double* ROOT::Math::GSLNLSMinimizer::Errors() const

return errors at the minimum 
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::CovMatrix "virtual double ROOT::Math::GSLNLSMinimizer::CovMatrix(unsigned int, unsigned int) const

return covariance matrices elements if the variable is fixed the matrix is zero The ordering of the variables is the same as in errors 
";

%feature("docstring")  ROOT::Math::GSLNLSMinimizer::CovMatrixStatus "virtual int ROOT::Math::GSLNLSMinimizer::CovMatrixStatus() const

return covariance matrix status 
";


// File: classROOT_1_1Math_1_1GSLRandomEngine.xml
%feature("docstring") ROOT::Math::GSLRandomEngine "

GSLRandomEngine Base class for all GSL random engines, normally user instantiate the derived classes which creates internally the generator.

The main GSL generators (see here) are available as derived classes In addition to generate uniform numbers it provides method for generating numbers according to pre-defined distributions using the GSL functions from GSL random number distributions.

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::GSLRandomEngine "ROOT::Math::GSLRandomEngine::GSLRandomEngine()

default constructor. No creation of rng is done. If then  Initialize() is called an engine is created based on default GSL type (MT) 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::GSLRandomEngine "ROOT::Math::GSLRandomEngine::GSLRandomEngine(GSLRngWrapper *rng)

create from an existing rng. User manage the rng pointer which is then deleted olny by calling  Terminate()
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::GSLRandomEngine "ROOT::Math::GSLRandomEngine::GSLRandomEngine(const GSLRandomEngine &eng)

Copy constructor : clone the contained GSL generator 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::Initialize "void ROOT::Math::GSLRandomEngine::Initialize()

initialize the generator If no rng is present the default one based on Mersenne and Twister is created 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::Terminate "void ROOT::Math::GSLRandomEngine::Terminate()

delete pointer to contained rng 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::~GSLRandomEngine "virtual ROOT::Math::GSLRandomEngine::~GSLRandomEngine()

call  Terminate()
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::Rndm "double ROOT::Math::GSLRandomEngine::Rndm() const

Generate a random number between ]0,1] 0 is excluded and 1 is included 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::RndmInt "unsigned long ROOT::Math::GSLRandomEngine::RndmInt(unsigned long max) const

Generate an integer number between [0,max-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::IntRndm "unsigned long ROOT::Math::GSLRandomEngine::IntRndm() const

Generate an integer number between [0,max_generator-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::RandomArray "void ROOT::Math::GSLRandomEngine::RandomArray(Iterator begin, Iterator end) const

Generate an array of random numbers. The iterators points to the random numbers 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::RandomArray "void ROOT::Math::GSLRandomEngine::RandomArray(double *begin, double *end) const

Generate an array of random numbers The iterators points to the random numbers 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::Name "std::string ROOT::Math::GSLRandomEngine::Name() const

return name of generator 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::Size "unsigned int ROOT::Math::GSLRandomEngine::Size() const

return the state size of generator 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::MinInt "unsigned long ROOT::Math::GSLRandomEngine::MinInt() const

return the minimum integer a generator can handle typically this value is 0 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::MaxInt "unsigned long ROOT::Math::GSLRandomEngine::MaxInt() const

return the maximum integer +1 a generator can handle 
";

%feature("docstring")  ROOT::Math::GSLRandomEngine::SetSeed "void ROOT::Math::GSLRandomEngine::SetSeed(unsigned int seed) const

set the random generator seed 
";


// File: classROOT_1_1Math_1_1GSLRngCMRG.xml
%feature("docstring") ROOT::Math::GSLRngCMRG "

Combined multiple recursive generator (L'Ecuyer) see here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngCMRG::GSLRngCMRG "ROOT::Math::GSLRngCMRG::GSLRngCMRG()
";


// File: classROOT_1_1Math_1_1GSLRngGFSR4.xml
%feature("docstring") ROOT::Math::GSLRngGFSR4 "

Lagged Fibonacci generator by Ziff see here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngGFSR4::GSLRngGFSR4 "ROOT::Math::GSLRngGFSR4::GSLRngGFSR4()
";


// File: classROOT_1_1Math_1_1GSLRngMinStd.xml
%feature("docstring") ROOT::Math::GSLRngMinStd "

MINSTD generator (Park and Miller) see here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngMinStd::GSLRngMinStd "ROOT::Math::GSLRngMinStd::GSLRngMinStd()
";


// File: classROOT_1_1Math_1_1GSLRngMixMax.xml
%feature("docstring") ROOT::Math::GSLRngMixMax "

MixMax generator based on  ROOT::Math::MixMaxEngine of N=240

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngMixMax::GSLRngMixMax "ROOT::Math::GSLRngMixMax::GSLRngMixMax()
";

%feature("docstring")  ROOT::Math::GSLRngMixMax::~GSLRngMixMax "virtual ROOT::Math::GSLRngMixMax::~GSLRngMixMax()
";


// File: classROOT_1_1Math_1_1GSLRngMRG.xml
%feature("docstring") ROOT::Math::GSLRngMRG "

5-th order multiple recursive generator (L'Ecuyer, Blouin and Coutre) see here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngMRG::GSLRngMRG "ROOT::Math::GSLRngMRG::GSLRngMRG()
";


// File: classROOT_1_1Math_1_1GSLRngMT.xml
%feature("docstring") ROOT::Math::GSLRngMT "

Mersenne-Twister generator gsl_rng_mt19937 from here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngMT::GSLRngMT "ROOT::Math::GSLRngMT::GSLRngMT()
";


// File: classROOT_1_1Math_1_1GSLRngRand.xml
%feature("docstring") ROOT::Math::GSLRngRand "

BSD rand() generator gsl_rmg_rand from here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngRand::GSLRngRand "ROOT::Math::GSLRngRand::GSLRngRand()
";


// File: classROOT_1_1Math_1_1GSLRngRanLux.xml
%feature("docstring") ROOT::Math::GSLRngRanLux "

Old Ranlux generator (James, Luscher) (default luxury level, p = 223) (This is eequivalent to TRandom1 with default luxury level) see here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngRanLux::GSLRngRanLux "ROOT::Math::GSLRngRanLux::GSLRngRanLux()
";


// File: classROOT_1_1Math_1_1GSLRngRanLuxD1.xml
%feature("docstring") ROOT::Math::GSLRngRanLuxD1 "

Double precision (48 bits) version of Second generation of Ranlux generator with luxury level of 1 (It throws away 202 value for every 12 used) see here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngRanLuxD1::GSLRngRanLuxD1 "ROOT::Math::GSLRngRanLuxD1::GSLRngRanLuxD1()
";


// File: classROOT_1_1Math_1_1GSLRngRanLuxD2.xml
%feature("docstring") ROOT::Math::GSLRngRanLuxD2 "

Double precision (48 bits) version of Second generation of Ranlux generator with luxury level of 2 (It throws away 397 value for every 12 used) see here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngRanLuxD2::GSLRngRanLuxD2 "ROOT::Math::GSLRngRanLuxD2::GSLRngRanLuxD2()
";


// File: classROOT_1_1Math_1_1GSLRngRanLuxS1.xml
%feature("docstring") ROOT::Math::GSLRngRanLuxS1 "

Second generation of Ranlux generator for single precision with luxury level of 1 (It throws away 202 values for every 12 used) see here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngRanLuxS1::GSLRngRanLuxS1 "ROOT::Math::GSLRngRanLuxS1::GSLRngRanLuxS1()
";


// File: classROOT_1_1Math_1_1GSLRngRanLuxS2.xml
%feature("docstring") ROOT::Math::GSLRngRanLuxS2 "

Second generation of Ranlux generator for Single precision with luxury level of 2 (It throws away 397 value for every 12 used) see here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngRanLuxS2::GSLRngRanLuxS2 "ROOT::Math::GSLRngRanLuxS2::GSLRngRanLuxS2()
";


// File: classROOT_1_1Math_1_1GSLRngRanMar.xml
%feature("docstring") ROOT::Math::GSLRngRanMar "

RANMAR generator see here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngRanMar::GSLRngRanMar "ROOT::Math::GSLRngRanMar::GSLRngRanMar()
";


// File: structROOT_1_1Math_1_1GSLRngROOTWrapper.xml
%feature("docstring") ROOT::Math::GSLRngROOTWrapper "";

%feature("docstring")  ROOT::Math::GSLRngROOTWrapper::GSLRngROOTWrapper "ROOT::Math::GSLRngROOTWrapper< Engine >::GSLRngROOTWrapper()
";

%feature("docstring")  ROOT::Math::GSLRngROOTWrapper::~GSLRngROOTWrapper "ROOT::Math::GSLRngROOTWrapper< Engine >::~GSLRngROOTWrapper()
";


// File: classROOT_1_1Math_1_1GSLRngTaus.xml
%feature("docstring") ROOT::Math::GSLRngTaus "

Tausworthe generator by L'Ecuyer see here

C++ includes: GSLRndmEngines.h
";

%feature("docstring")  ROOT::Math::GSLRngTaus::GSLRngTaus "ROOT::Math::GSLRngTaus::GSLRngTaus()
";


// File: classROOT_1_1Math_1_1GSLRngWrapper.xml
%feature("docstring") ROOT::Math::GSLRngWrapper "

GSLRngWrapper class to wrap gsl_rng structure

C++ includes: GSLRngWrapper.h
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::GSLRngWrapper "ROOT::Math::GSLRngWrapper::GSLRngWrapper()

Default constructor 
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::GSLRngWrapper "ROOT::Math::GSLRngWrapper::GSLRngWrapper(const gsl_rng_type *type)

Constructor with type 
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::GSLRngWrapper "ROOT::Math::GSLRngWrapper::GSLRngWrapper(const gsl_rng *r)

construct from an existing gsl_rng it is managed externally - so will not be deleted at the end 
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::GSLRngWrapper "ROOT::Math::GSLRngWrapper::GSLRngWrapper(GSLRngWrapper &r)

Copy constructor - clone the GSL object and manage it 
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::~GSLRngWrapper "ROOT::Math::GSLRngWrapper::~GSLRngWrapper()

Destructor (free the rng if not done before) 
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::Allocate "void ROOT::Math::GSLRngWrapper::Allocate()
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::Free "void ROOT::Math::GSLRngWrapper::Free()
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::SetType "void ROOT::Math::GSLRngWrapper::SetType(const gsl_rng_type *type)
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::SetDefaultType "void ROOT::Math::GSLRngWrapper::SetDefaultType()
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::PrintState "void ROOT::Math::GSLRngWrapper::PrintState() const
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::Rng "gsl_rng* ROOT::Math::GSLRngWrapper::Rng()
";

%feature("docstring")  ROOT::Math::GSLRngWrapper::Rng "const gsl_rng* ROOT::Math::GSLRngWrapper::Rng() const
";


// File: classROOT_1_1Math_1_1GSLSimAnFunc.xml
%feature("docstring") ROOT::Math::GSLSimAnFunc "

GSLSimAnFunc class description. Interface class for the objetive function to be used in simulated annealing If user wants to re-implement some of the methods (like the one defining the metric) which are used by the the simulated annealing algorithm must build a user derived class. NOTE: Derived classes must re-implement the assignment and copy constructor to call them of the parent class

C++ includes: GSLSimAnnealing.h
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::GSLSimAnFunc "ROOT::Math::GSLSimAnFunc::GSLSimAnFunc(const ROOT::Math::IMultiGenFunction &func, const double *x)

construct from an interface of a multi-dimensional function 
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::GSLSimAnFunc "ROOT::Math::GSLSimAnFunc::GSLSimAnFunc(const ROOT::Math::IMultiGenFunction &func, const double *x, const double *scale)

construct from an interface of a multi-dimensional function Use optionally a scale factor (for each coordinate) which can be used to scale the step sizes (this is used for example by the minimization algorithm) 
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::~GSLSimAnFunc "virtual ROOT::Math::GSLSimAnFunc::~GSLSimAnFunc()

virtual distructor (no operations) 
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::FastCopy "virtual GSLSimAnFunc& ROOT::Math::GSLSimAnFunc::FastCopy(const GSLSimAnFunc &f)

fast copy method called by GSL simuated annealing internally copy only the things which have been changed must be re-implemented by derived classes if needed 
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::Clone "virtual GSLSimAnFunc* ROOT::Math::GSLSimAnFunc::Clone() const

clone method. Needs to be re-implemented by the derived classes for deep copying 
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::Energy "virtual double ROOT::Math::GSLSimAnFunc::Energy() const

evaluate the energy ( objective function value) re-implement by derived classes if needed to be modified 
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::Step "virtual void ROOT::Math::GSLSimAnFunc::Step(const GSLRandomEngine &r, double maxstep)

change the x[i] value using a random value urndm generated between [0,1] up to a maximum value maxstep re-implement by derived classes if needed to be modified 
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::Distance "virtual double ROOT::Math::GSLSimAnFunc::Distance(const GSLSimAnFunc &func) const

calculate the distance (metric) between this one and another configuration Presently a cartesian metric is used. re-implement by derived classes if needed to be modified 
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::Print "virtual void ROOT::Math::GSLSimAnFunc::Print()

print the position in the standard output std::ostream GSL prints in addition n iteration, n function calls, temperature and energy re-implement by derived classes if necessary 
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::SetX "void ROOT::Math::GSLSimAnFunc::SetX(const double *x)

change the x values (used by sim annealing to take a step) 
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::SetX "void ROOT::Math::GSLSimAnFunc::SetX(IT begin, IT end)
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::NDim "unsigned int ROOT::Math::GSLSimAnFunc::NDim() const
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::X "double ROOT::Math::GSLSimAnFunc::X(unsigned int i) const
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::X "const std::vector<double>& ROOT::Math::GSLSimAnFunc::X() const
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::Scale "double ROOT::Math::GSLSimAnFunc::Scale(unsigned int i) const
";

%feature("docstring")  ROOT::Math::GSLSimAnFunc::SetX "void ROOT::Math::GSLSimAnFunc::SetX(unsigned int i, double x)
";


// File: classROOT_1_1Math_1_1GSLSimAnMinimizer.xml
%feature("docstring") ROOT::Math::GSLSimAnMinimizer "

GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. It implements the ROOT::Minimizer interface and a plug-in (name \"GSLSimAn\") exists to instantiate this class via the plug-in manager

C++ includes: GSLSimAnMinimizer.h
";

%feature("docstring")  ROOT::Math::GSLSimAnMinimizer::GSLSimAnMinimizer "ROOT::Math::GSLSimAnMinimizer::GSLSimAnMinimizer(int type=0)

Default constructor 
";

%feature("docstring")  ROOT::Math::GSLSimAnMinimizer::~GSLSimAnMinimizer "virtual ROOT::Math::GSLSimAnMinimizer::~GSLSimAnMinimizer()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::GSLSimAnMinimizer::Minimize "virtual bool ROOT::Math::GSLSimAnMinimizer::Minimize()

method to perform the minimization 
";

%feature("docstring")  ROOT::Math::GSLSimAnMinimizer::NCalls "unsigned int ROOT::Math::GSLSimAnMinimizer::NCalls() const

number of function calls to reach the minimum 
";

%feature("docstring")  ROOT::Math::GSLSimAnMinimizer::getSolver "ROOT::Math::GSLSimAnnealing& ROOT::Math::GSLSimAnMinimizer::getSolver()
";


// File: classROOT_1_1Math_1_1GSLSimAnnealing.xml
%feature("docstring") ROOT::Math::GSLSimAnnealing "

GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function

C++ includes: GSLSimAnnealing.h
";

%feature("docstring")  ROOT::Math::GSLSimAnnealing::GSLSimAnnealing "ROOT::Math::GSLSimAnnealing::GSLSimAnnealing()

Default constructor 
";

%feature("docstring")  ROOT::Math::GSLSimAnnealing::~GSLSimAnnealing "ROOT::Math::GSLSimAnnealing::~GSLSimAnnealing()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::GSLSimAnnealing::Solve "int ROOT::Math::GSLSimAnnealing::Solve(const ROOT::Math::IMultiGenFunction &func, const double *x0, const double *scale, double *xmin, bool debug=false)

solve the simulated annealing given a multi-dim function, the initial vector parameters and a vector containing the scaling factors for the parameters 
";

%feature("docstring")  ROOT::Math::GSLSimAnnealing::Solve "int ROOT::Math::GSLSimAnnealing::Solve(GSLSimAnFunc &func, bool debug=false)

solve the simulated annealing given a  GSLSimAnFunc object The object will contain the initial state at the beginning and the final minimum state at the end 
";

%feature("docstring")  ROOT::Math::GSLSimAnnealing::Params "GSLSimAnParams& ROOT::Math::GSLSimAnnealing::Params()
";

%feature("docstring")  ROOT::Math::GSLSimAnnealing::Params "const GSLSimAnParams& ROOT::Math::GSLSimAnnealing::Params() const
";

%feature("docstring")  ROOT::Math::GSLSimAnnealing::SetParams "void ROOT::Math::GSLSimAnnealing::SetParams(const GSLSimAnParams &params)
";


// File: structROOT_1_1Math_1_1GSLSimAnParams.xml
%feature("docstring") ROOT::Math::GSLSimAnParams "

structure holding the simulated annealing parameters

C++ includes: GSLSimAnnealing.h
";

%feature("docstring")  ROOT::Math::GSLSimAnParams::GSLSimAnParams "ROOT::Math::GSLSimAnParams::GSLSimAnParams()
";


// File: classROOT_1_1Minuit2_1_1HessianGradientCalculator.xml
%feature("docstring") ROOT::Minuit2::HessianGradientCalculator "

HessianGradientCalculator: class to calculate Gradient for Hessian

C++ includes: HessianGradientCalculator.h
";

%feature("docstring")  ROOT::Minuit2::HessianGradientCalculator::HessianGradientCalculator "ROOT::Minuit2::HessianGradientCalculator::HessianGradientCalculator(const MnFcn &fcn, const MnUserTransformation &par, const MnStrategy &stra)
";

%feature("docstring")  ROOT::Minuit2::HessianGradientCalculator::~HessianGradientCalculator "virtual ROOT::Minuit2::HessianGradientCalculator::~HessianGradientCalculator()
";

%feature("docstring")  ROOT::Minuit2::HessianGradientCalculator::DeltaGradient "std::pair<FunctionGradient, MnAlgebraicVector> ROOT::Minuit2::HessianGradientCalculator::DeltaGradient(const MinimumParameters &, const FunctionGradient &) const
";

%feature("docstring")  ROOT::Minuit2::HessianGradientCalculator::Fcn "const MnFcn& ROOT::Minuit2::HessianGradientCalculator::Fcn() const
";

%feature("docstring")  ROOT::Minuit2::HessianGradientCalculator::Trafo "const MnUserTransformation& ROOT::Minuit2::HessianGradientCalculator::Trafo() const
";

%feature("docstring")  ROOT::Minuit2::HessianGradientCalculator::Precision "const MnMachinePrecision& ROOT::Minuit2::HessianGradientCalculator::Precision() const
";

%feature("docstring")  ROOT::Minuit2::HessianGradientCalculator::Strategy "const MnStrategy& ROOT::Minuit2::HessianGradientCalculator::Strategy() const
";

%feature("docstring")  ROOT::Minuit2::HessianGradientCalculator::Ncycle "unsigned int ROOT::Minuit2::HessianGradientCalculator::Ncycle() const
";

%feature("docstring")  ROOT::Minuit2::HessianGradientCalculator::StepTolerance "double ROOT::Minuit2::HessianGradientCalculator::StepTolerance() const
";

%feature("docstring")  ROOT::Minuit2::HessianGradientCalculator::GradTolerance "double ROOT::Minuit2::HessianGradientCalculator::GradTolerance() const
";


// File: classROOT_1_1Math_1_1IBaseFunctionMultiDimTempl.xml
%feature("docstring") ROOT::Math::IBaseFunctionMultiDimTempl "

Documentation for the abstract class IBaseFunctionMultiDim. Interface (abstract class) for generic functions objects of multi-dimension Provides a method to evaluate the function given a vector of coordinate values, by implementing operator() (const double *). In addition it defines the interface for copying functions via the pure virtual method  Clone() and the interface for getting the function dimension via the  NDim() method. Derived classes must implement the pure private virtual method DoEval(const double *) for the function evaluation in addition to  NDim() and  Clone().

C++ includes: IFunction.h
";

%feature("docstring")  ROOT::Math::IBaseFunctionMultiDimTempl::IBaseFunctionMultiDimTempl "ROOT::Math::IBaseFunctionMultiDimTempl< T >::IBaseFunctionMultiDimTempl()
";

%feature("docstring")  ROOT::Math::IBaseFunctionMultiDimTempl::~IBaseFunctionMultiDimTempl "virtual ROOT::Math::IBaseFunctionMultiDimTempl< T >::~IBaseFunctionMultiDimTempl()

virtual destructor 
";

%feature("docstring")  ROOT::Math::IBaseFunctionMultiDimTempl::Clone "virtual IBaseFunctionMultiDimTempl<T>* ROOT::Math::IBaseFunctionMultiDimTempl< T >::Clone() const =0

Clone a function. Each derived class must implement their version of the Clone method 
";

%feature("docstring")  ROOT::Math::IBaseFunctionMultiDimTempl::NDim "virtual unsigned int ROOT::Math::IBaseFunctionMultiDimTempl< T >::NDim() const =0

Retrieve the dimension of the function 
";


// File: classROOT_1_1Math_1_1IBaseFunctionOneDim.xml
%feature("docstring") ROOT::Math::IBaseFunctionOneDim "

Interface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ). In addition it defines the interface for copying functions via the pure virtual method  Clone(). Derived classes must implement the pure virtual private method DoEval(double ) for the function evaluation in addition to  Clone(). An interface for evaluating the function passing a vector (like for multidim functions) is also provided

C++ includes: IFunction.h
";

%feature("docstring")  ROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim "ROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim()
";

%feature("docstring")  ROOT::Math::IBaseFunctionOneDim::~IBaseFunctionOneDim "virtual ROOT::Math::IBaseFunctionOneDim::~IBaseFunctionOneDim()

virtual destructor 
";

%feature("docstring")  ROOT::Math::IBaseFunctionOneDim::Clone "virtual IBaseFunctionOneDim* ROOT::Math::IBaseFunctionOneDim::Clone() const =0

Clone a function. Each derived class will implement their version of the provate DoClone method 
";


// File: classROOT_1_1Math_1_1IBaseParam.xml
%feature("docstring") ROOT::Math::IBaseParam "

Documentation for the abstract class  IBaseParam. It defines the interface for dealing with the function parameters This is used only for internal convinience, to avoid redefining the Parameter API for the one and the multi-dim functions. Concrete class should derive from ROOT::Math::IParamFunction and not from this class.

C++ includes: IParamFunction.h
";

%feature("docstring")  ROOT::Math::IBaseParam::~IBaseParam "virtual ROOT::Math::IBaseParam::~IBaseParam()

Virtual Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::IBaseParam::Parameters "virtual const double* ROOT::Math::IBaseParam::Parameters() const =0

Access the parameter values 
";

%feature("docstring")  ROOT::Math::IBaseParam::SetParameters "virtual void ROOT::Math::IBaseParam::SetParameters(const double *p)=0

Set the parameter values

Parameters:
-----------

p: 
vector of doubles containing the parameter values.

to be defined: can user change number of params ? At the moment no. 
";

%feature("docstring")  ROOT::Math::IBaseParam::NPar "virtual unsigned int ROOT::Math::IBaseParam::NPar() const =0

Return the number of Parameters 
";

%feature("docstring")  ROOT::Math::IBaseParam::ParameterName "virtual std::string ROOT::Math::IBaseParam::ParameterName(unsigned int i) const

Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (\"Par_0, Par_1, ...\") 
";


// File: classmumufit_1_1test_1_1IFactory.xml
%feature("docstring") mumufit::test::IFactory "

Base class for all factories.

C++ includes: IFactory.h
";

%feature("docstring")  mumufit::test::IFactory::createItem "AbstractProduct* mumufit::test::IFactory< Key, AbstractProduct >::createItem(const Key &item_key) const

Creates object by calling creation function corresponded to given identifier. 
";

%feature("docstring")  mumufit::test::IFactory::createItemPtr "std::unique_ptr<AbstractProduct> mumufit::test::IFactory< Key, AbstractProduct >::createItemPtr(const Key &item_key) const
";

%feature("docstring")  mumufit::test::IFactory::registerItem "bool mumufit::test::IFactory< Key, AbstractProduct >::registerItem(const Key &item_key, CreateItemCallback CreateFn)

Registers object's creation function. 
";

%feature("docstring")  mumufit::test::IFactory::contains "bool mumufit::test::IFactory< Key, AbstractProduct >::contains(const Key &item_key) const
";

%feature("docstring")  mumufit::test::IFactory::size "size_t mumufit::test::IFactory< Key, AbstractProduct >::size() const

Returns number of registered objects. 
";


// File: classTMVA_1_1IFitterTarget.xml
%feature("docstring") TMVA::IFitterTarget "";

%feature("docstring")  TMVA::IFitterTarget::IFitterTarget "TMVA::IFitterTarget::IFitterTarget()
";

%feature("docstring")  TMVA::IFitterTarget::~IFitterTarget "virtual TMVA::IFitterTarget::~IFitterTarget()
";

%feature("docstring")  TMVA::IFitterTarget::EstimatorFunction "virtual Double_t TMVA::IFitterTarget::EstimatorFunction(std::vector< Double_t > &parameters)=0
";

%feature("docstring")  TMVA::IFitterTarget::ProgressNotifier "virtual void TMVA::IFitterTarget::ProgressNotifier(TString, TString)
";


// File: classmumufit_1_1IFunctionAdapter.xml
%feature("docstring") mumufit::IFunctionAdapter "

Base class for objective function adapters, which converts user functions to minimize into the function which minimization machinery expects.

C++ includes: IFunctionAdapter.h
";

%feature("docstring")  mumufit::IFunctionAdapter::IFunctionAdapter "IFunctionAdapter::IFunctionAdapter()
";

%feature("docstring")  mumufit::IFunctionAdapter::~IFunctionAdapter "IFunctionAdapter::~IFunctionAdapter()
";

%feature("docstring")  mumufit::IFunctionAdapter::numberOfCalls "int IFunctionAdapter::numberOfCalls() const
";

%feature("docstring")  mumufit::IFunctionAdapter::numberOfGradientCalls "int IFunctionAdapter::numberOfGradientCalls() const
";


// File: classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.xml
%feature("docstring") ROOT::Math::IGradientFunctionMultiDimTempl "

Interface (abstract class) for multi-dimensional functions providing a gradient calculation. It implements both the  ROOT::Math::IBaseFunctionMultiDimTempl and  ROOT::Math::IGradientMultiDimTempl interfaces. The method ROOT::Math::IFunction::Gradient calculates the full gradient vector, ROOT::Math::IFunction::Derivative calculates the partial derivative for each coordinate and ROOT::Math::Fdf calculates the gradient and the function value at the same time. The pure private virtual method DoDerivative() must be implemented by the derived classes, while Gradient and FdF are by default implemented using DoDerivative, butthey can be overloaded by the derived classes to improve the efficiency in the derivative calculation.

C++ includes: IFunction.h
";

%feature("docstring")  ROOT::Math::IGradientFunctionMultiDimTempl::~IGradientFunctionMultiDimTempl "virtual ROOT::Math::IGradientFunctionMultiDimTempl< T >::~IGradientFunctionMultiDimTempl()

Virtual Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::IGradientFunctionMultiDimTempl::Gradient "virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::Gradient(const T *x, T *grad) const

Evaluate all the vector of function derivatives (gradient) at a point x. Derived classes must re-implement it if more efficient than evaluting one at a time 
";

%feature("docstring")  ROOT::Math::IGradientFunctionMultiDimTempl::FdF "virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::FdF(const T *x, T &f, T *df) const

Optimized method to evaluate at the same time the function value and derivative at a point x. Often both value and derivatives are needed and it is often more efficient to compute them at the same time. Derived class should implement this method if performances play an important role and if it is faster to evaluate value and derivative at the same time 
";

%feature("docstring")  ROOT::Math::IGradientFunctionMultiDimTempl::NDim "virtual unsigned int ROOT::Math::IBaseFunctionMultiDimTempl< T >::NDim() const=0

Retrieve the dimension of the function 
";


// File: classROOT_1_1Math_1_1IGradientFunctionOneDim.xml
%feature("docstring") ROOT::Math::IGradientFunctionOneDim "

Interface (abstract class) for one-dimensional functions providing a gradient calculation. It implements both the  ROOT::Math::IBaseFunctionOneDim and  ROOT::Math::IGradientOneDim interfaces. The method ROOT::Math::IFunction::Derivative calculates the derivative and ROOT::Math::Fdf calculates the derivative and the function values at the same time. The pure private virtual method DoDerivative() must be implemented by the derived classes, while FdF is by default implemented using DoDerivative, but it can be overloaded by the derived classes to improve the efficiency in the derivative calculation.

C++ includes: IFunction.h
";

%feature("docstring")  ROOT::Math::IGradientFunctionOneDim::~IGradientFunctionOneDim "virtual ROOT::Math::IGradientFunctionOneDim::~IGradientFunctionOneDim()

Virtual Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::IGradientFunctionOneDim::FdF "virtual void ROOT::Math::IGradientFunctionOneDim::FdF(double x, double &f, double &df) const

Optimized method to evaluate at the same time the function value and derivative at a point x. Often both value and derivatives are needed and it is often more efficient to compute them at the same time. Derived class should implement this method if performances play an important role and if it is faster to evaluate value and derivative at the same time 
";


// File: classROOT_1_1Math_1_1IGradientMultiDimTempl.xml
%feature("docstring") ROOT::Math::IGradientMultiDimTempl "

Gradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function. Three methods are provided:
Gradient(const double *x, double * grad) evaluate the full gradient vector at the vector value x

Derivative(const double * x, int icoord) evaluate the partial derivative for the icoord coordinate

FdF(const double *x, double &f, double * g) evaluate at the same time gradient and function/

Concrete classes should derive from ROOT::Math::IGradientFunctionMultiDim and not from this class.

C++ includes: IFunction.h
";

%feature("docstring")  ROOT::Math::IGradientMultiDimTempl::~IGradientMultiDimTempl "virtual ROOT::Math::IGradientMultiDimTempl< T >::~IGradientMultiDimTempl()

virual destructor 
";

%feature("docstring")  ROOT::Math::IGradientMultiDimTempl::Gradient "virtual void ROOT::Math::IGradientMultiDimTempl< T >::Gradient(const T *x, T *grad) const =0

Evaluate all the vector of function derivatives (gradient) at a point x. Derived classes must re-implement if it is more efficient than evaluting one at a time 
";

%feature("docstring")  ROOT::Math::IGradientMultiDimTempl::Derivative "T ROOT::Math::IGradientMultiDimTempl< T >::Derivative(const T *x, unsigned int icoord=0) const

Return the partial derivative with respect to the passed coordinate 
";

%feature("docstring")  ROOT::Math::IGradientMultiDimTempl::FdF "virtual void ROOT::Math::IGradientMultiDimTempl< T >::FdF(const T *x, T &f, T *df) const =0

Optimized method to evaluate at the same time the function value and derivative at a point x. Often both value and derivatives are needed and it is often more efficient to compute them at the same time. Derived class should implement this method if performances play an important role and if it is faster to evaluate value and derivative at the same time 
";


// File: classROOT_1_1Math_1_1IGradientOneDim.xml
%feature("docstring") ROOT::Math::IGradientOneDim "

Specialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF

Concrete classes should derive from  ROOT::Math::IGradientFunctionOneDim and not from this class.

C++ includes: IFunction.h
";

%feature("docstring")  ROOT::Math::IGradientOneDim::~IGradientOneDim "virtual ROOT::Math::IGradientOneDim::~IGradientOneDim()

virtual destructor 
";

%feature("docstring")  ROOT::Math::IGradientOneDim::Derivative "double ROOT::Math::IGradientOneDim::Derivative(double x) const

Return the derivative of the function at a point x Use the private method DoDerivative 
";

%feature("docstring")  ROOT::Math::IGradientOneDim::FdF "virtual void ROOT::Math::IGradientOneDim::FdF(double x, double &f, double &df) const =0

Optimized method to evaluate at the same time the function value and derivative at a point x. Often both value and derivatives are needed and it is often more efficient to compute them at the same time. Derived class should implement this method if performances play an important role and if it is faster to evaluate value and derivative at the same time 
";

%feature("docstring")  ROOT::Math::IGradientOneDim::Derivative "double ROOT::Math::IGradientOneDim::Derivative(const double *x) const

Compatibility method with multi-dimensional interface for partial derivative 
";

%feature("docstring")  ROOT::Math::IGradientOneDim::Gradient "void ROOT::Math::IGradientOneDim::Gradient(const double *x, double *g) const

Compatibility method with multi-dimensional interface for Gradient 
";

%feature("docstring")  ROOT::Math::IGradientOneDim::FdF "void ROOT::Math::IGradientOneDim::FdF(const double *x, double &f, double *df) const

Compatibility method with multi-dimensional interface for Gradient and function evaluation 
";


// File: classIMinimizer.xml
%feature("docstring") IMinimizer "

Abstract base class for all kind minimizers.

C++ includes: IMinimizer.h
";

%feature("docstring")  IMinimizer::IMinimizer "IMinimizer::IMinimizer()
";

%feature("docstring")  IMinimizer::~IMinimizer "IMinimizer::~IMinimizer()
";

%feature("docstring")  IMinimizer::IMinimizer "IMinimizer::IMinimizer(const IMinimizer &other)=delete
";

%feature("docstring")  IMinimizer::minimizerName "virtual std::string IMinimizer::minimizerName() const =0

return name of the minimizer 
";

%feature("docstring")  IMinimizer::algorithmName "virtual std::string IMinimizer::algorithmName() const =0

return name of the minimization algorithm 
";

%feature("docstring")  IMinimizer::minimize_scalar "mumufit::MinimizerResult IMinimizer::minimize_scalar(fcn_scalar_t, mumufit::Parameters)

run minimization 
";

%feature("docstring")  IMinimizer::minimize_residual "mumufit::MinimizerResult IMinimizer::minimize_residual(fcn_residual_t, mumufit::Parameters)
";

%feature("docstring")  IMinimizer::clear "virtual void IMinimizer::clear()

clear resources (parameters) for consecutives minimizations 
";

%feature("docstring")  IMinimizer::minValue "double IMinimizer::minValue() const

Returns minimum function value. 
";

%feature("docstring")  IMinimizer::setOptions "void IMinimizer::setOptions(const std::string &options)

Sets option string to the minimizer. 
";

%feature("docstring")  IMinimizer::requiresResiduals "virtual bool IMinimizer::requiresResiduals()

Returns true if minimizer computations are residual-based, false otherwise. 
";


// File: classROOT_1_1Math_1_1IMinimizer1D.xml
%feature("docstring") ROOT::Math::IMinimizer1D "

Interface class for numerical methods for one-dimensional minimization

C++ includes: IMinimizer1D.h
";

%feature("docstring")  ROOT::Math::IMinimizer1D::IMinimizer1D "ROOT::Math::IMinimizer1D::IMinimizer1D()
";

%feature("docstring")  ROOT::Math::IMinimizer1D::~IMinimizer1D "virtual ROOT::Math::IMinimizer1D::~IMinimizer1D()
";

%feature("docstring")  ROOT::Math::IMinimizer1D::XMinimum "virtual double ROOT::Math::IMinimizer1D::XMinimum() const =0

Return current estimate of the position of the minimum 
";

%feature("docstring")  ROOT::Math::IMinimizer1D::XLower "virtual double ROOT::Math::IMinimizer1D::XLower() const =0

Return current lower bound of the minimization interval 
";

%feature("docstring")  ROOT::Math::IMinimizer1D::XUpper "virtual double ROOT::Math::IMinimizer1D::XUpper() const =0

Return current upper bound of the minimization interval 
";

%feature("docstring")  ROOT::Math::IMinimizer1D::FValMinimum "virtual double ROOT::Math::IMinimizer1D::FValMinimum() const =0

Return function value at current estimate of the minimum 
";

%feature("docstring")  ROOT::Math::IMinimizer1D::FValLower "virtual double ROOT::Math::IMinimizer1D::FValLower() const =0

Return function value at current lower bound of the minimization interval 
";

%feature("docstring")  ROOT::Math::IMinimizer1D::FValUpper "virtual double ROOT::Math::IMinimizer1D::FValUpper() const =0

Return function value at current upper bound of the minimization interval 
";

%feature("docstring")  ROOT::Math::IMinimizer1D::Minimize "virtual bool ROOT::Math::IMinimizer1D::Minimize(int maxIter, double absTol, double relTol)=0

Find minimum position iterating until convergence specified by the absolute and relative tolerance or the maximum number of iteration is reached Return true if iterations converged successfully @param maxIter maximum number of iteration @param absTol desired absolute error in the minimum position @param absTol desired relative error in the minimum position 
";

%feature("docstring")  ROOT::Math::IMinimizer1D::Iterations "virtual int ROOT::Math::IMinimizer1D::Iterations() const =0

Return number of iteration used to find minimum 
";

%feature("docstring")  ROOT::Math::IMinimizer1D::Name "virtual const char* ROOT::Math::IMinimizer1D::Name() const =0

Return name of minimization algorithm 
";

%feature("docstring")  ROOT::Math::IMinimizer1D::Status "virtual int ROOT::Math::IMinimizer1D::Status() const =0

Returns the status of the previous estimate 
";


// File: classROOT_1_1Minuit2_1_1InitialGradientCalculator.xml
%feature("docstring") ROOT::Minuit2::InitialGradientCalculator "

Class to calculate an initial estimate of the gradient

C++ includes: InitialGradientCalculator.h
";

%feature("docstring")  ROOT::Minuit2::InitialGradientCalculator::InitialGradientCalculator "ROOT::Minuit2::InitialGradientCalculator::InitialGradientCalculator(const MnFcn &fcn, const MnUserTransformation &par, const MnStrategy &stra)
";

%feature("docstring")  ROOT::Minuit2::InitialGradientCalculator::~InitialGradientCalculator "virtual ROOT::Minuit2::InitialGradientCalculator::~InitialGradientCalculator()
";

%feature("docstring")  ROOT::Minuit2::InitialGradientCalculator::Fcn "const MnFcn& ROOT::Minuit2::InitialGradientCalculator::Fcn() const
";

%feature("docstring")  ROOT::Minuit2::InitialGradientCalculator::Trafo "const MnUserTransformation& ROOT::Minuit2::InitialGradientCalculator::Trafo() const
";

%feature("docstring")  ROOT::Minuit2::InitialGradientCalculator::Precision "const MnMachinePrecision& ROOT::Minuit2::InitialGradientCalculator::Precision() const
";

%feature("docstring")  ROOT::Minuit2::InitialGradientCalculator::Strategy "const MnStrategy& ROOT::Minuit2::InitialGradientCalculator::Strategy() const
";

%feature("docstring")  ROOT::Minuit2::InitialGradientCalculator::Ncycle "unsigned int ROOT::Minuit2::InitialGradientCalculator::Ncycle() const
";

%feature("docstring")  ROOT::Minuit2::InitialGradientCalculator::StepTolerance "double ROOT::Minuit2::InitialGradientCalculator::StepTolerance() const
";

%feature("docstring")  ROOT::Minuit2::InitialGradientCalculator::GradTolerance "double ROOT::Minuit2::InitialGradientCalculator::GradTolerance() const
";


// File: classROOT_1_1Fit_1_1FitUtil_1_1IntegralEvaluator.xml
%feature("docstring") ROOT::Fit::FitUtil::IntegralEvaluator "";

%feature("docstring")  ROOT::Fit::FitUtil::IntegralEvaluator::IntegralEvaluator "ROOT::Fit::FitUtil::IntegralEvaluator< ParamFunc >::IntegralEvaluator(const ParamFunc &func, const double *p, bool useIntegral=true)
";

%feature("docstring")  ROOT::Fit::FitUtil::IntegralEvaluator::SetFunction "void ROOT::Fit::FitUtil::IntegralEvaluator< ParamFunc >::SetFunction(const ParamFunc &func, const double *p=0)
";

%feature("docstring")  ROOT::Fit::FitUtil::IntegralEvaluator::SetParameters "void ROOT::Fit::FitUtil::IntegralEvaluator< ParamFunc >::SetParameters(const double *p)
";

%feature("docstring")  ROOT::Fit::FitUtil::IntegralEvaluator::~IntegralEvaluator "ROOT::Fit::FitUtil::IntegralEvaluator< ParamFunc >::~IntegralEvaluator()
";

%feature("docstring")  ROOT::Fit::FitUtil::IntegralEvaluator::F1 "double ROOT::Fit::FitUtil::IntegralEvaluator< ParamFunc >::F1(double x) const
";

%feature("docstring")  ROOT::Fit::FitUtil::IntegralEvaluator::FN "double ROOT::Fit::FitUtil::IntegralEvaluator< ParamFunc >::FN(const double *x) const
";

%feature("docstring")  ROOT::Fit::FitUtil::IntegralEvaluator::Integral "double ROOT::Fit::FitUtil::IntegralEvaluator< ParamFunc >::Integral(const double *x1, const double *x2)
";


// File: classTMVA_1_1Interval.xml
%feature("docstring") TMVA::Interval "";

%feature("docstring")  TMVA::Interval::Interval "TMVA::Interval::Interval(Double_t min, Double_t max, Int_t nbins=0)
";

%feature("docstring")  TMVA::Interval::Interval "TMVA::Interval::Interval(const Interval &other)
";

%feature("docstring")  TMVA::Interval::~Interval "virtual TMVA::Interval::~Interval()
";

%feature("docstring")  TMVA::Interval::GetMin "virtual Double_t TMVA::Interval::GetMin() const
";

%feature("docstring")  TMVA::Interval::GetMax "virtual Double_t TMVA::Interval::GetMax() const
";

%feature("docstring")  TMVA::Interval::GetWidth "virtual Double_t TMVA::Interval::GetWidth() const
";

%feature("docstring")  TMVA::Interval::GetNbins "virtual Int_t TMVA::Interval::GetNbins() const
";

%feature("docstring")  TMVA::Interval::GetMean "virtual Double_t TMVA::Interval::GetMean() const
";

%feature("docstring")  TMVA::Interval::GetRndm "virtual Double_t TMVA::Interval::GetRndm(TRandom3 &) const
";

%feature("docstring")  TMVA::Interval::GetElement "virtual Double_t TMVA::Interval::GetElement(Int_t position) const
";

%feature("docstring")  TMVA::Interval::GetStepSize "virtual Double_t TMVA::Interval::GetStepSize(Int_t iBin=0) const
";

%feature("docstring")  TMVA::Interval::SetMax "void TMVA::Interval::SetMax(Double_t m)
";

%feature("docstring")  TMVA::Interval::SetMin "void TMVA::Interval::SetMin(Double_t m)
";

%feature("docstring")  TMVA::Interval::Print "virtual void TMVA::Interval::Print(std::ostream &os) const
";


// File: classROOT_1_1Math_1_1IOptions.xml
%feature("docstring") ROOT::Math::IOptions "

Generic interface for defining configuration options of a numerical algorithm

C++ includes: IOptions.h
";

%feature("docstring")  ROOT::Math::IOptions::IOptions "ROOT::Math::IOptions::IOptions()
";

%feature("docstring")  ROOT::Math::IOptions::~IOptions "virtual ROOT::Math::IOptions::~IOptions()
";

%feature("docstring")  ROOT::Math::IOptions::Clone "virtual IOptions* ROOT::Math::IOptions::Clone() const =0
";

%feature("docstring")  ROOT::Math::IOptions::SetValue "void ROOT::Math::IOptions::SetValue(const char *name, double val)

set option value

generic methods for retrivieng options 
";

%feature("docstring")  ROOT::Math::IOptions::SetValue "void ROOT::Math::IOptions::SetValue(const char *name, int val)
";

%feature("docstring")  ROOT::Math::IOptions::SetValue "void ROOT::Math::IOptions::SetValue(const char *name, const char *val)
";

%feature("docstring")  ROOT::Math::IOptions::RValue "double ROOT::Math::IOptions::RValue(const char *name) const
";

%feature("docstring")  ROOT::Math::IOptions::IValue "int ROOT::Math::IOptions::IValue(const char *name) const
";

%feature("docstring")  ROOT::Math::IOptions::NamedValue "std::string ROOT::Math::IOptions::NamedValue(const char *name) const
";

%feature("docstring")  ROOT::Math::IOptions::GetValue "bool ROOT::Math::IOptions::GetValue(const char *name, T &t) const
";

%feature("docstring")  ROOT::Math::IOptions::GetRealValue "virtual bool ROOT::Math::IOptions::GetRealValue(const char *, double &) const
";

%feature("docstring")  ROOT::Math::IOptions::GetIntValue "virtual bool ROOT::Math::IOptions::GetIntValue(const char *, int &) const
";

%feature("docstring")  ROOT::Math::IOptions::GetNamedValue "virtual bool ROOT::Math::IOptions::GetNamedValue(const char *, std::string &) const
";

%feature("docstring")  ROOT::Math::IOptions::SetRealValue "virtual void ROOT::Math::IOptions::SetRealValue(const char *, double)

method wich need to be re-implemented by the derived classes 
";

%feature("docstring")  ROOT::Math::IOptions::SetIntValue "virtual void ROOT::Math::IOptions::SetIntValue(const char *, int)
";

%feature("docstring")  ROOT::Math::IOptions::SetNamedValue "virtual void ROOT::Math::IOptions::SetNamedValue(const char *, const char *)
";

%feature("docstring")  ROOT::Math::IOptions::Print "virtual void ROOT::Math::IOptions::Print(std::ostream &=std::cout) const

print options 
";


// File: classROOT_1_1Math_1_1IParametricFunctionMultiDimTempl.xml
%feature("docstring") ROOT::Math::IParametricFunctionMultiDimTempl "

IParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and  ROOT::Math::IBaseParam

Provides the interface for evaluating a function passing a coordinate vector and a parameter vector.

C++ includes: IParamFunction.h
";


// File: classROOT_1_1Math_1_1IParametricFunctionOneDim.xml
%feature("docstring") ROOT::Math::IParametricFunctionOneDim "

Specialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from  ROOT::Math::IBaseFunctionOneDim and  ROOT::Math::IBaseParam

C++ includes: IParamFunction.h
";


// File: classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.xml
%feature("docstring") ROOT::Math::IParametricGradFunctionMultiDimTempl "

Interface (abstract class) for parametric gradient multi-dimensional functions providing in addition to function evaluation with respect to the coordinates also the gradient with respect to the parameters, via the method ParameterGradient.

It is a derived class from ROOT::Math::IParametricFunctionMultiDim.

The pure private virtual method DoParameterGradient must be implemented by the derived classes in addition to those inherited by the base abstract classes.

C++ includes: IParamFunction.h
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionMultiDimTempl::~IParametricGradFunctionMultiDimTempl "virtual ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::~IParametricGradFunctionMultiDimTempl()

Virtual Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionMultiDimTempl::ParameterGradient "virtual void ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::ParameterGradient(const T *x, const double *p, T *grad) const

Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x. It is optional to be implemented by the derived classes for better efficiency 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionMultiDimTempl::ParameterDerivative "T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::ParameterDerivative(const T *x, const double *p, unsigned int ipar=0) const

Evaluate the partial derivative w.r.t a parameter ipar from values and parameters 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionMultiDimTempl::ParameterGradient "void ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::ParameterGradient(const T *x, T *grad) const

Evaluate all derivatives using cached parameter values 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionMultiDimTempl::ParameterDerivative "T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::ParameterDerivative(const T *x, unsigned int ipar=0) const

Evaluate partial derivative using cached parameter values 
";


// File: classROOT_1_1Math_1_1IParametricGradFunctionOneDim.xml
%feature("docstring") ROOT::Math::IParametricGradFunctionOneDim "

Interface (abstract class) for parametric one-dimensional gradient functions providing in addition to function evaluation with respect the coordinates also the gradient with respect to the parameters, via the method ParameterGradient.

It is a derived class from  ROOT::Math::IParametricFunctionOneDim.

The pure private virtual method DoParameterGradient must be implemented by the derived classes in addition to those inherited by the base abstract classes.

C++ includes: IParamFunction.h
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionOneDim::~IParametricGradFunctionOneDim "virtual ROOT::Math::IParametricGradFunctionOneDim::~IParametricGradFunctionOneDim()

Virtual Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient "virtual void ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(double x, const double *p, double *grad) const

Evaluate the derivatives of the function with respect to the parameters at a point x. It is optional to be implemented by the derived classes for better efficiency if needed 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient "void ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(double x, double *grad) const

Evaluate all derivatives using cached parameter values 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient "void ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(const double *x, const double *p, double *grad) const

Compatibility interface with multi-dimensional functions 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient "void ROOT::Math::IParametricGradFunctionOneDim::ParameterGradient(const double *x, double *grad) const

Evaluate all derivatives using cached parameter values (multi-dim like interface) 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative "double ROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, const double *p, unsigned int ipar=0) const

Partial derivative with respect a parameter 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative "double ROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, unsigned int ipar=0) const

Evaluate partial derivative using cached parameter values 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative "double ROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double *x, const double *p, unsigned int ipar=0) const

Partial derivative with respect a parameter Compatibility interface with multi-dimensional functions 
";

%feature("docstring")  ROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative "double ROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double *x, unsigned int ipar=0) const

Evaluate partial derivative using cached parameter values (multi-dim like interface) 
";


// File: classROOT_1_1Math_1_1KahanSum.xml
%feature("docstring") ROOT::Math::KahanSum "

The Kahan compensate summation algorithm significantly reduces the numerical error in the total obtained by adding a sequence of finite precision floating point numbers. This is done by keeping a separate running compensation (a variable to accumulate small errors).
 The intial values of the result and the correction are set to the default value of the type it hass been instantiated with.
Examples:

C++ includes: Util.h
";

%feature("docstring")  ROOT::Math::KahanSum::KahanSum "ROOT::Math::KahanSum< T >::KahanSum(const T &initialValue=T{})

Constructor accepting a initial value for the summation as parameter. 
";

%feature("docstring")  ROOT::Math::KahanSum::Add "void ROOT::Math::KahanSum< T >::Add(const T &x)

Single element accumulated addition. 
";

%feature("docstring")  ROOT::Math::KahanSum::Add "void ROOT::Math::KahanSum< T >::Add(const Iterator begin, const Iterator end)

Iterate over a datastructure referenced by a pointer and accumulate on the exising result. 
";

%feature("docstring")  ROOT::Math::KahanSum::Result "T ROOT::Math::KahanSum< T >::Result()

Return the result. 
";


// File: classmumufit_1_1Kernel.xml
%feature("docstring") mumufit::Kernel "

A main class to run fitting.

C++ includes: Kernel.h
";

%feature("docstring")  mumufit::Kernel::Kernel "Kernel::Kernel()
";

%feature("docstring")  mumufit::Kernel::~Kernel "Kernel::~Kernel()
";

%feature("docstring")  mumufit::Kernel::setMinimizer "void Kernel::setMinimizer(const std::string &minimizerName, const std::string &algorithmName=\"\", const std::string &options=\"\")
";

%feature("docstring")  mumufit::Kernel::setMinimizer "void Kernel::setMinimizer(IMinimizer *minimizer)
";

%feature("docstring")  mumufit::Kernel::minimize "MinimizerResult Kernel::minimize(fcn_scalar_t fcn, const Parameters &parameters)
";

%feature("docstring")  mumufit::Kernel::minimize "MinimizerResult Kernel::minimize(fcn_residual_t fcn, const Parameters &parameters)
";


// File: classROOT_1_1Minuit2_1_1LASymMatrix.xml
%feature("docstring") ROOT::Minuit2::LASymMatrix "

Class describing a symmetric matrix of size n. The size is specified as a run-time argument passed in the constructor. The class uses expression templates for the operations and functions. Only the independent data are kept in the fdata array of size n*(n+1)/2 containing the lower triangular data

C++ includes: LASymMatrix.h
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::LASymMatrix "ROOT::Minuit2::LASymMatrix::LASymMatrix(unsigned int n)
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::~LASymMatrix "ROOT::Minuit2::LASymMatrix::~LASymMatrix()
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::LASymMatrix "ROOT::Minuit2::LASymMatrix::LASymMatrix(const LASymMatrix &v)
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::LASymMatrix "ROOT::Minuit2::LASymMatrix::LASymMatrix(const ABObj< sym, LASymMatrix, T > &v)
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::LASymMatrix "ROOT::Minuit2::LASymMatrix::LASymMatrix(const ABObj< sym, ABSum< ABObj< sym, A, T >, ABObj< sym, B, T > >, T > &sum)
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::LASymMatrix "ROOT::Minuit2::LASymMatrix::LASymMatrix(const ABObj< sym, ABSum< ABObj< sym, LASymMatrix, T >, ABObj< sym, A, T > >, T > &sum)
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::LASymMatrix "ROOT::Minuit2::LASymMatrix::LASymMatrix(const ABObj< sym, ABObj< sym, A, T >, T > &something)
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::LASymMatrix "ROOT::Minuit2::LASymMatrix::LASymMatrix(const ABObj< sym, MatrixInverse< sym, ABObj< sym, LASymMatrix, T >, T >, T > &inv)
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::LASymMatrix "ROOT::Minuit2::LASymMatrix::LASymMatrix(const ABObj< sym, ABSum< ABObj< sym, MatrixInverse< sym, ABObj< sym, LASymMatrix, T >, T >, T >, ABObj< sym, A, T > >, T > &sum)
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::LASymMatrix "ROOT::Minuit2::LASymMatrix::LASymMatrix(const ABObj< sym, VectorOuterProduct< ABObj< vec, LAVector, double >, double >, double > &)
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::LASymMatrix "ROOT::Minuit2::LASymMatrix::LASymMatrix(const ABObj< sym, ABSum< ABObj< sym, VectorOuterProduct< ABObj< vec, LAVector, T >, T >, T >, ABObj< sym, A, T > >, T > &sum)
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::Data "const double* ROOT::Minuit2::LASymMatrix::Data() const
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::Data "double* ROOT::Minuit2::LASymMatrix::Data()
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::size "unsigned int ROOT::Minuit2::LASymMatrix::size() const
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::Nrow "unsigned int ROOT::Minuit2::LASymMatrix::Nrow() const
";

%feature("docstring")  ROOT::Minuit2::LASymMatrix::Ncol "unsigned int ROOT::Minuit2::LASymMatrix::Ncol() const
";


// File: classROOT_1_1Minuit2_1_1LAVector.xml
%feature("docstring") ROOT::Minuit2::LAVector "";

%feature("docstring")  ROOT::Minuit2::LAVector::LAVector "ROOT::Minuit2::LAVector::LAVector(unsigned int n)
";

%feature("docstring")  ROOT::Minuit2::LAVector::~LAVector "ROOT::Minuit2::LAVector::~LAVector()
";

%feature("docstring")  ROOT::Minuit2::LAVector::LAVector "ROOT::Minuit2::LAVector::LAVector(const LAVector &v)
";

%feature("docstring")  ROOT::Minuit2::LAVector::LAVector "ROOT::Minuit2::LAVector::LAVector(const ABObj< vec, LAVector, T > &v)
";

%feature("docstring")  ROOT::Minuit2::LAVector::LAVector "ROOT::Minuit2::LAVector::LAVector(const ABObj< vec, ABSum< ABObj< vec, A, T >, ABObj< vec, B, T > >, T > &sum)
";

%feature("docstring")  ROOT::Minuit2::LAVector::LAVector "ROOT::Minuit2::LAVector::LAVector(const ABObj< vec, ABSum< ABObj< vec, LAVector, T >, ABObj< vec, A, T > >, T > &sum)
";

%feature("docstring")  ROOT::Minuit2::LAVector::LAVector "ROOT::Minuit2::LAVector::LAVector(const ABObj< vec, ABObj< vec, A, T >, T > &something)
";

%feature("docstring")  ROOT::Minuit2::LAVector::LAVector "ROOT::Minuit2::LAVector::LAVector(const ABObj< vec, ABProd< ABObj< sym, LASymMatrix, T >, ABObj< vec, LAVector, T > >, T > &prod)
";

%feature("docstring")  ROOT::Minuit2::LAVector::LAVector "ROOT::Minuit2::LAVector::LAVector(const ABObj< vec, ABSum< ABObj< vec, ABProd< ABObj< sym, LASymMatrix, T >, ABObj< vec, LAVector, T > >, T >, ABObj< vec, LAVector, T > >, T > &prod)
";

%feature("docstring")  ROOT::Minuit2::LAVector::Data "const double* ROOT::Minuit2::LAVector::Data() const
";

%feature("docstring")  ROOT::Minuit2::LAVector::Data "double* ROOT::Minuit2::LAVector::Data()
";

%feature("docstring")  ROOT::Minuit2::LAVector::size "unsigned int ROOT::Minuit2::LAVector::size() const
";


// File: classROOT_1_1Fit_1_1FitUtil_1_1LikelihoodAux.xml
%feature("docstring") ROOT::Fit::FitUtil::LikelihoodAux "";

%feature("docstring")  ROOT::Fit::FitUtil::LikelihoodAux::LikelihoodAux "ROOT::Fit::FitUtil::LikelihoodAux< T >::LikelihoodAux(T logv={}, T w={}, T w2={})
";


// File: classROOT_1_1Fit_1_1FitUtil_1_1LikelihoodAux_3_01double_01_4.xml
%feature("docstring") ROOT::Fit::FitUtil::LikelihoodAux< double > "
";

%feature("docstring")  ROOT::Fit::FitUtil::LikelihoodAux< double >::LikelihoodAux "
ROOT::Fit::FitUtil::LikelihoodAux< double >::LikelihoodAux(double logv=0.0, double w=0.0, double w2=0.0)
";


// File: structTMath_1_1Limits.xml
%feature("docstring") TMath::Limits "";


// File: classROOT_1_1Fit_1_1LogLikelihoodFCN.xml
%feature("docstring") ROOT::Fit::LogLikelihoodFCN "

LogLikelihoodFCN class for likelihood fits

it is template to distinguish gradient and non-gradient case

C++ includes: LogLikelihoodFCN.h
";

%feature("docstring")  ROOT::Fit::LogLikelihoodFCN::LogLikelihoodFCN "ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >::LogLikelihoodFCN(const std::shared_ptr< UnBinData > &data, const std::shared_ptr< IModelFunction > &func, int weight=0, bool extended=false, const ::ROOT::Fit::ExecutionPolicy &executionPolicy=::ROOT::Fit::ExecutionPolicy::kSerial)

Constructor from unbin data set and model function (pdf) 
";

%feature("docstring")  ROOT::Fit::LogLikelihoodFCN::LogLikelihoodFCN "ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >::LogLikelihoodFCN(const UnBinData &data, const IModelFunction &func, int weight=0, bool extended=false, const ::ROOT::Fit::ExecutionPolicy &executionPolicy=::ROOT::Fit::ExecutionPolicy::kSerial)

Constructor from unbin data set and model function (pdf) for object managed by users 
";

%feature("docstring")  ROOT::Fit::LogLikelihoodFCN::~LogLikelihoodFCN "virtual ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >::~LogLikelihoodFCN()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Fit::LogLikelihoodFCN::LogLikelihoodFCN "ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >::LogLikelihoodFCN(const LogLikelihoodFCN &f)

Copy constructor 
";

%feature("docstring")  ROOT::Fit::LogLikelihoodFCN::Clone "virtual BaseFunction* ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >::Clone() const

clone the function (need to return Base for Windows) 
";

%feature("docstring")  ROOT::Fit::LogLikelihoodFCN::NFitPoints "virtual unsigned int ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >::NFitPoints() const
";

%feature("docstring")  ROOT::Fit::LogLikelihoodFCN::DataElement "virtual double ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >::DataElement(const double *x, unsigned int i, double *g) const

i-th likelihood contribution and its gradient 
";

%feature("docstring")  ROOT::Fit::LogLikelihoodFCN::Gradient "virtual void ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >::Gradient(const double *x, double *g) const
";

%feature("docstring")  ROOT::Fit::LogLikelihoodFCN::Type "virtual BaseObjFunction::Type_t ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >::Type() const

get type of fit method function 
";

%feature("docstring")  ROOT::Fit::LogLikelihoodFCN::UseSumOfWeightSquare "void ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >::UseSumOfWeightSquare(bool on=true)
";


// File: classROOT_1_1Math_1_1LSResidualFunc.xml
%feature("docstring") ROOT::Math::LSResidualFunc "

LSResidualFunc class description. Internal class used for accessing the residuals of the Least Square function and their derivates which are estimated numerically using GSL numerical derivation. The class contains a pointer to the fit method function and an index specifying the i-th residual and wraps it in a multi-dim gradient function interface ROOT::Math::IGradientFunctionMultiDim. The class is used by  ROOT::Math::GSLNLSMinimizer (GSL non linear least square fitter)

C++ includes: GSLNLSMinimizer.h
";

%feature("docstring")  ROOT::Math::LSResidualFunc::LSResidualFunc "ROOT::Math::LSResidualFunc::LSResidualFunc()
";

%feature("docstring")  ROOT::Math::LSResidualFunc::LSResidualFunc "ROOT::Math::LSResidualFunc::LSResidualFunc(const ROOT::Math::FitMethodFunction &func, unsigned int i)
";

%feature("docstring")  ROOT::Math::LSResidualFunc::LSResidualFunc "ROOT::Math::LSResidualFunc::LSResidualFunc(const LSResidualFunc &rhs)
";

%feature("docstring")  ROOT::Math::LSResidualFunc::Clone "IMultiGenFunction* ROOT::Math::LSResidualFunc::Clone() const

Clone a function. Each derived class must implement their version of the Clone method 
";

%feature("docstring")  ROOT::Math::LSResidualFunc::NDim "unsigned int ROOT::Math::LSResidualFunc::NDim() const

Retrieve the dimension of the function 
";

%feature("docstring")  ROOT::Math::LSResidualFunc::Gradient "void ROOT::Math::LSResidualFunc::Gradient(const double *x, double *g) const
";

%feature("docstring")  ROOT::Math::LSResidualFunc::FdF "void ROOT::Math::LSResidualFunc::FdF(const double *x, double &f, double *g) const
";


// File: classROOT_1_1Minuit2_1_1MatrixInverse.xml
%feature("docstring") ROOT::Minuit2::MatrixInverse "";

%feature("docstring")  ROOT::Minuit2::MatrixInverse::MatrixInverse "ROOT::Minuit2::MatrixInverse< mtype, M, T >::MatrixInverse(const M &obj)
";

%feature("docstring")  ROOT::Minuit2::MatrixInverse::~MatrixInverse "ROOT::Minuit2::MatrixInverse< mtype, M, T >::~MatrixInverse()
";

%feature("docstring")  ROOT::Minuit2::MatrixInverse::Obj "const M& ROOT::Minuit2::MatrixInverse< mtype, M, T >::Obj() const
";


// File: classROOT_1_1Minuit2_1_1MatrixInverse_3_01vec_00_01M_00_01T_01_4.xml
%feature("docstring") ROOT::Minuit2::MatrixInverse< vec, M, T > "
";

%feature("docstring")  ROOT::Minuit2::MatrixInverse< vec, M, T >::~MatrixInverse "
ROOT::Minuit2::MatrixInverse< vec, M, T >::~MatrixInverse()
";

%feature("docstring")  ROOT::Minuit2::MatrixInverse< vec, M, T >::Obj "
const M& ROOT::Minuit2::MatrixInverse< vec, M, T >::Obj() const
";


// File: classROOT_1_1Math_1_1MemFunHandler.xml
%feature("docstring") ROOT::Math::MemFunHandler "

Functor Handler to Wrap pointers to member functions The member function type must be (XXX means any name is allowed) : double XXX ( double x) for 1D functions and double XXXX (const double *x) for multi-dimensional functions

C++ includes: Functor.h
";

%feature("docstring")  ROOT::Math::MemFunHandler::MemFunHandler "ROOT::Math::MemFunHandler< ParentFunctor, PointerToObj, PointerToMemFn >::MemFunHandler(const PointerToObj &pObj, PointerToMemFn pMemFn)

constructor from a pointer to the class and a pointer to the function 
";

%feature("docstring")  ROOT::Math::MemFunHandler::MemFunHandler "ROOT::Math::MemFunHandler< ParentFunctor, PointerToObj, PointerToMemFn >::MemFunHandler(unsigned int dim, const PointerToObj &pObj, PointerToMemFn pMemFn)

constructor from a pointer to the class and a pointer to the function 
";

%feature("docstring")  ROOT::Math::MemFunHandler::~MemFunHandler "virtual ROOT::Math::MemFunHandler< ParentFunctor, PointerToObj, PointerToMemFn >::~MemFunHandler()
";

%feature("docstring")  ROOT::Math::MemFunHandler::Copy "ImplFunc* ROOT::Math::MemFunHandler< ParentFunctor, PointerToObj, PointerToMemFn >::Copy() const
";

%feature("docstring")  ROOT::Math::MemFunHandler::Clone "BaseFunc* ROOT::Math::MemFunHandler< ParentFunctor, PointerToObj, PointerToMemFn >::Clone() const
";

%feature("docstring")  ROOT::Math::MemFunHandler::NDim "unsigned int ROOT::Math::MemFunHandler< ParentFunctor, PointerToObj, PointerToMemFn >::NDim() const
";


// File: classROOT_1_1Math_1_1MemGradFunHandler.xml
%feature("docstring") ROOT::Math::MemGradFunHandler "

Functor Handler to Wrap pointers to member functions for the evaluation of the function and the gradient. The member function type must be (XXX means any name is allowed) : double XXX ( double x) for 1D function and derivative evaluation double XXX (const double *x) for multi-dimensional function evaluation and double XXX (cost double *x, int icoord) for partial derivatives evaluation

C++ includes: Functor.h
";

%feature("docstring")  ROOT::Math::MemGradFunHandler::MemGradFunHandler "ROOT::Math::MemGradFunHandler< ParentFunctor, PointerToObj, PointerToMemFn, PointerToGradMemFn >::MemGradFunHandler(const PointerToObj &pObj, PointerToMemFn pMemFn, PointerToGradMemFn pGradMemFn)

constructor from a pointer to the class and a pointer to the function 
";

%feature("docstring")  ROOT::Math::MemGradFunHandler::MemGradFunHandler "ROOT::Math::MemGradFunHandler< ParentFunctor, PointerToObj, PointerToMemFn, PointerToGradMemFn >::MemGradFunHandler(unsigned int dim, const PointerToObj &pObj, PointerToMemFn pMemFn, PointerToGradMemFn pGradMemFn)

constructor from a pointer to the class and a pointer to the function 
";

%feature("docstring")  ROOT::Math::MemGradFunHandler::~MemGradFunHandler "virtual ROOT::Math::MemGradFunHandler< ParentFunctor, PointerToObj, PointerToMemFn, PointerToGradMemFn >::~MemGradFunHandler()
";

%feature("docstring")  ROOT::Math::MemGradFunHandler::Copy "ImplFunc* ROOT::Math::MemGradFunHandler< ParentFunctor, PointerToObj, PointerToMemFn, PointerToGradMemFn >::Copy() const
";

%feature("docstring")  ROOT::Math::MemGradFunHandler::Clone "BaseFunc* ROOT::Math::MemGradFunHandler< ParentFunctor, PointerToObj, PointerToMemFn, PointerToGradMemFn >::Clone() const
";

%feature("docstring")  ROOT::Math::MemGradFunHandler::NDim "unsigned int ROOT::Math::MemGradFunHandler< ParentFunctor, PointerToObj, PointerToMemFn, PointerToGradMemFn >::NDim() const
";


// File: classMinimize.xml
%feature("docstring") Minimize "";


// File: classmumufit_1_1Minimizer.xml
%feature("docstring") mumufit::Minimizer "

A main class to run fitting.

C++ includes: Minimizer.h
";

%feature("docstring")  mumufit::Minimizer::Minimizer "Minimizer::Minimizer()
";

%feature("docstring")  mumufit::Minimizer::~Minimizer "Minimizer::~Minimizer()
";

%feature("docstring")  mumufit::Minimizer::setMinimizer "void Minimizer::setMinimizer(const std::string &minimizerName, const std::string &algorithmName=\"\", const std::string &options=\"\")
";

%feature("docstring")  mumufit::Minimizer::setMinimizer "void Minimizer::setMinimizer(IMinimizer *minimizer)
";

%feature("docstring")  mumufit::Minimizer::minimize "MinimizerResult Minimizer::minimize(fcn_scalar_t fcn, const Parameters &parameters)
";

%feature("docstring")  mumufit::Minimizer::minimize "MinimizerResult Minimizer::minimize(fcn_residual_t fcn, const Parameters &parameters)
";

%feature("docstring")  mumufit::Minimizer::minimize "MinimizerResult Minimizer::minimize(PyCallback &callback, const Parameters &parameters)

Finds minimum of user objective function (to be called from Python). 
";


// File: classROOT_1_1Math_1_1Minimizer.xml
%feature("docstring") ROOT::Math::Minimizer "

Abstract  Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc..) Plug-in's exist in  ROOT to be able to instantiate the derived classes like  ROOT::Math::GSLMinimizer or ROOT::Math::Minuit2Minimizer via the plug-in manager.

Provides interface for setting the function to be minimized. The function must implemente the multi-dimensional generic interface ROOT::Math::IBaseFunctionMultiDim. If the function provides gradient calculation (implements the ROOT::Math::IGradientFunctionMultiDim interface) this will be used by the  Minimizer.

It Defines also interface for setting the initial values for the function variables (which are the parameters in of the model function in case of solving for fitting) and especifying their limits.

It defines the interface to set and retrieve basic minimization parameters (for specific  Minimizer parameters one must use the derived classes).

Then it defines the interface to retrieve the result of minimization ( minimum X values, function value, gradient, error on the mimnimum, etc...)

C++ includes: Minimizer.h
";

%feature("docstring")  ROOT::Math::Minimizer::Minimizer "ROOT::Math::Minimizer::Minimizer()

Default constructor 
";

%feature("docstring")  ROOT::Math::Minimizer::~Minimizer "virtual ROOT::Math::Minimizer::~Minimizer()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::Minimizer::Clear "virtual void ROOT::Math::Minimizer::Clear()

reset for consecutive minimizations - implement if needed 
";

%feature("docstring")  ROOT::Math::Minimizer::SetFunction "virtual void ROOT::Math::Minimizer::SetFunction(const ROOT::Math::IMultiGenFunction &func)=0

set the function to minimize 
";

%feature("docstring")  ROOT::Math::Minimizer::SetFunction "virtual void ROOT::Math::Minimizer::SetFunction(const ROOT::Math::IMultiGradFunction &func)

set a function to minimize using gradient 
";

%feature("docstring")  ROOT::Math::Minimizer::SetVariables "int ROOT::Math::Minimizer::SetVariables(const VariableIterator &begin, const VariableIterator &end)

add variables . Return number of variables successfully added 
";

%feature("docstring")  ROOT::Math::Minimizer::SetVariable "virtual bool ROOT::Math::Minimizer::SetVariable(unsigned int ivar, const std::string &name, double val, double step)=0

set a new free variable 
";

%feature("docstring")  ROOT::Math::Minimizer::SetLowerLimitedVariable "virtual bool ROOT::Math::Minimizer::SetLowerLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double lower)

set a new lower limit variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Math::Minimizer::SetUpperLimitedVariable "virtual bool ROOT::Math::Minimizer::SetUpperLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double upper)

set a new upper limit variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Math::Minimizer::SetLimitedVariable "virtual bool ROOT::Math::Minimizer::SetLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double lower, double upper)

set a new upper/lower limited variable (override if minimizer supports them ) otherwise as default set an unlimited variable 
";

%feature("docstring")  ROOT::Math::Minimizer::SetFixedVariable "virtual bool ROOT::Math::Minimizer::SetFixedVariable(unsigned int ivar, const std::string &name, double val)

set a new fixed variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Math::Minimizer::SetVariableValue "virtual bool ROOT::Math::Minimizer::SetVariableValue(unsigned int ivar, double value)

set the value of an already existing variable 
";

%feature("docstring")  ROOT::Math::Minimizer::SetVariableValues "virtual bool ROOT::Math::Minimizer::SetVariableValues(const double *x)

set the values of all existing variables (array must be dimensioned to the size of the existing parameters) 
";

%feature("docstring")  ROOT::Math::Minimizer::SetVariableStepSize "virtual bool ROOT::Math::Minimizer::SetVariableStepSize(unsigned int ivar, double value)

set the step size of an already existing variable 
";

%feature("docstring")  ROOT::Math::Minimizer::SetVariableLowerLimit "virtual bool ROOT::Math::Minimizer::SetVariableLowerLimit(unsigned int ivar, double lower)

set the lower-limit of an already existing variable 
";

%feature("docstring")  ROOT::Math::Minimizer::SetVariableUpperLimit "virtual bool ROOT::Math::Minimizer::SetVariableUpperLimit(unsigned int ivar, double upper)

set the upper-limit of an already existing variable 
";

%feature("docstring")  ROOT::Math::Minimizer::SetVariableLimits "virtual bool ROOT::Math::Minimizer::SetVariableLimits(unsigned int ivar, double lower, double upper)

set the limits of an already existing variable 
";

%feature("docstring")  ROOT::Math::Minimizer::FixVariable "virtual bool ROOT::Math::Minimizer::FixVariable(unsigned int ivar)

fix an existing variable 
";

%feature("docstring")  ROOT::Math::Minimizer::ReleaseVariable "virtual bool ROOT::Math::Minimizer::ReleaseVariable(unsigned int ivar)

release an existing variable 
";

%feature("docstring")  ROOT::Math::Minimizer::IsFixedVariable "virtual bool ROOT::Math::Minimizer::IsFixedVariable(unsigned int ivar) const

query if an existing variable is fixed (i.e. considered constant in the minimization) note that by default all variables are not fixed 
";

%feature("docstring")  ROOT::Math::Minimizer::GetVariableSettings "virtual bool ROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings &pars) const

get variable settings in a variable object (like ROOT::Fit::ParamsSettings) 
";

%feature("docstring")  ROOT::Math::Minimizer::SetVariableInitialRange "virtual bool ROOT::Math::Minimizer::SetVariableInitialRange(unsigned int, double, double)

set the initial range of an existing variable 
";

%feature("docstring")  ROOT::Math::Minimizer::Minimize "virtual bool ROOT::Math::Minimizer::Minimize()=0

method to perform the minimization 
";

%feature("docstring")  ROOT::Math::Minimizer::MinValue "virtual double ROOT::Math::Minimizer::MinValue() const =0

return minimum function value 
";

%feature("docstring")  ROOT::Math::Minimizer::X "virtual const double* ROOT::Math::Minimizer::X() const =0

return pointer to X values at the minimum 
";

%feature("docstring")  ROOT::Math::Minimizer::Edm "virtual double ROOT::Math::Minimizer::Edm() const

return expected distance reached from the minimum (re-implement if minimizer provides it 
";

%feature("docstring")  ROOT::Math::Minimizer::MinGradient "virtual const double* ROOT::Math::Minimizer::MinGradient() const

return pointer to gradient values at the minimum 
";

%feature("docstring")  ROOT::Math::Minimizer::NCalls "virtual unsigned int ROOT::Math::Minimizer::NCalls() const

number of function calls to reach the minimum 
";

%feature("docstring")  ROOT::Math::Minimizer::NIterations "virtual unsigned int ROOT::Math::Minimizer::NIterations() const

number of iterations to reach the minimum 
";

%feature("docstring")  ROOT::Math::Minimizer::NDim "virtual unsigned int ROOT::Math::Minimizer::NDim() const =0

this is <= Function(). NDim() which is the total number of variables (free+ constrained ones) 
";

%feature("docstring")  ROOT::Math::Minimizer::NFree "virtual unsigned int ROOT::Math::Minimizer::NFree() const

number of free variables (real dimension of the problem) this is <= Function(). NDim() which is the total (re-implement if minimizer supports bounded parameters) 
";

%feature("docstring")  ROOT::Math::Minimizer::ProvidesError "virtual bool ROOT::Math::Minimizer::ProvidesError() const

minimizer provides error and error matrix 
";

%feature("docstring")  ROOT::Math::Minimizer::Errors "virtual const double* ROOT::Math::Minimizer::Errors() const

return errors at the minimum 
";

%feature("docstring")  ROOT::Math::Minimizer::CovMatrix "virtual double ROOT::Math::Minimizer::CovMatrix(unsigned int ivar, unsigned int jvar) const

return covariance matrices element for variables ivar,jvar if the variable is fixed the return value is zero The ordering of the variables is the same as in the parameter and errors vectors 
";

%feature("docstring")  ROOT::Math::Minimizer::GetCovMatrix "virtual bool ROOT::Math::Minimizer::GetCovMatrix(double *covMat) const

Fill the passed array with the covariance matrix elements if the variable is fixed or const the value is zero. The array will be filled as cov[i *ndim + j] The ordering of the variables is the same as in errors and parameter value. This is different from the direct interface of Minuit2 or TMinuit where the values were obtained only to variable parameters 
";

%feature("docstring")  ROOT::Math::Minimizer::GetHessianMatrix "virtual bool ROOT::Math::Minimizer::GetHessianMatrix(double *hMat) const

Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. The array will be filled as h[i *ndim + j] 
";

%feature("docstring")  ROOT::Math::Minimizer::CovMatrixStatus "virtual int ROOT::Math::Minimizer::CovMatrixStatus() const

return status of covariance matrix using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}  Minimizer who implements covariance matrix calculation will re-implement the method 
";

%feature("docstring")  ROOT::Math::Minimizer::Correlation "virtual double ROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const

return correlation coefficient between variable i and j. If the variable is fixed or const the return value is zero 
";

%feature("docstring")  ROOT::Math::Minimizer::GlobalCC "virtual double ROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const

return global correlation coefficient for variable i This is a number between zero and one which gives the correlation between the i-th parameter and that linear combination of all other parameters which is most strongly correlated with i.  Minimizer must overload method if implemented 
";

%feature("docstring")  ROOT::Math::Minimizer::GetMinosError "virtual bool ROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double &errLow, double &errUp, int option=0)

minos error for variable i, return false if Minos failed or not supported and the lower and upper errors are returned in errLow and errUp An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run (This feature is not yet implemented) 
";

%feature("docstring")  ROOT::Math::Minimizer::Hesse "virtual bool ROOT::Math::Minimizer::Hesse()

perform a full calculation of the Hessian matrix for error calculation 
";

%feature("docstring")  ROOT::Math::Minimizer::Scan "virtual bool ROOT::Math::Minimizer::Scan(unsigned int ivar, unsigned int &nstep, double *x, double *y, double xmin=0, double xmax=0)

scan function minimum for variable i. Variable and function must be set before using Scan Return false if an error or if minimizer does not support this functionality 
";

%feature("docstring")  ROOT::Math::Minimizer::Contour "virtual bool ROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int &npoints, double *xi, double *xj)

find the contour points (xi, xj) of the function for parameter ivar and jvar around the minimum The contour will be find for value of the function = Min + ErrorUp(); 
";

%feature("docstring")  ROOT::Math::Minimizer::PrintResults "virtual void ROOT::Math::Minimizer::PrintResults()

print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing)

return reference to the objective function virtual const ROOT::Math::IGenFunction & Function() const = 0; 
";

%feature("docstring")  ROOT::Math::Minimizer::VariableName "virtual std::string ROOT::Math::Minimizer::VariableName(unsigned int ivar) const

get name of variables (override if minimizer support storing of variable names) return an empty string if variable is not found 
";

%feature("docstring")  ROOT::Math::Minimizer::VariableIndex "virtual int ROOT::Math::Minimizer::VariableIndex(const std::string &name) const

get index of variable given a variable given a name return -1 if variable is not found 
";

%feature("docstring")  ROOT::Math::Minimizer::PrintLevel "int ROOT::Math::Minimizer::PrintLevel() const

set print level

minimizer configuration parameters 
";

%feature("docstring")  ROOT::Math::Minimizer::MaxFunctionCalls "unsigned int ROOT::Math::Minimizer::MaxFunctionCalls() const

max number of function calls 
";

%feature("docstring")  ROOT::Math::Minimizer::MaxIterations "unsigned int ROOT::Math::Minimizer::MaxIterations() const

max iterations 
";

%feature("docstring")  ROOT::Math::Minimizer::Tolerance "double ROOT::Math::Minimizer::Tolerance() const

absolute tolerance 
";

%feature("docstring")  ROOT::Math::Minimizer::Precision "double ROOT::Math::Minimizer::Precision() const

precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) 
";

%feature("docstring")  ROOT::Math::Minimizer::Strategy "int ROOT::Math::Minimizer::Strategy() const

strategy 
";

%feature("docstring")  ROOT::Math::Minimizer::Status "int ROOT::Math::Minimizer::Status() const

status code of minimizer 
";

%feature("docstring")  ROOT::Math::Minimizer::ErrorDef "double ROOT::Math::Minimizer::ErrorDef() const

return the statistical scale used for calculate the error is typically 1 for Chi2 and 0.5 for likelihood minimization 
";

%feature("docstring")  ROOT::Math::Minimizer::IsValidError "bool ROOT::Math::Minimizer::IsValidError() const

return true if  Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) 
";

%feature("docstring")  ROOT::Math::Minimizer::Options "virtual MinimizerOptions ROOT::Math::Minimizer::Options() const

retrieve the minimizer options (implement derived class if needed) 
";

%feature("docstring")  ROOT::Math::Minimizer::SetPrintLevel "void ROOT::Math::Minimizer::SetPrintLevel(int level)

set print level 
";

%feature("docstring")  ROOT::Math::Minimizer::SetMaxFunctionCalls "void ROOT::Math::Minimizer::SetMaxFunctionCalls(unsigned int maxfcn)

set maximum of function calls 
";

%feature("docstring")  ROOT::Math::Minimizer::SetMaxIterations "void ROOT::Math::Minimizer::SetMaxIterations(unsigned int maxiter)

set maximum iterations (one iteration can have many function calls) 
";

%feature("docstring")  ROOT::Math::Minimizer::SetTolerance "void ROOT::Math::Minimizer::SetTolerance(double tol)

set the tolerance 
";

%feature("docstring")  ROOT::Math::Minimizer::SetPrecision "void ROOT::Math::Minimizer::SetPrecision(double prec)

set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. default case) 
";

%feature("docstring")  ROOT::Math::Minimizer::SetStrategy "void ROOT::Math::Minimizer::SetStrategy(int strategyLevel)

set the strategy 
";

%feature("docstring")  ROOT::Math::Minimizer::SetErrorDef "void ROOT::Math::Minimizer::SetErrorDef(double up)

set scale for calculating the errors 
";

%feature("docstring")  ROOT::Math::Minimizer::SetValidError "void ROOT::Math::Minimizer::SetValidError(bool on)

flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit) 
";

%feature("docstring")  ROOT::Math::Minimizer::SetOptions "void ROOT::Math::Minimizer::SetOptions(const MinimizerOptions &opt)

set all options in one go 
";

%feature("docstring")  ROOT::Math::Minimizer::SetDefaultOptions "void ROOT::Math::Minimizer::SetDefaultOptions()

reset the defaut options (defined in  MinimizerOptions) 
";


// File: classMinimizerAdapter.xml
%feature("docstring") MinimizerAdapter "

Abstract base class that adapts the CERN  ROOT minimizer to our  IMinimizer.

C++ includes: MinimizerAdapter.h
";

%feature("docstring")  MinimizerAdapter::~MinimizerAdapter "MinimizerAdapter::~MinimizerAdapter() override
";

%feature("docstring")  MinimizerAdapter::minimize_scalar "MinimizerResult MinimizerAdapter::minimize_scalar(fcn_scalar_t fcn, mumufit::Parameters parameters) override

run minimization 
";

%feature("docstring")  MinimizerAdapter::minimize_residual "MinimizerResult MinimizerAdapter::minimize_residual(fcn_residual_t fcn, mumufit::Parameters parameters) override
";

%feature("docstring")  MinimizerAdapter::minimizerName "std::string MinimizerAdapter::minimizerName() const final

Returns name of the minimizer. 
";

%feature("docstring")  MinimizerAdapter::algorithmName "std::string MinimizerAdapter::algorithmName() const final

Returns name of the minimization algorithm. 
";

%feature("docstring")  MinimizerAdapter::setParameters "void MinimizerAdapter::setParameters(const mumufit::Parameters &parameters)
";

%feature("docstring")  MinimizerAdapter::minValue "double MinimizerAdapter::minValue() const final

Returns minimum function value. 
";

%feature("docstring")  MinimizerAdapter::options "MinimizerOptions& MinimizerAdapter::options()
";

%feature("docstring")  MinimizerAdapter::options "const MinimizerOptions& MinimizerAdapter::options() const
";

%feature("docstring")  MinimizerAdapter::statusToString "std::string MinimizerAdapter::statusToString() const

Returns string representation of current minimizer status. 
";

%feature("docstring")  MinimizerAdapter::providesError "bool MinimizerAdapter::providesError() const

Returns true if minimizer provides error and error matrix. 
";

%feature("docstring")  MinimizerAdapter::statusMap "std::map< std::string, std::string > MinimizerAdapter::statusMap() const

Returns map of string representing different minimizer statuses. 
";

%feature("docstring")  MinimizerAdapter::setOptions "void MinimizerAdapter::setOptions(const std::string &optionString) final

Sets option string to the minimizer. 
";


// File: classMinimizerCatalog.xml
%feature("docstring") MinimizerCatalog "

Hard-coded information about all minimizers available.

C++ includes: MinimizerCatalog.h
";

%feature("docstring")  MinimizerCatalog::MinimizerCatalog "MinimizerCatalog::MinimizerCatalog()
";

%feature("docstring")  MinimizerCatalog::toString "std::string MinimizerCatalog::toString() const

Returns multiline string representing catalog content. 
";

%feature("docstring")  MinimizerCatalog::minimizerNames "std::vector< std::string > MinimizerCatalog::minimizerNames() const
";

%feature("docstring")  MinimizerCatalog::algorithmNames "std::vector< std::string > MinimizerCatalog::algorithmNames(const std::string &minimizerName) const

Returns list of algorithms defined for the minimizer with a given name. 
";

%feature("docstring")  MinimizerCatalog::algorithmDescriptions "std::vector< std::string > MinimizerCatalog::algorithmDescriptions(const std::string &minimizerName) const

Returns list of algorithm's descriptions for the minimizer with a given name . 
";

%feature("docstring")  MinimizerCatalog::minimizerInfo "const MinimizerInfo & MinimizerCatalog::minimizerInfo(const std::string &minimizerName) const

Returns info for minimizer with given name. 
";


// File: classMinimizerFactory.xml
%feature("docstring") MinimizerFactory "

Factory to create minimizers.

C++ includes: MinimizerFactory.h
";


// File: classMinimizerInfo.xml
%feature("docstring") MinimizerInfo "

Info about a minimizer, including list of defined minimization algorithms.

C++ includes: MinimizerInfo.h
";

%feature("docstring")  MinimizerInfo::MinimizerInfo "MinimizerInfo::MinimizerInfo()=delete
";

%feature("docstring")  MinimizerInfo::MinimizerInfo "MinimizerInfo::MinimizerInfo(const std::string &minimizerType, const std::string &minimizerDescription)
";

%feature("docstring")  MinimizerInfo::setAlgorithmName "void MinimizerInfo::setAlgorithmName(const std::string &algorithmName)

Sets currently active algorithm. 
";

%feature("docstring")  MinimizerInfo::name "std::string MinimizerInfo::name() const
";

%feature("docstring")  MinimizerInfo::description "std::string MinimizerInfo::description() const
";

%feature("docstring")  MinimizerInfo::algorithmName "std::string MinimizerInfo::algorithmName() const
";

%feature("docstring")  MinimizerInfo::algorithmNames "std::vector< std::string > MinimizerInfo::algorithmNames() const

Return list of defined algorithm names. 
";

%feature("docstring")  MinimizerInfo::algorithmDescriptions "std::vector< std::string > MinimizerInfo::algorithmDescriptions() const

Returns list of string with description of all available algorithms. 
";


// File: classMinimizerOptions.xml
%feature("docstring") MinimizerOptions "

Collection of internal minimizer settings.

C++ includes: MinimizerOptions.h
";

%feature("docstring")  MinimizerOptions::toOptionString "std::string MinimizerOptions::toOptionString() const

Returns string with all options (i.e. \"Strategy=1;Tolerance=0.01;\") 
";

%feature("docstring")  MinimizerOptions::setOptionString "void MinimizerOptions::setOptionString(const std::string &options)

Set options from their string representation. 
";


// File: classROOT_1_1Math_1_1MinimizerOptions.xml
%feature("docstring") ROOT::Math::MinimizerOptions "

Minimizer options

C++ includes: MinimizerOptions.h
";

%feature("docstring")  ROOT::Math::MinimizerOptions::MinimizerOptions "ROOT::Math::MinimizerOptions::MinimizerOptions()
";

%feature("docstring")  ROOT::Math::MinimizerOptions::~MinimizerOptions "ROOT::Math::MinimizerOptions::~MinimizerOptions()
";

%feature("docstring")  ROOT::Math::MinimizerOptions::MinimizerOptions "ROOT::Math::MinimizerOptions::MinimizerOptions(const MinimizerOptions &opt)
";

%feature("docstring")  ROOT::Math::MinimizerOptions::PrintLevel "int ROOT::Math::MinimizerOptions::PrintLevel() const

set print level

non-static methods for retrieving options 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::MaxFunctionCalls "unsigned int ROOT::Math::MinimizerOptions::MaxFunctionCalls() const

max number of function calls 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::MaxIterations "unsigned int ROOT::Math::MinimizerOptions::MaxIterations() const

max iterations 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::Strategy "int ROOT::Math::MinimizerOptions::Strategy() const

strategy 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::Tolerance "double ROOT::Math::MinimizerOptions::Tolerance() const

absolute tolerance 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::Precision "double ROOT::Math::MinimizerOptions::Precision() const

precision in the objective funciton calculation (value <=0 means left to default) 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::ErrorDef "double ROOT::Math::MinimizerOptions::ErrorDef() const

error definition 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::ExtraOptions "const IOptions* ROOT::Math::MinimizerOptions::ExtraOptions() const

return extra options (NULL pointer if they are not present) 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::MinimizerType "const std::string& ROOT::Math::MinimizerOptions::MinimizerType() const

type of minimizer 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::MinimizerAlgorithm "const std::string& ROOT::Math::MinimizerOptions::MinimizerAlgorithm() const

type of algorithm 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::Print "void ROOT::Math::MinimizerOptions::Print(std::ostream &os=std::cout) const

print all the options 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::ResetToDefaultOptions "void ROOT::Math::MinimizerOptions::ResetToDefaultOptions()

non-static methods for setting options 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::SetPrintLevel "void ROOT::Math::MinimizerOptions::SetPrintLevel(int level)

set print level 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::SetMaxFunctionCalls "void ROOT::Math::MinimizerOptions::SetMaxFunctionCalls(unsigned int maxfcn)

set maximum of function calls 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::SetMaxIterations "void ROOT::Math::MinimizerOptions::SetMaxIterations(unsigned int maxiter)

set maximum iterations (one iteration can have many function calls) 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::SetTolerance "void ROOT::Math::MinimizerOptions::SetTolerance(double tol)

set the tolerance 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::SetPrecision "void ROOT::Math::MinimizerOptions::SetPrecision(double prec)

set the precision 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::SetStrategy "void ROOT::Math::MinimizerOptions::SetStrategy(int stra)

set the strategy 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::SetErrorDef "void ROOT::Math::MinimizerOptions::SetErrorDef(double err)

set error def 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::SetMinimizerType "void ROOT::Math::MinimizerOptions::SetMinimizerType(const char *type)

set minimizer type 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::SetMinimizerAlgorithm "void ROOT::Math::MinimizerOptions::SetMinimizerAlgorithm(const char *type)

set minimizer algorithm 
";

%feature("docstring")  ROOT::Math::MinimizerOptions::SetExtraOptions "void ROOT::Math::MinimizerOptions::SetExtraOptions(const IOptions &opt)

set extra options (in this case pointer is cloned) 
";


// File: classMinimizerOptionsTest.xml
%feature("docstring") MinimizerOptionsTest "";


// File: classmumufit_1_1MinimizerResult.xml
%feature("docstring") mumufit::MinimizerResult "

Result of minimization round.

C++ includes: MinimizerResult.h
";

%feature("docstring")  mumufit::MinimizerResult::MinimizerResult "MinimizerResult::MinimizerResult()
";

%feature("docstring")  mumufit::MinimizerResult::setParameters "void MinimizerResult::setParameters(const Parameters &parameters)
";

%feature("docstring")  mumufit::MinimizerResult::parameters "Parameters MinimizerResult::parameters() const
";

%feature("docstring")  mumufit::MinimizerResult::setMinValue "void MinimizerResult::setMinValue(double value)
";

%feature("docstring")  mumufit::MinimizerResult::minValue "double MinimizerResult::minValue() const

Minimum value of objective function found by minimizer. 
";

%feature("docstring")  mumufit::MinimizerResult::toString "std::string MinimizerResult::toString() const

Returns multi-line string representing minimization results. 
";

%feature("docstring")  mumufit::MinimizerResult::setReport "void MinimizerResult::setReport(const std::string &value)
";

%feature("docstring")  mumufit::MinimizerResult::setDuration "void MinimizerResult::setDuration(double value)
";

%feature("docstring")  mumufit::MinimizerResult::setNumberOfCalls "void MinimizerResult::setNumberOfCalls(int value)
";

%feature("docstring")  mumufit::MinimizerResult::setNumberOfGradientCalls "void MinimizerResult::setNumberOfGradientCalls(int value)
";


// File: classMinimizerTestPlan.xml
%feature("docstring") MinimizerTestPlan "

Defines objective function to fit, expected minimum, initial fit parameters and expected values of fit parameters at minimum.

C++ includes: MinimizerTestPlan.h
";

%feature("docstring")  MinimizerTestPlan::MinimizerTestPlan "MinimizerTestPlan::MinimizerTestPlan(const std::string &name)
";

%feature("docstring")  MinimizerTestPlan::~MinimizerTestPlan "MinimizerTestPlan::~MinimizerTestPlan()
";

%feature("docstring")  MinimizerTestPlan::addParameter "void MinimizerTestPlan::addParameter(const mumufit::Parameter &param, double expected_value, double tolerance=0.01)
";

%feature("docstring")  MinimizerTestPlan::name "std::string MinimizerTestPlan::name() const
";

%feature("docstring")  MinimizerTestPlan::checkMinimizer "virtual bool MinimizerTestPlan::checkMinimizer(mumufit::Minimizer &minimizer)=0

Runs minimization and check minimization result. 
";


// File: classROOT_1_1Math_1_1MinimizerVariableTransformation.xml
%feature("docstring") ROOT::Math::MinimizerVariableTransformation "

Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters

C++ includes: MinimizerVariableTransformation.h
";

%feature("docstring")  ROOT::Math::MinimizerVariableTransformation::~MinimizerVariableTransformation "virtual ROOT::Math::MinimizerVariableTransformation::~MinimizerVariableTransformation()
";

%feature("docstring")  ROOT::Math::MinimizerVariableTransformation::Int2ext "virtual double ROOT::Math::MinimizerVariableTransformation::Int2ext(double value, double lower, double upper) const =0
";

%feature("docstring")  ROOT::Math::MinimizerVariableTransformation::Ext2int "virtual double ROOT::Math::MinimizerVariableTransformation::Ext2int(double value, double lower, double upper) const =0
";

%feature("docstring")  ROOT::Math::MinimizerVariableTransformation::DInt2Ext "virtual double ROOT::Math::MinimizerVariableTransformation::DInt2Ext(double value, double lower, double upper) const =0
";


// File: classROOT_1_1Math_1_1MinimTransformFunction.xml
%feature("docstring") ROOT::Math::MinimTransformFunction "

MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer

C++ includes: MinimTransformFunction.h
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::MinimTransformFunction "ROOT::Math::MinimTransformFunction::MinimTransformFunction(const IMultiGradFunction *f, const std::vector< ROOT::Math::EMinimVariableType > &types, const std::vector< double > &values, const std::map< unsigned int, std::pair< double, double > > &bounds)

Constructor from a IMultiGradFunction interface (which is managed by the class) vector specifying the variable types (free, bounded or fixed, defined in enum EMinimVariableTypes ) variable values (used for the fixed ones) and a map with the bounds (for the bounded variables) 
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::~MinimTransformFunction "ROOT::Math::MinimTransformFunction::~MinimTransformFunction()

Destructor (delete function pointer) 
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::NDim "unsigned int ROOT::Math::MinimTransformFunction::NDim() const

Retrieve the dimension of the function 
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::NTot "unsigned int ROOT::Math::MinimTransformFunction::NTot() const
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::Clone "IMultiGenFunction* ROOT::Math::MinimTransformFunction::Clone() const

clone: not supported (since unique_ptr used in the fVariables) 
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::Transformation "const double* ROOT::Math::MinimTransformFunction::Transformation(const double *x) const

transform from internal to external result is cached also inside the class 
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::Transformation "void ROOT::Math::MinimTransformFunction::Transformation(const double *xint, double *xext) const

transform from internal to external 
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::InvTransformation "void ROOT::Math::MinimTransformFunction::InvTransformation(const double *xext, double *xint) const

inverse transformation (external -> internal) 
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::InvStepTransformation "void ROOT::Math::MinimTransformFunction::InvStepTransformation(const double *x, const double *sext, double *sint) const

inverse transformation for steps (external -> internal) at external point x 
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::GradientTransformation "void ROOT::Math::MinimTransformFunction::GradientTransformation(const double *x, const double *gExt, double *gInt) const

transform gradient vector (external -> internal) at internal point x 
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::MatrixTransformation "void ROOT::Math::MinimTransformFunction::MatrixTransformation(const double *x, const double *covInt, double *covExt) const

transform covariance matrix (internal -> external) at internal point x use row storages for matrices m(i,j) = rep[ i * dim + j] 
";

%feature("docstring")  ROOT::Math::MinimTransformFunction::OriginalFunction "const IMultiGradFunction* ROOT::Math::MinimTransformFunction::OriginalFunction() const
";


// File: classROOT_1_1Math_1_1MinimTransformVariable.xml
%feature("docstring") ROOT::Math::MinimTransformVariable "

MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the  MinimTransformFunction class

C++ includes: MinimTransformVariable.h
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::MinimTransformVariable "ROOT::Math::MinimTransformVariable::MinimTransformVariable()

Default Constructor for an unlimited variable 
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::MinimTransformVariable "ROOT::Math::MinimTransformVariable::MinimTransformVariable(double value)
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::MinimTransformVariable "ROOT::Math::MinimTransformVariable::MinimTransformVariable(double lower, double upper, SinVariableTransformation *trafo)
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::MinimTransformVariable "ROOT::Math::MinimTransformVariable::MinimTransformVariable(double lower, SqrtLowVariableTransformation *trafo)
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::MinimTransformVariable "ROOT::Math::MinimTransformVariable::MinimTransformVariable(double upper, SqrtUpVariableTransformation *trafo)
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::MinimTransformVariable "ROOT::Math::MinimTransformVariable::MinimTransformVariable(const MinimTransformVariable &rhs)
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::IsFixed "bool ROOT::Math::MinimTransformVariable::IsFixed() const
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::IsLimited "bool ROOT::Math::MinimTransformVariable::IsLimited() const
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::HasLowerBound "bool ROOT::Math::MinimTransformVariable::HasLowerBound() const
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::HasUpperBound "bool ROOT::Math::MinimTransformVariable::HasUpperBound() const
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::LowerBound "double ROOT::Math::MinimTransformVariable::LowerBound() const
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::UpperBound "double ROOT::Math::MinimTransformVariable::UpperBound() const
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::FixValue "double ROOT::Math::MinimTransformVariable::FixValue() const
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::InternalToExternal "double ROOT::Math::MinimTransformVariable::InternalToExternal(double x) const
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::DerivativeIntToExt "double ROOT::Math::MinimTransformVariable::DerivativeIntToExt(double x) const
";

%feature("docstring")  ROOT::Math::MinimTransformVariable::ExternalToInternal "double ROOT::Math::MinimTransformVariable::ExternalToInternal(double x) const
";


// File: classROOT_1_1Minuit2_1_1MinimumBuilder.xml
%feature("docstring") ROOT::Minuit2::MinimumBuilder "";

%feature("docstring")  ROOT::Minuit2::MinimumBuilder::MinimumBuilder "ROOT::Minuit2::MinimumBuilder::MinimumBuilder()
";

%feature("docstring")  ROOT::Minuit2::MinimumBuilder::~MinimumBuilder "virtual ROOT::Minuit2::MinimumBuilder::~MinimumBuilder()
";

%feature("docstring")  ROOT::Minuit2::MinimumBuilder::Minimum "virtual FunctionMinimum ROOT::Minuit2::MinimumBuilder::Minimum(const MnFcn &, const GradientCalculator &, const MinimumSeed &, const MnStrategy &, unsigned int, double) const =0
";

%feature("docstring")  ROOT::Minuit2::MinimumBuilder::StorageLevel "int ROOT::Minuit2::MinimumBuilder::StorageLevel() const
";

%feature("docstring")  ROOT::Minuit2::MinimumBuilder::PrintLevel "int ROOT::Minuit2::MinimumBuilder::PrintLevel() const
";

%feature("docstring")  ROOT::Minuit2::MinimumBuilder::TraceIter "bool ROOT::Minuit2::MinimumBuilder::TraceIter() const
";

%feature("docstring")  ROOT::Minuit2::MinimumBuilder::TraceObject "MnTraceObject* ROOT::Minuit2::MinimumBuilder::TraceObject() const
";

%feature("docstring")  ROOT::Minuit2::MinimumBuilder::SetPrintLevel "virtual void ROOT::Minuit2::MinimumBuilder::SetPrintLevel(int level)
";

%feature("docstring")  ROOT::Minuit2::MinimumBuilder::SetStorageLevel "virtual void ROOT::Minuit2::MinimumBuilder::SetStorageLevel(int level)
";

%feature("docstring")  ROOT::Minuit2::MinimumBuilder::SetTraceObject "virtual void ROOT::Minuit2::MinimumBuilder::SetTraceObject(MnTraceObject &obj)
";

%feature("docstring")  ROOT::Minuit2::MinimumBuilder::TraceIteration "void ROOT::Minuit2::MinimumBuilder::TraceIteration(int iter, const MinimumState &state) const
";


// File: classROOT_1_1Minuit2_1_1MinimumError.xml
%feature("docstring") ROOT::Minuit2::MinimumError "

MinimumError keeps the inv. 2nd derivative (inv. Hessian) used for calculating the Parameter step size (-V*g) and for the covariance Update (ErrorUpdator). The covariance matrix is equal to twice the inv. Hessian.

C++ includes: MinimumError.h
";

%feature("docstring")  ROOT::Minuit2::MinimumError::MinimumError "ROOT::Minuit2::MinimumError::MinimumError(unsigned int n)
";

%feature("docstring")  ROOT::Minuit2::MinimumError::MinimumError "ROOT::Minuit2::MinimumError::MinimumError(const MnAlgebraicSymMatrix &mat, double dcov)
";

%feature("docstring")  ROOT::Minuit2::MinimumError::MinimumError "ROOT::Minuit2::MinimumError::MinimumError(const MnAlgebraicSymMatrix &mat, MnHesseFailed)
";

%feature("docstring")  ROOT::Minuit2::MinimumError::MinimumError "ROOT::Minuit2::MinimumError::MinimumError(const MnAlgebraicSymMatrix &mat, MnMadePosDef)
";

%feature("docstring")  ROOT::Minuit2::MinimumError::MinimumError "ROOT::Minuit2::MinimumError::MinimumError(const MnAlgebraicSymMatrix &mat, MnInvertFailed)
";

%feature("docstring")  ROOT::Minuit2::MinimumError::MinimumError "ROOT::Minuit2::MinimumError::MinimumError(const MnAlgebraicSymMatrix &mat, MnNotPosDef)
";

%feature("docstring")  ROOT::Minuit2::MinimumError::~MinimumError "ROOT::Minuit2::MinimumError::~MinimumError()
";

%feature("docstring")  ROOT::Minuit2::MinimumError::MinimumError "ROOT::Minuit2::MinimumError::MinimumError(const MinimumError &e)
";

%feature("docstring")  ROOT::Minuit2::MinimumError::Matrix "MnAlgebraicSymMatrix ROOT::Minuit2::MinimumError::Matrix() const
";

%feature("docstring")  ROOT::Minuit2::MinimumError::InvHessian "const MnAlgebraicSymMatrix& ROOT::Minuit2::MinimumError::InvHessian() const
";

%feature("docstring")  ROOT::Minuit2::MinimumError::Hessian "MnAlgebraicSymMatrix ROOT::Minuit2::MinimumError::Hessian() const
";

%feature("docstring")  ROOT::Minuit2::MinimumError::Dcovar "double ROOT::Minuit2::MinimumError::Dcovar() const
";

%feature("docstring")  ROOT::Minuit2::MinimumError::IsAccurate "bool ROOT::Minuit2::MinimumError::IsAccurate() const
";

%feature("docstring")  ROOT::Minuit2::MinimumError::IsValid "bool ROOT::Minuit2::MinimumError::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::MinimumError::IsPosDef "bool ROOT::Minuit2::MinimumError::IsPosDef() const
";

%feature("docstring")  ROOT::Minuit2::MinimumError::IsMadePosDef "bool ROOT::Minuit2::MinimumError::IsMadePosDef() const
";

%feature("docstring")  ROOT::Minuit2::MinimumError::HesseFailed "bool ROOT::Minuit2::MinimumError::HesseFailed() const
";

%feature("docstring")  ROOT::Minuit2::MinimumError::InvertFailed "bool ROOT::Minuit2::MinimumError::InvertFailed() const
";

%feature("docstring")  ROOT::Minuit2::MinimumError::IsAvailable "bool ROOT::Minuit2::MinimumError::IsAvailable() const
";


// File: classROOT_1_1Minuit2_1_1MinimumErrorUpdator.xml
%feature("docstring") ROOT::Minuit2::MinimumErrorUpdator "";

%feature("docstring")  ROOT::Minuit2::MinimumErrorUpdator::~MinimumErrorUpdator "virtual ROOT::Minuit2::MinimumErrorUpdator::~MinimumErrorUpdator()
";

%feature("docstring")  ROOT::Minuit2::MinimumErrorUpdator::Update "virtual MinimumError ROOT::Minuit2::MinimumErrorUpdator::Update(const MinimumState &, const MinimumParameters &, const FunctionGradient &) const =0
";


// File: classROOT_1_1Minuit2_1_1MinimumParameters.xml
%feature("docstring") ROOT::Minuit2::MinimumParameters "";

%feature("docstring")  ROOT::Minuit2::MinimumParameters::MinimumParameters "ROOT::Minuit2::MinimumParameters::MinimumParameters(unsigned int n, double fval=0)
";

%feature("docstring")  ROOT::Minuit2::MinimumParameters::MinimumParameters "ROOT::Minuit2::MinimumParameters::MinimumParameters(const MnAlgebraicVector &avec, double fval)

takes the Parameter vector 
";

%feature("docstring")  ROOT::Minuit2::MinimumParameters::MinimumParameters "ROOT::Minuit2::MinimumParameters::MinimumParameters(const MnAlgebraicVector &avec, const MnAlgebraicVector &dirin, double fval)

takes the Parameter vector plus step size x1 - x0 = dirin 
";

%feature("docstring")  ROOT::Minuit2::MinimumParameters::~MinimumParameters "ROOT::Minuit2::MinimumParameters::~MinimumParameters()
";

%feature("docstring")  ROOT::Minuit2::MinimumParameters::MinimumParameters "ROOT::Minuit2::MinimumParameters::MinimumParameters(const MinimumParameters &par)
";

%feature("docstring")  ROOT::Minuit2::MinimumParameters::Vec "const MnAlgebraicVector& ROOT::Minuit2::MinimumParameters::Vec() const
";

%feature("docstring")  ROOT::Minuit2::MinimumParameters::Dirin "const MnAlgebraicVector& ROOT::Minuit2::MinimumParameters::Dirin() const
";

%feature("docstring")  ROOT::Minuit2::MinimumParameters::Fval "double ROOT::Minuit2::MinimumParameters::Fval() const
";

%feature("docstring")  ROOT::Minuit2::MinimumParameters::IsValid "bool ROOT::Minuit2::MinimumParameters::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::MinimumParameters::HasStepSize "bool ROOT::Minuit2::MinimumParameters::HasStepSize() const
";


// File: classROOT_1_1Minuit2_1_1MinimumSeed.xml
%feature("docstring") ROOT::Minuit2::MinimumSeed "

MinimumSeed contains the starting values for the minimization produced by the SeedGenerator.

C++ includes: MinimumSeed.h
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::MinimumSeed "ROOT::Minuit2::MinimumSeed::MinimumSeed(const MinimumState &st, const MnUserTransformation &trafo)
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::~MinimumSeed "ROOT::Minuit2::MinimumSeed::~MinimumSeed()
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::MinimumSeed "ROOT::Minuit2::MinimumSeed::MinimumSeed(const MinimumSeed &seed)
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::State "const MinimumState& ROOT::Minuit2::MinimumSeed::State() const
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::Parameters "const MinimumParameters& ROOT::Minuit2::MinimumSeed::Parameters() const
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::Error "const MinimumError& ROOT::Minuit2::MinimumSeed::Error() const
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::Gradient "const FunctionGradient& ROOT::Minuit2::MinimumSeed::Gradient() const
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::Trafo "const MnUserTransformation& ROOT::Minuit2::MinimumSeed::Trafo() const
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::Precision "const MnMachinePrecision& ROOT::Minuit2::MinimumSeed::Precision() const
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::Fval "double ROOT::Minuit2::MinimumSeed::Fval() const
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::Edm "double ROOT::Minuit2::MinimumSeed::Edm() const
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::NFcn "unsigned int ROOT::Minuit2::MinimumSeed::NFcn() const
";

%feature("docstring")  ROOT::Minuit2::MinimumSeed::IsValid "bool ROOT::Minuit2::MinimumSeed::IsValid() const
";


// File: classROOT_1_1Minuit2_1_1MinimumSeedGenerator.xml
%feature("docstring") ROOT::Minuit2::MinimumSeedGenerator "

base class for seed generators (starting values); the seed generator prepares initial starting values from the input ( MnUserParameterState) for the minimization;

C++ includes: MinimumSeedGenerator.h
";

%feature("docstring")  ROOT::Minuit2::MinimumSeedGenerator::~MinimumSeedGenerator "virtual ROOT::Minuit2::MinimumSeedGenerator::~MinimumSeedGenerator()
";


// File: classROOT_1_1Minuit2_1_1MinimumState.xml
%feature("docstring") ROOT::Minuit2::MinimumState "

MinimumState keeps the information (position, Gradient, 2nd deriv, etc) after one minimization step (usually in  MinimumBuilder).

C++ includes: MinimumState.h
";

%feature("docstring")  ROOT::Minuit2::MinimumState::MinimumState "ROOT::Minuit2::MinimumState::MinimumState(unsigned int n)

invalid state 
";

%feature("docstring")  ROOT::Minuit2::MinimumState::MinimumState "ROOT::Minuit2::MinimumState::MinimumState(double fval, double edm, int nfcn)

state without parameters and errors (only function value an, edm and nfcn) 
";

%feature("docstring")  ROOT::Minuit2::MinimumState::MinimumState "ROOT::Minuit2::MinimumState::MinimumState(const MinimumParameters &states, double edm, int nfcn)

state with parameters only (from stepping methods like Simplex, Scan) 
";

%feature("docstring")  ROOT::Minuit2::MinimumState::MinimumState "ROOT::Minuit2::MinimumState::MinimumState(const MinimumParameters &states, const MinimumError &err, const FunctionGradient &grad, double edm, int nfcn)

state with parameters, Gradient and covariance (from Gradient methods such as Migrad) 
";

%feature("docstring")  ROOT::Minuit2::MinimumState::~MinimumState "ROOT::Minuit2::MinimumState::~MinimumState()
";

%feature("docstring")  ROOT::Minuit2::MinimumState::MinimumState "ROOT::Minuit2::MinimumState::MinimumState(const MinimumState &state)
";

%feature("docstring")  ROOT::Minuit2::MinimumState::Parameters "const MinimumParameters& ROOT::Minuit2::MinimumState::Parameters() const
";

%feature("docstring")  ROOT::Minuit2::MinimumState::Vec "const MnAlgebraicVector& ROOT::Minuit2::MinimumState::Vec() const
";

%feature("docstring")  ROOT::Minuit2::MinimumState::size "int ROOT::Minuit2::MinimumState::size() const
";

%feature("docstring")  ROOT::Minuit2::MinimumState::Error "const MinimumError& ROOT::Minuit2::MinimumState::Error() const
";

%feature("docstring")  ROOT::Minuit2::MinimumState::Gradient "const FunctionGradient& ROOT::Minuit2::MinimumState::Gradient() const
";

%feature("docstring")  ROOT::Minuit2::MinimumState::Fval "double ROOT::Minuit2::MinimumState::Fval() const
";

%feature("docstring")  ROOT::Minuit2::MinimumState::Edm "double ROOT::Minuit2::MinimumState::Edm() const
";

%feature("docstring")  ROOT::Minuit2::MinimumState::NFcn "int ROOT::Minuit2::MinimumState::NFcn() const
";

%feature("docstring")  ROOT::Minuit2::MinimumState::IsValid "bool ROOT::Minuit2::MinimumState::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::MinimumState::HasParameters "bool ROOT::Minuit2::MinimumState::HasParameters() const
";

%feature("docstring")  ROOT::Minuit2::MinimumState::HasCovariance "bool ROOT::Minuit2::MinimumState::HasCovariance() const
";


// File: classROOT_1_1Minuit2_1_1MinosError.xml
%feature("docstring") ROOT::Minuit2::MinosError "

Class holding the result of Minos (lower and upper values) for a specific parameter

C++ includes: MinosError.h
";

%feature("docstring")  ROOT::Minuit2::MinosError::MinosError "ROOT::Minuit2::MinosError::MinosError()
";

%feature("docstring")  ROOT::Minuit2::MinosError::MinosError "ROOT::Minuit2::MinosError::MinosError(unsigned int par, double min, const MnCross &low, const MnCross &up)
";

%feature("docstring")  ROOT::Minuit2::MinosError::~MinosError "ROOT::Minuit2::MinosError::~MinosError()
";

%feature("docstring")  ROOT::Minuit2::MinosError::MinosError "ROOT::Minuit2::MinosError::MinosError(const MinosError &err)
";

%feature("docstring")  ROOT::Minuit2::MinosError::Lower "double ROOT::Minuit2::MinosError::Lower() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::Upper "double ROOT::Minuit2::MinosError::Upper() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::Parameter "unsigned int ROOT::Minuit2::MinosError::Parameter() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::LowerState "const MnUserParameterState& ROOT::Minuit2::MinosError::LowerState() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::UpperState "const MnUserParameterState& ROOT::Minuit2::MinosError::UpperState() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::IsValid "bool ROOT::Minuit2::MinosError::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::LowerValid "bool ROOT::Minuit2::MinosError::LowerValid() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::UpperValid "bool ROOT::Minuit2::MinosError::UpperValid() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::AtLowerLimit "bool ROOT::Minuit2::MinosError::AtLowerLimit() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::AtUpperLimit "bool ROOT::Minuit2::MinosError::AtUpperLimit() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::AtLowerMaxFcn "bool ROOT::Minuit2::MinosError::AtLowerMaxFcn() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::AtUpperMaxFcn "bool ROOT::Minuit2::MinosError::AtUpperMaxFcn() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::LowerNewMin "bool ROOT::Minuit2::MinosError::LowerNewMin() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::UpperNewMin "bool ROOT::Minuit2::MinosError::UpperNewMin() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::NFcn "unsigned int ROOT::Minuit2::MinosError::NFcn() const
";

%feature("docstring")  ROOT::Minuit2::MinosError::Min "double ROOT::Minuit2::MinosError::Min() const
";


// File: classMinuit2Minimizer.xml
%feature("docstring") Minuit2Minimizer "

Wrapper for the CERN  ROOT facade of the Minuit2 minimizer. See Minuit2 user manual https://root.cern.ch/root/htmldoc/guides/minuit2/Minuit2.pdf.

C++ includes: Minuit2Minimizer.h
";

%feature("docstring")  Minuit2Minimizer::Minuit2Minimizer "Minuit2Minimizer::Minuit2Minimizer(const std::string &algorithmName=\"Migrad\")
";

%feature("docstring")  Minuit2Minimizer::~Minuit2Minimizer "Minuit2Minimizer::~Minuit2Minimizer()
";

%feature("docstring")  Minuit2Minimizer::setStrategy "void Minuit2Minimizer::setStrategy(int value)

Sets minimization strategy (0-low, 1-medium, 2-high minimization quality). At low quality number of function calls will be economized. 
";

%feature("docstring")  Minuit2Minimizer::strategy "int Minuit2Minimizer::strategy() const
";

%feature("docstring")  Minuit2Minimizer::setErrorDefinition "void Minuit2Minimizer::setErrorDefinition(double value)

Sets error definition factor for parameter error calculation. If objective function (OF) is the usual chisquare function and if the user wants the usual one-standard-deviation errors, then the error definition should be 1.0. If OF is a negative-log-likelihood function, then 0.5. If OF is a chisquare, but the user wants two-standard-deviation errors, 4.0. 
";

%feature("docstring")  Minuit2Minimizer::errorDefinition "double Minuit2Minimizer::errorDefinition() const
";

%feature("docstring")  Minuit2Minimizer::setTolerance "void Minuit2Minimizer::setTolerance(double value)

Sets tolerance on the function value at the minimum. Minimization will stop when the estimated vertical distance to the minimum (EDM) is less than 0.001*tolerance*ErrorDef. Here ErrorDef=1.0 for chi squared fit and ErrorDef=0.5 for negative log likelihood fit. 
";

%feature("docstring")  Minuit2Minimizer::tolerance "double Minuit2Minimizer::tolerance() const
";

%feature("docstring")  Minuit2Minimizer::setPrecision "void Minuit2Minimizer::setPrecision(double value)

Sets relative floating point arithmetic precision. Should be adjusted when the user knows that objectiove function value is not calculated to the nominal machine accuracy. Typical values are between 10^-5 and 10^-14. 
";

%feature("docstring")  Minuit2Minimizer::precision "double Minuit2Minimizer::precision() const
";

%feature("docstring")  Minuit2Minimizer::setPrintLevel "void Minuit2Minimizer::setPrintLevel(int value)

Sets minimizer internal print level. Default value is 0 (silent). 
";

%feature("docstring")  Minuit2Minimizer::printLevel "int Minuit2Minimizer::printLevel() const
";

%feature("docstring")  Minuit2Minimizer::setMaxFunctionCalls "void Minuit2Minimizer::setMaxFunctionCalls(int value)

Sets maximum number of objective function calls. 
";

%feature("docstring")  Minuit2Minimizer::maxFunctionCalls "int Minuit2Minimizer::maxFunctionCalls() const
";

%feature("docstring")  Minuit2Minimizer::statusToString "std::string Minuit2Minimizer::statusToString() const override

Returns string representation of current minimizer status. 
";

%feature("docstring")  Minuit2Minimizer::statusMap "std::map< std::string, std::string > Minuit2Minimizer::statusMap() const override

Returns map of string representing different minimizer statuses. 
";

%feature("docstring")  Minuit2Minimizer::requiresResiduals "bool Minuit2Minimizer::requiresResiduals() override

Returns true if minimizer computations are residual-based, false otherwise. 
";


// File: classROOT_1_1Minuit2_1_1Minuit2Minimizer.xml
%feature("docstring") ROOT::Minuit2::Minuit2Minimizer "

Minuit2Minimizer class implementing the  ROOT::Math::Minimizer interface for Minuit2 minimization algorithm. In  ROOT it can be instantiated using the plug-in manager (plug-in \"Minuit2\") Using a string (used by the plugin manager) or via an enumeration an one can set all the possible minimization algorithms (Migrad, Simplex, Combined, Scan and Fumili).

Refer to the guide for an introduction how Minuit works.

C++ includes: Minuit2Minimizer.h
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::Minuit2Minimizer "ROOT::Minuit2::Minuit2Minimizer::Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type=ROOT::Minuit2::kMigrad)

Default constructor 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::Minuit2Minimizer "ROOT::Minuit2::Minuit2Minimizer::Minuit2Minimizer(const char *type)

Constructor with a char (used by PM) 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::~Minuit2Minimizer "virtual ROOT::Minuit2::Minuit2Minimizer::~Minuit2Minimizer()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::Clear "virtual void ROOT::Minuit2::Minuit2Minimizer::Clear()

reset for consecutive minimizations - implement if needed 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetFunction "virtual void ROOT::Minuit2::Minuit2Minimizer::SetFunction(const ROOT::Math::IMultiGenFunction &func)

set the function to minimize 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetFunction "virtual void ROOT::Minuit2::Minuit2Minimizer::SetFunction(const ROOT::Math::IMultiGradFunction &func)

set gradient the function to minimize 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetVariable "virtual bool ROOT::Minuit2::Minuit2Minimizer::SetVariable(unsigned int ivar, const std::string &name, double val, double step)

set free variable 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetLowerLimitedVariable "virtual bool ROOT::Minuit2::Minuit2Minimizer::SetLowerLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double lower)

set lower limit variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetUpperLimitedVariable "virtual bool ROOT::Minuit2::Minuit2Minimizer::SetUpperLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double upper)

set upper limit variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetLimitedVariable "virtual bool ROOT::Minuit2::Minuit2Minimizer::SetLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double, double)

set upper/lower limited variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetFixedVariable "virtual bool ROOT::Minuit2::Minuit2Minimizer::SetFixedVariable(unsigned int, const std::string &, double)

set fixed variable (override if minimizer supports them ) 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetVariableValue "virtual bool ROOT::Minuit2::Minuit2Minimizer::SetVariableValue(unsigned int ivar, double val)

set variable 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetVariableValues "virtual bool ROOT::Minuit2::Minuit2Minimizer::SetVariableValues(const double *val)

set the values of all existing variables (array must be dimensioned to the size of the existing parameters) 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetVariableStepSize "virtual bool ROOT::Minuit2::Minuit2Minimizer::SetVariableStepSize(unsigned int ivar, double step)

set the step size of an already existing variable 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetVariableLowerLimit "virtual bool ROOT::Minuit2::Minuit2Minimizer::SetVariableLowerLimit(unsigned int ivar, double lower)

set the lower-limit of an already existing variable 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetVariableUpperLimit "virtual bool ROOT::Minuit2::Minuit2Minimizer::SetVariableUpperLimit(unsigned int ivar, double upper)

set the upper-limit of an already existing variable 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetVariableLimits "virtual bool ROOT::Minuit2::Minuit2Minimizer::SetVariableLimits(unsigned int ivar, double lower, double upper)

set the limits of an already existing variable 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::FixVariable "virtual bool ROOT::Minuit2::Minuit2Minimizer::FixVariable(unsigned int ivar)

fix an existing variable 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::ReleaseVariable "virtual bool ROOT::Minuit2::Minuit2Minimizer::ReleaseVariable(unsigned int ivar)

release an existing variable 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::IsFixedVariable "virtual bool ROOT::Minuit2::Minuit2Minimizer::IsFixedVariable(unsigned int ivar) const

query if an existing variable is fixed (i.e. considered constant in the minimization) note that by default all variables are not fixed 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::GetVariableSettings "virtual bool ROOT::Minuit2::Minuit2Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings &varObj) const

get variable settings in a variable object (like ROOT::Fit::ParamsSettings) 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::VariableName "virtual std::string ROOT::Minuit2::Minuit2Minimizer::VariableName(unsigned int ivar) const

get name of variables (override if minimizer support storing of variable names) 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::VariableIndex "virtual int ROOT::Minuit2::Minuit2Minimizer::VariableIndex(const std::string &name) const

get index of variable given a variable given a name return -1 if variable is not found 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::Minimize "virtual bool ROOT::Minuit2::Minuit2Minimizer::Minimize()

method to perform the minimization. Return false in case the minimization did not converge. In this case a status code different than zero is set (retrieved by the derived method Minimizer::Status() )\"

status = 1 : Covariance was made pos defined status = 2 : Hesse is invalid status = 3 : Edm is above max status = 4 : Reached call limit status = 5 : Any other failure 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::MinValue "virtual double ROOT::Minuit2::Minuit2Minimizer::MinValue() const

return minimum function value 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::Edm "virtual double ROOT::Minuit2::Minuit2Minimizer::Edm() const

return expected distance reached from the minimum 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::X "virtual const double* ROOT::Minuit2::Minuit2Minimizer::X() const

return pointer to X values at the minimum 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::MinGradient "virtual const double* ROOT::Minuit2::Minuit2Minimizer::MinGradient() const

return pointer to gradient values at the minimum 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::NCalls "virtual unsigned int ROOT::Minuit2::Minuit2Minimizer::NCalls() const

number of function calls to reach the minimum 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::NDim "virtual unsigned int ROOT::Minuit2::Minuit2Minimizer::NDim() const

this is <= Function(). NDim() which is the total number of variables (free+ constrained ones) 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::NFree "virtual unsigned int ROOT::Minuit2::Minuit2Minimizer::NFree() const

number of free variables (real dimension of the problem) this is <= Function(). NDim() which is the total 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::ProvidesError "virtual bool ROOT::Minuit2::Minuit2Minimizer::ProvidesError() const

minimizer provides error and error matrix 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::Errors "virtual const double* ROOT::Minuit2::Minuit2Minimizer::Errors() const

return errors at the minimum 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::CovMatrix "virtual double ROOT::Minuit2::Minuit2Minimizer::CovMatrix(unsigned int i, unsigned int j) const

return covariance matrix elements if the variable is fixed or const the value is zero The ordering of the variables is the same as in errors and parameter value. This is different from the direct interface of Minuit2 or TMinuit where the values were obtained only to variable parameters 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::GetCovMatrix "virtual bool ROOT::Minuit2::Minuit2Minimizer::GetCovMatrix(double *cov) const

Fill the passed array with the covariance matrix elements if the variable is fixed or const the value is zero. The array will be filled as cov[i *ndim + j] The ordering of the variables is the same as in errors and parameter value. This is different from the direct interface of Minuit2 or TMinuit where the values were obtained only to variable parameters 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::GetHessianMatrix "virtual bool ROOT::Minuit2::Minuit2Minimizer::GetHessianMatrix(double *h) const

Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. The array will be filled as h[i *ndim + j] 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::CovMatrixStatus "virtual int ROOT::Minuit2::Minuit2Minimizer::CovMatrixStatus() const

return the status of the covariance matrix status = -1 : not available (inversion failed or Hesse failed) status = 0 : available but not positive defined status = 1 : covariance only approximate status = 2 : full matrix but forced pos def status = 3 : full accurate matrix 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::Correlation "virtual double ROOT::Minuit2::Minuit2Minimizer::Correlation(unsigned int i, unsigned int j) const

return correlation coefficient between variable i and j. If the variable is fixed or const the return value is zero 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::GlobalCC "virtual double ROOT::Minuit2::Minuit2Minimizer::GlobalCC(unsigned int i) const

get global correlation coefficient for the variable i. This is a number between zero and one which gives the correlation between the i-th variable and that linear combination of all other variables which is most strongly correlated with i. If the variable is fixed or const the return value is zero 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::GetMinosError "virtual bool ROOT::Minuit2::Minuit2Minimizer::GetMinosError(unsigned int i, double &errLow, double &errUp, int=0)

get the minos error for parameter i, return false if Minos failed A minimizaiton must be performed befre, return false if no minimization has been done In case of Minos failed the status error is updated as following status += 10 * minosStatus where the minos status is: status = 1 : maximum number of function calls exceeded when running for lower error status = 2 : maximum number of function calls exceeded when running for upper error status = 3 : new minimum found when running for lower error status = 4 : new minimum found when running for upper error status = 5 : any other failure 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::Scan "virtual bool ROOT::Minuit2::Minuit2Minimizer::Scan(unsigned int i, unsigned int &nstep, double *x, double *y, double xmin=0, double xmax=0)

scan a parameter i around the minimum. A minimization must have been done before, return false if it is not the case 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::Contour "virtual bool ROOT::Minuit2::Minuit2Minimizer::Contour(unsigned int i, unsigned int j, unsigned int &npoints, double *xi, double *xj)

find the contour points (xi,xj) of the function for parameter i and j around the minimum The contour will be find for value of the function = Min + ErrorUp(); 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::Hesse "virtual bool ROOT::Minuit2::Minuit2Minimizer::Hesse()

perform a full calculation of the Hessian matrix for error calculation If a valid minimum exists the calculation is done on the minimum point otherwise is performed in the current set values of parameters Status code of minimizer is updated according to the following convention (in case Hesse failed) status += 100*hesseStatus where hesse status is: status = 1 : hesse failed status = 2 : matrix inversion failed status = 3 : matrix is not pos defined 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::PrintResults "virtual void ROOT::Minuit2::Minuit2Minimizer::PrintResults()

print result of minimization

return reference to the objective function virtual const ROOT::Math::IGenFunction & Function() const; 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetTraceObject "void ROOT::Minuit2::Minuit2Minimizer::SetTraceObject(MnTraceObject &obj)

set an object to trace operation for each iteration The object muust implement operator() (unsigned int,  MinimumState & state) 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::SetStorageLevel "void ROOT::Minuit2::Minuit2Minimizer::SetStorageLevel(int level)

set storage level = 1 : store all iteration states (default) = 0 : store only first and last state to save memory 
";

%feature("docstring")  ROOT::Minuit2::Minuit2Minimizer::State "const ROOT::Minuit2::MnUserParameterState& ROOT::Minuit2::Minuit2Minimizer::State()

return the minimizer state (containing values, step size , etc..) 
";


// File: classROOT_1_1Minuit2_1_1MinuitParameter.xml
%feature("docstring") ROOT::Minuit2::MinuitParameter "

class for the individual Minuit Parameter with Name and number; contains the input numbers for the minimization or the output result from minimization; possible interactions: Fix/release, set/remove limits, set Value/error;

From version 5.20: use string to store the name to avoid limitation of name length of 20 characters

C++ includes: MinuitParameter.h
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::MinuitParameter "ROOT::Minuit2::MinuitParameter::MinuitParameter()
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::MinuitParameter "ROOT::Minuit2::MinuitParameter::MinuitParameter(unsigned int num, const std::string &name, double val)
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::MinuitParameter "ROOT::Minuit2::MinuitParameter::MinuitParameter(unsigned int num, const std::string &name, double val, double err)
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::MinuitParameter "ROOT::Minuit2::MinuitParameter::MinuitParameter(unsigned int num, const std::string &name, double val, double err, double min, double max)
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::~MinuitParameter "ROOT::Minuit2::MinuitParameter::~MinuitParameter()
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::MinuitParameter "ROOT::Minuit2::MinuitParameter::MinuitParameter(const MinuitParameter &par)
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::Number "unsigned int ROOT::Minuit2::MinuitParameter::Number() const
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::GetName "const std::string& ROOT::Minuit2::MinuitParameter::GetName() const
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::Name "const char* ROOT::Minuit2::MinuitParameter::Name() const
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::Value "double ROOT::Minuit2::MinuitParameter::Value() const
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::Error "double ROOT::Minuit2::MinuitParameter::Error() const
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::SetName "void ROOT::Minuit2::MinuitParameter::SetName(const std::string &name)
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::SetValue "void ROOT::Minuit2::MinuitParameter::SetValue(double val)
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::SetError "void ROOT::Minuit2::MinuitParameter::SetError(double err)
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::SetLimits "void ROOT::Minuit2::MinuitParameter::SetLimits(double low, double up)
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::SetUpperLimit "void ROOT::Minuit2::MinuitParameter::SetUpperLimit(double up)
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::SetLowerLimit "void ROOT::Minuit2::MinuitParameter::SetLowerLimit(double low)
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::RemoveLimits "void ROOT::Minuit2::MinuitParameter::RemoveLimits()
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::Fix "void ROOT::Minuit2::MinuitParameter::Fix()
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::Release "void ROOT::Minuit2::MinuitParameter::Release()
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::IsConst "bool ROOT::Minuit2::MinuitParameter::IsConst() const
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::IsFixed "bool ROOT::Minuit2::MinuitParameter::IsFixed() const
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::HasLimits "bool ROOT::Minuit2::MinuitParameter::HasLimits() const
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::HasLowerLimit "bool ROOT::Minuit2::MinuitParameter::HasLowerLimit() const
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::HasUpperLimit "bool ROOT::Minuit2::MinuitParameter::HasUpperLimit() const
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::LowerLimit "double ROOT::Minuit2::MinuitParameter::LowerLimit() const
";

%feature("docstring")  ROOT::Minuit2::MinuitParameter::UpperLimit "double ROOT::Minuit2::MinuitParameter::UpperLimit() const
";


// File: classROOT_1_1Math_1_1MixMaxEngine.xml
%feature("docstring") ROOT::Math::MixMaxEngine "

MixMaxEngine is a wrapper class for the MIXMAX Random number generator.
     MIXMAX is a matrix-recursive random number generator introduced by
     G. Savvidy.

The real implementation of the generator, written in C, is in the mixmax.h and mixmax.cxx files.
     This generator code is available also at hepforge: http://mixmax.hepforge.org
     The MIXMAX code has been created and developed by Konstantin Savvidy and it is 
     released under GNU Lesser General Public License v3.

This wrapper class provides 3 different variants of MIXMAX according to the template para extra parameter N. 
     The extra parameter, `SkipNumber`, is used to perform additional iterations of the generator before returning the random numbers. 
       For example, when `SkipNumber = 2`, the generator will have two extra iterations that will be discarder.

MIXMAX with N = 240. This is a new version of  the generator (version 2.0beta)  described in the 
        <a href=\"http://dx.doi.org/10.1016/j.chaos.2016.05.003\">2016 paper</a> (3rd reference), with 
        special number $s=487013230256099140$, $m=2^{51}+1$ and having a period of $10^{4389}$.

MIXMAX with N = 17, from the 2.0beta version with $s=0$ and $m=2^{36}+1$. The period of the generator is $10^{294}$.

MIXMAX with N = 256 from the 1.0 version. The period is (for `SkipNumber=0`) $10^{4682}$. 
        For this generator we recommend in ROOT using a default value of `SkipNumber=2, while for the previous two generators 
        skipping is not needed.

This table describes the properties of the MIXMAX generators. MIXMAX is a genuine 61 bit generator on the Galois field GF[p], where
       $p=2^{61}-1$ is the Mersenne prime number.
      The MIXMAX generators with these parameters pass all of the BigCrush
      tests in the <a href=\"http://simul.iro.umontreal.ca/testu01/tu01.html\">TestU01 suite</a\\\\>.

\\\\begin{table}[h]
   \\\\centering
     \\\\begin{tabular}{@{} rrlcrr @{}} 
     
      \\\\toprule
      Dimension &~ Entropy & Decorrelation Time &  Iteration Time  & Relaxation Time                                 &Period  q\\\\\\\\
      N     &~~ $~h(T)$   &~~~ $\\\\tau_0 = {1\\\\over h(T) 2N }$ & t & $\\\\tau ={1\\\\over h(T) \\\\ln {1\\\\over \\\\delta v_0}}$ &  $  \\\\log_{10} (q)$  \\\\\\\\ % Crush
      \\\\midrule
      256    & 194   & ~~~~~0.000012     & 1   & 95.00  &   4682\\\\footnote{full
      period is not confirmed}  \\\\\\\\
      \\\\hline
         8   & 220   & $~~~~~0.00028$    & 1   & 1.54   &    129  \\\\\\\\
        17   & 374   & ~~~~~0.000079     & 1   & 1.92   &    294  \\\\\\\\
       240   & 8679  & ~~~~~0.00000024   & 1   & 1.17   &   4389  \\\\\\\\
      \\\\bottomrule
   \\\\end{tabular}
     \\\\caption{The entropy $h(T)$, decorrelation time $\\\\tau_0$ 
       decorrelation time, relaxation time $\\\\tau $ and period of the MIXMAX generator
       \\\\cite{savvidy2017ex,savvidy2017cl},
       expressed in units of the iteration time $t$, which is
       normalised to 1.
       Clearly $\\\\tau_0~ < t ~< \\\\tau $.
}
\\\\end{table}
     The References for MIXMAX are

G.K.Savvidy and N.G.Ter-Arutyunian, *On the Monte Carlo simulation of physical systems,
     J.Comput.Phys. 97, 566 (1991)*;
     Preprint EPI-865-16-86, Yerevan, Jan. 1986

K.Savvidy, *The MIXMAX random number generator*, 
     Comp. Phys. Commun. 196 (2015), pp 161–165
     http://dx.doi.org/10.1016/j.cpc.2015.06.003

K.Savvidy and G.Savvidy, *Spectrum and Entropy of C-systems MIXMAX Random Number Generator*,
     Chaos, Solitons & Fractals, Volume 91, (2016) pp. 33–38
     http://dx.doi.org/10.1016/j.chaos.2016.05.003

@ingroup Random

C++ includes: MixMaxEngine.h
";

%feature("docstring")  ROOT::Math::MixMaxEngine::MixMaxEngine "ROOT::Math::MixMaxEngine< N, SkipNumber >::MixMaxEngine(uint64_t seed=1)
";

%feature("docstring")  ROOT::Math::MixMaxEngine::~MixMaxEngine "virtual ROOT::Math::MixMaxEngine< N, SkipNumber >::~MixMaxEngine()
";

%feature("docstring")  ROOT::Math::MixMaxEngine::SetSeed "void ROOT::Math::MixMaxEngine< N, SkipNumber >::SetSeed(Result_t seed)

set the generator seed 
";

%feature("docstring")  ROOT::Math::MixMaxEngine::Rndm "virtual double ROOT::Math::MixMaxEngine< N, SkipNumber >::Rndm()
";

%feature("docstring")  ROOT::Math::MixMaxEngine::RndmArray "void ROOT::Math::MixMaxEngine< N, SkipNumber >::RndmArray(int n, double *array)

generate an array of random numbers 
";

%feature("docstring")  ROOT::Math::MixMaxEngine::IntRndm "Result_t ROOT::Math::MixMaxEngine< N, SkipNumber >::IntRndm()

generate a 64 bit integer number 
";


// File: classROOT_1_1Math_1_1MixMaxEngineImpl.xml
%feature("docstring") ROOT::Math::MixMaxEngineImpl "";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl::MixMaxEngineImpl "ROOT::Math::MixMaxEngineImpl< N >::MixMaxEngineImpl(uint64_t)
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl::~MixMaxEngineImpl "ROOT::Math::MixMaxEngineImpl< N >::~MixMaxEngineImpl()
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl::SetSeed "void ROOT::Math::MixMaxEngineImpl< N >::SetSeed(uint64_t)
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl::Rndm "double ROOT::Math::MixMaxEngineImpl< N >::Rndm()
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl::IntRndm "double ROOT::Math::MixMaxEngineImpl< N >::IntRndm()
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl::SetState "void ROOT::Math::MixMaxEngineImpl< N >::SetState(const std::vector< uint64_t > &)
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl::GetState "void ROOT::Math::MixMaxEngineImpl< N >::GetState(std::vector< uint64_t > &)
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl::Counter "int ROOT::Math::MixMaxEngineImpl< N >::Counter()
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl::SetCounter "void ROOT::Math::MixMaxEngineImpl< N >::SetCounter(int)
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl::Iterate "void ROOT::Math::MixMaxEngineImpl< N >::Iterate()
";


// File: classROOT_1_1Math_1_1MixMaxEngineImpl_3_01ROOT__MM__N_01_4.xml
%feature("docstring") ROOT::Math::MixMaxEngineImpl< ROOT_MM_N > "
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::MixMaxEngineImpl "
ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::MixMaxEngineImpl(uint64_t seed)
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::~MixMaxEngineImpl "
ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::~MixMaxEngineImpl()
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::SetSeedFast "
void ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::SetSeedFast(Result_t seed)
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::SetSeed "
void ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::SetSeed(Result_t seed)
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::Rndm "
double ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::Rndm()
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::IntRndm "
Result_t ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::IntRndm()
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::SetState "
void ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::SetState(const std::vector< StateInt_t > &state)
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::GetState "
void ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::GetState(std::vector< StateInt_t > &state) const
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::Iterate "
void ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::Iterate()
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::Counter "
int ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::Counter() const
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::SetCounter "
void ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::SetCounter(int val)
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::RndmArray "
void ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::RndmArray(int n, double *array)
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::ReadState "
void ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::ReadState(const char filename[])
";

%feature("docstring")  ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::Branch "
void ROOT::Math::MixMaxEngineImpl< ROOT_MM_N >::Branch(uint32_t *seedvec)
";


// File: classROOT_1_1Minuit2_1_1BasicFunctionMinimum_1_1MnAboveMaxEdm.xml
%feature("docstring") ROOT::Minuit2::BasicFunctionMinimum::MnAboveMaxEdm "";


// File: classROOT_1_1Minuit2_1_1FunctionMinimum_1_1MnAboveMaxEdm.xml
%feature("docstring") ROOT::Minuit2::FunctionMinimum::MnAboveMaxEdm "";


// File: classROOT_1_1Minuit2_1_1MnApplication.xml
%feature("docstring") ROOT::Minuit2::MnApplication "

application interface class for minimizers (migrad, simplex,  Minimize, Scan) User normally instantiates the derived class like  ROOT::Minuit2::MnMigrad for using Migrad for minimization

C++ includes: MnApplication.h
";

%feature("docstring")  ROOT::Minuit2::MnApplication::MnApplication "ROOT::Minuit2::MnApplication::MnApplication(const FCNBase &fcn, const MnUserParameterState &state, const MnStrategy &stra, unsigned int nfcn=0)

constructor from non-gradient functions 
";

%feature("docstring")  ROOT::Minuit2::MnApplication::MnApplication "ROOT::Minuit2::MnApplication::MnApplication(const FCNGradientBase &fcn, const MnUserParameterState &state, const MnStrategy &stra, unsigned int nfcn=0)

constructor from gradient function 
";

%feature("docstring")  ROOT::Minuit2::MnApplication::~MnApplication "virtual ROOT::Minuit2::MnApplication::~MnApplication()
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Minimizer "virtual ModularFunctionMinimizer& ROOT::Minuit2::MnApplication::Minimizer()=0
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Minimizer "virtual const ModularFunctionMinimizer& ROOT::Minuit2::MnApplication::Minimizer() const =0
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Precision "const MnMachinePrecision& ROOT::Minuit2::MnApplication::Precision() const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::State "const MnUserParameterState& ROOT::Minuit2::MnApplication::State() const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Parameters "const MnUserParameters& ROOT::Minuit2::MnApplication::Parameters() const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Covariance "const MnUserCovariance& ROOT::Minuit2::MnApplication::Covariance() const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Fcnbase "virtual const FCNBase& ROOT::Minuit2::MnApplication::Fcnbase() const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Strategy "const MnStrategy& ROOT::Minuit2::MnApplication::Strategy() const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::NumOfCalls "unsigned int ROOT::Minuit2::MnApplication::NumOfCalls() const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::MinuitParameters "const std::vector<ROOT::Minuit2::MinuitParameter>& ROOT::Minuit2::MnApplication::MinuitParameters() const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Params "std::vector<double> ROOT::Minuit2::MnApplication::Params() const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Errors "std::vector<double> ROOT::Minuit2::MnApplication::Errors() const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Parameter "const MinuitParameter& ROOT::Minuit2::MnApplication::Parameter(unsigned int i) const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Add "void ROOT::Minuit2::MnApplication::Add(const char *Name, double val, double err)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Add "void ROOT::Minuit2::MnApplication::Add(const char *Name, double val, double err, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Add "void ROOT::Minuit2::MnApplication::Add(const char *, double)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Fix "void ROOT::Minuit2::MnApplication::Fix(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Release "void ROOT::Minuit2::MnApplication::Release(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::SetValue "void ROOT::Minuit2::MnApplication::SetValue(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::SetError "void ROOT::Minuit2::MnApplication::SetError(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::SetLimits "void ROOT::Minuit2::MnApplication::SetLimits(unsigned int, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::RemoveLimits "void ROOT::Minuit2::MnApplication::RemoveLimits(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Value "double ROOT::Minuit2::MnApplication::Value(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Error "double ROOT::Minuit2::MnApplication::Error(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Fix "void ROOT::Minuit2::MnApplication::Fix(const char *)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Release "void ROOT::Minuit2::MnApplication::Release(const char *)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::SetValue "void ROOT::Minuit2::MnApplication::SetValue(const char *, double)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::SetError "void ROOT::Minuit2::MnApplication::SetError(const char *, double)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::SetLimits "void ROOT::Minuit2::MnApplication::SetLimits(const char *, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::RemoveLimits "void ROOT::Minuit2::MnApplication::RemoveLimits(const char *)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::SetPrecision "void ROOT::Minuit2::MnApplication::SetPrecision(double)
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Value "double ROOT::Minuit2::MnApplication::Value(const char *) const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Error "double ROOT::Minuit2::MnApplication::Error(const char *) const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Index "unsigned int ROOT::Minuit2::MnApplication::Index(const char *) const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Name "const char* ROOT::Minuit2::MnApplication::Name(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Int2ext "double ROOT::Minuit2::MnApplication::Int2ext(unsigned int, double) const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::Ext2int "double ROOT::Minuit2::MnApplication::Ext2int(unsigned int, double) const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::IntOfExt "unsigned int ROOT::Minuit2::MnApplication::IntOfExt(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::ExtOfInt "unsigned int ROOT::Minuit2::MnApplication::ExtOfInt(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnApplication::VariableParameters "unsigned int ROOT::Minuit2::MnApplication::VariableParameters() const
";


// File: classROOT_1_1Minuit2_1_1MnContours.xml
%feature("docstring") ROOT::Minuit2::MnContours "

API class for Contours Error analysis (2-dim errors); minimization has to be done before and Minimum must be valid; possibility to ask only for the points or the points and associated Minos errors;

C++ includes: MnContours.h
";

%feature("docstring")  ROOT::Minuit2::MnContours::MnContours "ROOT::Minuit2::MnContours::MnContours(const FCNBase &fcn, const FunctionMinimum &min)

construct from FCN + Minimum 
";

%feature("docstring")  ROOT::Minuit2::MnContours::MnContours "ROOT::Minuit2::MnContours::MnContours(const FCNBase &fcn, const FunctionMinimum &min, unsigned int stra)

construct from FCN + Minimum + strategy 
";

%feature("docstring")  ROOT::Minuit2::MnContours::MnContours "ROOT::Minuit2::MnContours::MnContours(const FCNBase &fcn, const FunctionMinimum &min, const MnStrategy &stra)

construct from FCN + Minimum + strategy 
";

%feature("docstring")  ROOT::Minuit2::MnContours::~MnContours "ROOT::Minuit2::MnContours::~MnContours()
";

%feature("docstring")  ROOT::Minuit2::MnContours::Contour "ContoursError ROOT::Minuit2::MnContours::Contour(unsigned int, unsigned int, unsigned int npoints=20) const

ask for one Contour  ContoursError (MinosErrors + points) from number of points (>=4) and parameter indeces can be printed via std::cout 
";

%feature("docstring")  ROOT::Minuit2::MnContours::Strategy "const MnStrategy& ROOT::Minuit2::MnContours::Strategy() const
";


// File: classROOT_1_1Minuit2_1_1MnCovarianceSqueeze.xml
%feature("docstring") ROOT::Minuit2::MnCovarianceSqueeze "

class to reduce the covariance matrix when a parameter is fixed by removing the corresponding row and index

C++ includes: MnCovarianceSqueeze.h
";

%feature("docstring")  ROOT::Minuit2::MnCovarianceSqueeze::MnCovarianceSqueeze "ROOT::Minuit2::MnCovarianceSqueeze::MnCovarianceSqueeze()
";

%feature("docstring")  ROOT::Minuit2::MnCovarianceSqueeze::~MnCovarianceSqueeze "ROOT::Minuit2::MnCovarianceSqueeze::~MnCovarianceSqueeze()
";


// File: classROOT_1_1Minuit2_1_1MnCross.xml
%feature("docstring") ROOT::Minuit2::MnCross "";

%feature("docstring")  ROOT::Minuit2::MnCross::MnCross "ROOT::Minuit2::MnCross::MnCross()
";

%feature("docstring")  ROOT::Minuit2::MnCross::MnCross "ROOT::Minuit2::MnCross::MnCross(unsigned int nfcn)
";

%feature("docstring")  ROOT::Minuit2::MnCross::MnCross "ROOT::Minuit2::MnCross::MnCross(const MnUserParameterState &state, unsigned int nfcn)
";

%feature("docstring")  ROOT::Minuit2::MnCross::MnCross "ROOT::Minuit2::MnCross::MnCross(double value, const MnUserParameterState &state, unsigned int nfcn)
";

%feature("docstring")  ROOT::Minuit2::MnCross::MnCross "ROOT::Minuit2::MnCross::MnCross(const MnUserParameterState &state, unsigned int nfcn, CrossParLimit)
";

%feature("docstring")  ROOT::Minuit2::MnCross::MnCross "ROOT::Minuit2::MnCross::MnCross(const MnUserParameterState &state, unsigned int nfcn, CrossFcnLimit)
";

%feature("docstring")  ROOT::Minuit2::MnCross::MnCross "ROOT::Minuit2::MnCross::MnCross(const MnUserParameterState &state, unsigned int nfcn, CrossNewMin)
";

%feature("docstring")  ROOT::Minuit2::MnCross::~MnCross "ROOT::Minuit2::MnCross::~MnCross()
";

%feature("docstring")  ROOT::Minuit2::MnCross::MnCross "ROOT::Minuit2::MnCross::MnCross(const MnCross &cross)
";

%feature("docstring")  ROOT::Minuit2::MnCross::Value "double ROOT::Minuit2::MnCross::Value() const
";

%feature("docstring")  ROOT::Minuit2::MnCross::State "const MnUserParameterState& ROOT::Minuit2::MnCross::State() const
";

%feature("docstring")  ROOT::Minuit2::MnCross::IsValid "bool ROOT::Minuit2::MnCross::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::MnCross::AtLimit "bool ROOT::Minuit2::MnCross::AtLimit() const
";

%feature("docstring")  ROOT::Minuit2::MnCross::AtMaxFcn "bool ROOT::Minuit2::MnCross::AtMaxFcn() const
";

%feature("docstring")  ROOT::Minuit2::MnCross::NewMinimum "bool ROOT::Minuit2::MnCross::NewMinimum() const
";

%feature("docstring")  ROOT::Minuit2::MnCross::NFcn "unsigned int ROOT::Minuit2::MnCross::NFcn() const
";


// File: classROOT_1_1Minuit2_1_1MnEigen.xml
%feature("docstring") ROOT::Minuit2::MnEigen "

API class for calculating the eigenvalues of symmetric matrix

C++ includes: MnEigen.h
";

%feature("docstring")  ROOT::Minuit2::MnEigen::MnEigen "ROOT::Minuit2::MnEigen::MnEigen()
";

%feature("docstring")  ROOT::Minuit2::MnEigen::~MnEigen "ROOT::Minuit2::MnEigen::~MnEigen()
";


// File: classROOT_1_1Minuit2_1_1MnFcn.xml
%feature("docstring") ROOT::Minuit2::MnFcn "

Wrapper class to  FCNBase interface used internally by Minuit. Apply conversion from calling the function from a Minuit Vector (MnAlgebraicVector) to a std::vector for the function coordinates. The class counts also the number of function calls. By default counter strart from zero, but a different value might be given if the class is instantiated later on, for example for a set of different minimizaitons Normally the derived class MnUserFCN should be instantiated with performs in addition the transformatiopn internal-> external parameters

C++ includes: MnFcn.h
";

%feature("docstring")  ROOT::Minuit2::MnFcn::MnFcn "ROOT::Minuit2::MnFcn::MnFcn(const FCNBase &fcn, int ncall=0)

constructor of 
";

%feature("docstring")  ROOT::Minuit2::MnFcn::~MnFcn "virtual ROOT::Minuit2::MnFcn::~MnFcn()
";

%feature("docstring")  ROOT::Minuit2::MnFcn::NumOfCalls "unsigned int ROOT::Minuit2::MnFcn::NumOfCalls() const
";

%feature("docstring")  ROOT::Minuit2::MnFcn::ErrorDef "double ROOT::Minuit2::MnFcn::ErrorDef() const
";

%feature("docstring")  ROOT::Minuit2::MnFcn::Up "double ROOT::Minuit2::MnFcn::Up() const
";

%feature("docstring")  ROOT::Minuit2::MnFcn::Fcn "const FCNBase& ROOT::Minuit2::MnFcn::Fcn() const
";


// File: classROOT_1_1Minuit2_1_1MnFumiliMinimize.xml
%feature("docstring") ROOT::Minuit2::MnFumiliMinimize "

API class for minimization using Fumili technology; allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.; also used by  MnMinos and  MnContours;

C++ includes: MnFumiliMinimize.h
";

%feature("docstring")  ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize "ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize(const FumiliFCNBase &fcn, const std::vector< double > &par, const std::vector< double > &err, unsigned int stra=1)

construct from  FumiliFCNBase + std::vector for parameters and errors 
";

%feature("docstring")  ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize "ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize(const FumiliFCNBase &fcn, const std::vector< double > &par, unsigned int nrow, const std::vector< double > &cov, unsigned int stra=1)

construct from  FumiliFCNBase + std::vector for parameters and covariance 
";

%feature("docstring")  ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize "ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize(const FumiliFCNBase &fcn, const std::vector< double > &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FumiliFCNBase + std::vector for parameters and  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize "ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize(const FumiliFCNBase &fcn, const MnUserParameters &par, unsigned int stra=1)

construct from  FumiliFCNBase +  MnUserParameters
";

%feature("docstring")  ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize "ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize(const FumiliFCNBase &fcn, const MnUserParameters &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FumiliFCNBase +  MnUserParameters +  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize "ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize(const FumiliFCNBase &fcn, const MnUserParameterState &par, const MnStrategy &str)

construct from  FumiliFCNBase +  MnUserParameterState +  MnStrategy
";

%feature("docstring")  ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize "ROOT::Minuit2::MnFumiliMinimize::MnFumiliMinimize(const MnFumiliMinimize &migr)
";

%feature("docstring")  ROOT::Minuit2::MnFumiliMinimize::~MnFumiliMinimize "virtual ROOT::Minuit2::MnFumiliMinimize::~MnFumiliMinimize()
";

%feature("docstring")  ROOT::Minuit2::MnFumiliMinimize::Minimizer "FumiliMinimizer& ROOT::Minuit2::MnFumiliMinimize::Minimizer()
";

%feature("docstring")  ROOT::Minuit2::MnFumiliMinimize::Minimizer "const FumiliMinimizer& ROOT::Minuit2::MnFumiliMinimize::Minimizer() const
";

%feature("docstring")  ROOT::Minuit2::MnFumiliMinimize::Fcnbase "const FumiliFCNBase& ROOT::Minuit2::MnFumiliMinimize::Fcnbase() const
";


// File: classROOT_1_1Minuit2_1_1MnFunctionCross.xml
%feature("docstring") ROOT::Minuit2::MnFunctionCross "

MnFunctionCross

C++ includes: MnFunctionCross.h
";

%feature("docstring")  ROOT::Minuit2::MnFunctionCross::MnFunctionCross "ROOT::Minuit2::MnFunctionCross::MnFunctionCross(const FCNBase &fcn, const MnUserParameterState &state, double fval, const MnStrategy &stra)
";

%feature("docstring")  ROOT::Minuit2::MnFunctionCross::~MnFunctionCross "ROOT::Minuit2::MnFunctionCross::~MnFunctionCross()
";


// File: classROOT_1_1Minuit2_1_1MnGlobalCorrelationCoeff.xml
%feature("docstring") ROOT::Minuit2::MnGlobalCorrelationCoeff "

class for global correlation coefficient

C++ includes: MnGlobalCorrelationCoeff.h
";

%feature("docstring")  ROOT::Minuit2::MnGlobalCorrelationCoeff::MnGlobalCorrelationCoeff "ROOT::Minuit2::MnGlobalCorrelationCoeff::MnGlobalCorrelationCoeff()
";

%feature("docstring")  ROOT::Minuit2::MnGlobalCorrelationCoeff::MnGlobalCorrelationCoeff "ROOT::Minuit2::MnGlobalCorrelationCoeff::MnGlobalCorrelationCoeff(const MnAlgebraicSymMatrix &)
";

%feature("docstring")  ROOT::Minuit2::MnGlobalCorrelationCoeff::~MnGlobalCorrelationCoeff "ROOT::Minuit2::MnGlobalCorrelationCoeff::~MnGlobalCorrelationCoeff()
";

%feature("docstring")  ROOT::Minuit2::MnGlobalCorrelationCoeff::GlobalCC "const std::vector<double>& ROOT::Minuit2::MnGlobalCorrelationCoeff::GlobalCC() const
";

%feature("docstring")  ROOT::Minuit2::MnGlobalCorrelationCoeff::IsValid "bool ROOT::Minuit2::MnGlobalCorrelationCoeff::IsValid() const
";


// File: classROOT_1_1Minuit2_1_1MnHesse.xml
%feature("docstring") ROOT::Minuit2::MnHesse "

API class for calculating the numerical covariance matrix (== 2x Inverse Hessian == 2x Inverse 2nd derivative); can be used by the user or Minuit itself

C++ includes: MnHesse.h
";

%feature("docstring")  ROOT::Minuit2::MnHesse::MnHesse "ROOT::Minuit2::MnHesse::MnHesse()

default constructor with default strategy 
";

%feature("docstring")  ROOT::Minuit2::MnHesse::MnHesse "ROOT::Minuit2::MnHesse::MnHesse(unsigned int stra)

constructor with user-defined strategy level 
";

%feature("docstring")  ROOT::Minuit2::MnHesse::MnHesse "ROOT::Minuit2::MnHesse::MnHesse(const MnStrategy &stra)

conctructor with specific strategy 
";

%feature("docstring")  ROOT::Minuit2::MnHesse::~MnHesse "ROOT::Minuit2::MnHesse::~MnHesse()
";

%feature("docstring")  ROOT::Minuit2::MnHesse::Ncycles "unsigned int ROOT::Minuit2::MnHesse::Ncycles() const

forward interface of  MnStrategy
";

%feature("docstring")  ROOT::Minuit2::MnHesse::Tolerstp "double ROOT::Minuit2::MnHesse::Tolerstp() const
";

%feature("docstring")  ROOT::Minuit2::MnHesse::TolerG2 "double ROOT::Minuit2::MnHesse::TolerG2() const
";


// File: classROOT_1_1Minuit2_1_1BasicMinimumError_1_1MnHesseFailed.xml
%feature("docstring") ROOT::Minuit2::BasicMinimumError::MnHesseFailed "";


// File: classROOT_1_1Minuit2_1_1MinimumError_1_1MnHesseFailed.xml
%feature("docstring") ROOT::Minuit2::MinimumError::MnHesseFailed "";


// File: classROOT_1_1Minuit2_1_1BasicMinimumError_1_1MnInvertFailed.xml
%feature("docstring") ROOT::Minuit2::BasicMinimumError::MnInvertFailed "";


// File: classROOT_1_1Minuit2_1_1MinimumError_1_1MnInvertFailed.xml
%feature("docstring") ROOT::Minuit2::MinimumError::MnInvertFailed "";


// File: classROOT_1_1Minuit2_1_1MnLineSearch.xml
%feature("docstring") ROOT::Minuit2::MnLineSearch "

Implements a 1-dimensional minimization along a given direction (i.e. quadratic interpolation) It is independent of the algorithm that generates the direction vector. It brackets the 1-dimensional Minimum and iterates to approach the real Minimum of the n-dimensional function.

Fred James and Matthias Winkler; comments added by Andras Zsenei and Lorenzo Moneta

C++ includes: MnLineSearch.h
";

%feature("docstring")  ROOT::Minuit2::MnLineSearch::MnLineSearch "ROOT::Minuit2::MnLineSearch::MnLineSearch()
";

%feature("docstring")  ROOT::Minuit2::MnLineSearch::~MnLineSearch "ROOT::Minuit2::MnLineSearch::~MnLineSearch()
";


// File: classROOT_1_1Minuit2_1_1MnMachinePrecision.xml
%feature("docstring") ROOT::Minuit2::MnMachinePrecision "

determines the relative floating point arithmetic precision. The  SetPrecision() method can be used to override Minuit's own determination, when the user knows that the {FCN} function Value is not calculated to the nominal machine accuracy.

C++ includes: MnMachinePrecision.h
";

%feature("docstring")  ROOT::Minuit2::MnMachinePrecision::MnMachinePrecision "ROOT::Minuit2::MnMachinePrecision::MnMachinePrecision()
";

%feature("docstring")  ROOT::Minuit2::MnMachinePrecision::~MnMachinePrecision "ROOT::Minuit2::MnMachinePrecision::~MnMachinePrecision()
";

%feature("docstring")  ROOT::Minuit2::MnMachinePrecision::MnMachinePrecision "ROOT::Minuit2::MnMachinePrecision::MnMachinePrecision(const MnMachinePrecision &prec)
";

%feature("docstring")  ROOT::Minuit2::MnMachinePrecision::Eps "double ROOT::Minuit2::MnMachinePrecision::Eps() const

eps returns the smallest possible number so that 1.+eps > 1. 
";

%feature("docstring")  ROOT::Minuit2::MnMachinePrecision::Eps2 "double ROOT::Minuit2::MnMachinePrecision::Eps2() const

eps2 returns 2*sqrt(eps) 
";

%feature("docstring")  ROOT::Minuit2::MnMachinePrecision::SetPrecision "void ROOT::Minuit2::MnMachinePrecision::SetPrecision(double prec)

override Minuit's own determination 
";


// File: classROOT_1_1Minuit2_1_1BasicMinimumError_1_1MnMadePosDef.xml
%feature("docstring") ROOT::Minuit2::BasicMinimumError::MnMadePosDef "";


// File: classROOT_1_1Minuit2_1_1MinimumError_1_1MnMadePosDef.xml
%feature("docstring") ROOT::Minuit2::MinimumError::MnMadePosDef "";


// File: classROOT_1_1Minuit2_1_1MnMigrad.xml
%feature("docstring") ROOT::Minuit2::MnMigrad "

API class for minimization using Variable Metric technology (\"MIGRAD\"); allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.; also used by  MnMinos and  MnContours;

C++ includes: MnMigrad.h
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNBase &fcn, const std::vector< double > &par, const std::vector< double > &err, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and errors 
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNBase &fcn, const std::vector< double > &par, unsigned int nrow, const std::vector< double > &cov, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and covariance 
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNBase &fcn, const std::vector< double > &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNBase &fcn, const MnUserParameters &par, unsigned int stra=1)

construct from  FCNBase +  MnUserParameters
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNBase &fcn, const MnUserParameters &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNBase +  MnUserParameters +  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNBase &fcn, const MnUserParameterState &par, const MnStrategy &str)

construct from  FCNBase +  MnUserParameterState +  MnStrategy
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNGradientBase &fcn, const std::vector< double > &par, const std::vector< double > &err, unsigned int stra=1)

construct from  FCNGradientBase + std::vector for parameters and errors 
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNGradientBase &fcn, const std::vector< double > &par, unsigned int nrow, const std::vector< double > &cov, unsigned int stra=1)

construct from  FCNGradientBase + std::vector for parameters and covariance 
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNGradientBase &fcn, const std::vector< double > &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNGradientBase + std::vector for parameters and  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNGradientBase &fcn, const MnUserParameters &par, unsigned int stra=1)

construct from  FCNGradientBase +  MnUserParameters
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNGradientBase &fcn, const MnUserParameters &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNGradientBase +  MnUserParameters +  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const FCNGradientBase &fcn, const MnUserParameterState &par, const MnStrategy &str)

construct from  FCNGradientBase +  MnUserParameterState +  MnStrategy
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::MnMigrad "ROOT::Minuit2::MnMigrad::MnMigrad(const MnMigrad &migr)
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::~MnMigrad "ROOT::Minuit2::MnMigrad::~MnMigrad()
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::Minimizer "ModularFunctionMinimizer& ROOT::Minuit2::MnMigrad::Minimizer()
";

%feature("docstring")  ROOT::Minuit2::MnMigrad::Minimizer "const ModularFunctionMinimizer& ROOT::Minuit2::MnMigrad::Minimizer() const
";


// File: classROOT_1_1Minuit2_1_1MnMinimize.xml
%feature("docstring") ROOT::Minuit2::MnMinimize "

API class for minimization using Variable Metric technology (\"MIGRAD\"); allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.; also used by  MnMinos and  MnContours;

C++ includes: MnMinimize.h
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNBase &fcn, const std::vector< double > &par, const std::vector< double > &err, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and errors 
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNBase &fcn, const std::vector< double > &par, unsigned int nrow, const std::vector< double > &cov, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and covariance 
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNBase &fcn, const std::vector< double > &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNBase &fcn, const MnUserParameters &par, unsigned int stra=1)

construct from  FCNBase +  MnUserParameters
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNBase &fcn, const MnUserParameters &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNBase +  MnUserParameters +  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNBase &fcn, const MnUserParameterState &par, const MnStrategy &str)

construct from  FCNBase +  MnUserParameterState +  MnStrategy
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNGradientBase &fcn, const std::vector< double > &par, const std::vector< double > &err, unsigned int stra=1)

construct from  FCNGradientBase + std::vector for parameters and errors 
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNGradientBase &fcn, const std::vector< double > &par, unsigned int nrow, const std::vector< double > &cov, unsigned int stra=1)

construct from  FCNGradientBase + std::vector for parameters and covariance 
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNGradientBase &fcn, const std::vector< double > &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNGradientBase + std::vector for parameters and  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNGradientBase &fcn, const MnUserParameters &par, unsigned int stra=1)

construct from  FCNGradientBase +  MnUserParameters
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNGradientBase &fcn, const MnUserParameters &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNGradientBase +  MnUserParameters +  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const FCNGradientBase &fcn, const MnUserParameterState &par, const MnStrategy &str)

construct from  FCNGradientBase +  MnUserParameterState +  MnStrategy
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::MnMinimize "ROOT::Minuit2::MnMinimize::MnMinimize(const MnMinimize &migr)
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::~MnMinimize "ROOT::Minuit2::MnMinimize::~MnMinimize()
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::Minimizer "ModularFunctionMinimizer& ROOT::Minuit2::MnMinimize::Minimizer()
";

%feature("docstring")  ROOT::Minuit2::MnMinimize::Minimizer "const ModularFunctionMinimizer& ROOT::Minuit2::MnMinimize::Minimizer() const
";


// File: classROOT_1_1Minuit2_1_1MnMinos.xml
%feature("docstring") ROOT::Minuit2::MnMinos "

API class for Minos Error analysis (asymmetric errors); minimization has to be done before and Minimum must be valid; possibility to ask only for one side of the Minos Error;

C++ includes: MnMinos.h
";

%feature("docstring")  ROOT::Minuit2::MnMinos::MnMinos "ROOT::Minuit2::MnMinos::MnMinos(const FCNBase &fcn, const FunctionMinimum &min, unsigned int stra=1)

construct from FCN + Minimum + strategy 
";

%feature("docstring")  ROOT::Minuit2::MnMinos::MnMinos "ROOT::Minuit2::MnMinos::MnMinos(const FCNBase &fcn, const FunctionMinimum &min, const MnStrategy &stra)

construct from FCN + Minimum + strategy 
";

%feature("docstring")  ROOT::Minuit2::MnMinos::~MnMinos "ROOT::Minuit2::MnMinos::~MnMinos()
";

%feature("docstring")  ROOT::Minuit2::MnMinos::Lower "double ROOT::Minuit2::MnMinos::Lower(unsigned int, unsigned int maxcalls=0, double toler=0.1) const

calculate one side (negative or positive Error) of the Parameter give as input (optionally) maxcalls and tolerance 
";

%feature("docstring")  ROOT::Minuit2::MnMinos::Upper "double ROOT::Minuit2::MnMinos::Upper(unsigned int, unsigned int maxcalls=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::MnMinos::Loval "MnCross ROOT::Minuit2::MnMinos::Loval(unsigned int, unsigned int maxcalls=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::MnMinos::Upval "MnCross ROOT::Minuit2::MnMinos::Upval(unsigned int, unsigned int maxcalls=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::MnMinos::Minos "MinosError ROOT::Minuit2::MnMinos::Minos(unsigned int, unsigned int maxcalls=0, double toler=0.1) const

ask for  MinosError (Lower + Upper) can be printed via std::cout 
";


// File: classROOT_1_1Minuit2_1_1MinimumError_1_1MnNotPosDef.xml
%feature("docstring") ROOT::Minuit2::MinimumError::MnNotPosDef "";


// File: classROOT_1_1Minuit2_1_1BasicMinimumError_1_1MnNotPosDef.xml
%feature("docstring") ROOT::Minuit2::BasicMinimumError::MnNotPosDef "";


// File: classROOT_1_1Minuit2_1_1MnParabola.xml
%feature("docstring") ROOT::Minuit2::MnParabola "

This class defines a parabola of the form a*x*x + b*x + c

Fred James and Matthias Winkler; comments added by Andras Zsenei and Lorenzo Moneta

C++ includes: MnParabola.h
";

%feature("docstring")  ROOT::Minuit2::MnParabola::MnParabola "ROOT::Minuit2::MnParabola::MnParabola(double a, double b, double c)

Constructor that initializes the parabola with its three parameters.

Parameters:
-----------

a: 
the coefficient of the quadratic term

b: 
the coefficient of the linear term

c: 
the constant 
";

%feature("docstring")  ROOT::Minuit2::MnParabola::~MnParabola "ROOT::Minuit2::MnParabola::~MnParabola()
";

%feature("docstring")  ROOT::Minuit2::MnParabola::Y "double ROOT::Minuit2::MnParabola::Y(double x) const

Evaluates the parabola a the point x.

Parameters:
-----------

x: 
the coordinate where the parabola needs to be evaluated.

the y coordinate of the parabola corresponding to x. 
";

%feature("docstring")  ROOT::Minuit2::MnParabola::X_pos "double ROOT::Minuit2::MnParabola::X_pos(double y) const

Calculates the bigger of the two x values corresponding to the given y Value.

???????!!!!!!!!! And when there is none?? it looks like it will crash?? what is sqrt (-1.0) ?

Parameters:
-----------

y: 
the y Value for which the x Value is to be calculated.

the bigger one of the two corresponding values. 
";

%feature("docstring")  ROOT::Minuit2::MnParabola::X_neg "double ROOT::Minuit2::MnParabola::X_neg(double y) const

Calculates the smaller of the two x values corresponding to the given y Value.

???????!!!!!!!!! And when there is none?? it looks like it will crash?? what is sqrt (-1.0) ?

Parameters:
-----------

y: 
the y Value for which the x Value is to be calculated.

the smaller one of the two corresponding values. 
";

%feature("docstring")  ROOT::Minuit2::MnParabola::Min "double ROOT::Minuit2::MnParabola::Min() const

Calculates the x coordinate of the Minimum of the parabola.

x coordinate of the Minimum. 
";

%feature("docstring")  ROOT::Minuit2::MnParabola::YMin "double ROOT::Minuit2::MnParabola::YMin() const

Calculates the y coordinate of the Minimum of the parabola.

y coordinate of the Minimum. 
";

%feature("docstring")  ROOT::Minuit2::MnParabola::A "double ROOT::Minuit2::MnParabola::A() const

Accessor to the coefficient of the quadratic term.

the coefficient of the quadratic term. 
";

%feature("docstring")  ROOT::Minuit2::MnParabola::B "double ROOT::Minuit2::MnParabola::B() const

Accessor to the coefficient of the linear term.

the coefficient of the linear term. 
";

%feature("docstring")  ROOT::Minuit2::MnParabola::C "double ROOT::Minuit2::MnParabola::C() const

Accessor to the coefficient of the constant term.

the coefficient of the constant term. 
";


// File: classROOT_1_1Minuit2_1_1MnParabolaFactory.xml
%feature("docstring") ROOT::Minuit2::MnParabolaFactory "";

%feature("docstring")  ROOT::Minuit2::MnParabolaFactory::MnParabolaFactory "ROOT::Minuit2::MnParabolaFactory::MnParabolaFactory()
";

%feature("docstring")  ROOT::Minuit2::MnParabolaFactory::~MnParabolaFactory "ROOT::Minuit2::MnParabolaFactory::~MnParabolaFactory()
";


// File: classROOT_1_1Minuit2_1_1MnParabolaPoint.xml
%feature("docstring") ROOT::Minuit2::MnParabolaPoint "

A point of a parabola.

????!!!! in reality it is just a general point in two dimensional space, there is nothing that would indicate, that it belongs to a parabola. This class defines simpy an (x,y) pair!!!!

Fred James and Matthias Winkler; comments added by Andras Zsenei and Lorenzo Moneta
Todo
Should it be called  MnParabolaPoint or just Point?

C++ includes: MnParabolaPoint.h
";

%feature("docstring")  ROOT::Minuit2::MnParabolaPoint::MnParabolaPoint "ROOT::Minuit2::MnParabolaPoint::MnParabolaPoint(double x, double y)

Initializes the point with its coordinates.

Parameters:
-----------

x: 
the x (first) coordinate of the point.

y: 
the y (second) coordinate of the point. 
";

%feature("docstring")  ROOT::Minuit2::MnParabolaPoint::~MnParabolaPoint "ROOT::Minuit2::MnParabolaPoint::~MnParabolaPoint()
";

%feature("docstring")  ROOT::Minuit2::MnParabolaPoint::X "double ROOT::Minuit2::MnParabolaPoint::X() const

Accessor to the x (first) coordinate.

the x (first) coordinate of the point. 
";

%feature("docstring")  ROOT::Minuit2::MnParabolaPoint::Y "double ROOT::Minuit2::MnParabolaPoint::Y() const

Accessor to the y (second) coordinate.

the y (second) coordinate of the point. 
";


// File: classROOT_1_1Minuit2_1_1MnParameterScan.xml
%feature("docstring") ROOT::Minuit2::MnParameterScan "

Scans the values of FCN as a function of one Parameter and retains the best function and Parameter values found.

C++ includes: MnParameterScan.h
";

%feature("docstring")  ROOT::Minuit2::MnParameterScan::MnParameterScan "ROOT::Minuit2::MnParameterScan::MnParameterScan(const FCNBase &, const MnUserParameters &)
";

%feature("docstring")  ROOT::Minuit2::MnParameterScan::MnParameterScan "ROOT::Minuit2::MnParameterScan::MnParameterScan(const FCNBase &, const MnUserParameters &, double)
";

%feature("docstring")  ROOT::Minuit2::MnParameterScan::~MnParameterScan "ROOT::Minuit2::MnParameterScan::~MnParameterScan()
";

%feature("docstring")  ROOT::Minuit2::MnParameterScan::Parameters "const MnUserParameters& ROOT::Minuit2::MnParameterScan::Parameters() const
";

%feature("docstring")  ROOT::Minuit2::MnParameterScan::Fval "double ROOT::Minuit2::MnParameterScan::Fval() const
";


// File: classROOT_1_1Minuit2_1_1MnPlot.xml
%feature("docstring") ROOT::Minuit2::MnPlot "

MnPlot produces a text-screen graphical output of (x,y) points, e.g. from Scan or Contours.

C++ includes: MnPlot.h
";

%feature("docstring")  ROOT::Minuit2::MnPlot::MnPlot "ROOT::Minuit2::MnPlot::MnPlot()
";

%feature("docstring")  ROOT::Minuit2::MnPlot::MnPlot "ROOT::Minuit2::MnPlot::MnPlot(unsigned int width, unsigned int length)
";

%feature("docstring")  ROOT::Minuit2::MnPlot::~MnPlot "ROOT::Minuit2::MnPlot::~MnPlot()
";

%feature("docstring")  ROOT::Minuit2::MnPlot::Width "unsigned int ROOT::Minuit2::MnPlot::Width() const
";

%feature("docstring")  ROOT::Minuit2::MnPlot::Length "unsigned int ROOT::Minuit2::MnPlot::Length() const
";


// File: classROOT_1_1Minuit2_1_1MnPosDef.xml
%feature("docstring") ROOT::Minuit2::MnPosDef "

Force the covariance matrix to be positive defined by adding extra terms in the diagonal

C++ includes: MnPosDef.h
";

%feature("docstring")  ROOT::Minuit2::MnPosDef::MnPosDef "ROOT::Minuit2::MnPosDef::MnPosDef()
";

%feature("docstring")  ROOT::Minuit2::MnPosDef::~MnPosDef "ROOT::Minuit2::MnPosDef::~MnPosDef()
";


// File: classROOT_1_1Minuit2_1_1MnPrint.xml
%feature("docstring") ROOT::Minuit2::MnPrint "";


// File: classROOT_1_1Minuit2_1_1BasicFunctionMinimum_1_1MnReachedCallLimit.xml
%feature("docstring") ROOT::Minuit2::BasicFunctionMinimum::MnReachedCallLimit "";


// File: classROOT_1_1Minuit2_1_1FunctionMinimum_1_1MnReachedCallLimit.xml
%feature("docstring") ROOT::Minuit2::FunctionMinimum::MnReachedCallLimit "";


// File: classROOT_1_1Minuit2_1_1MnRefCountedPointer.xml
%feature("docstring") ROOT::Minuit2::MnRefCountedPointer "";

%feature("docstring")  ROOT::Minuit2::MnRefCountedPointer::MnRefCountedPointer "ROOT::Minuit2::MnRefCountedPointer< T >::MnRefCountedPointer()
";

%feature("docstring")  ROOT::Minuit2::MnRefCountedPointer::MnRefCountedPointer "ROOT::Minuit2::MnRefCountedPointer< T >::MnRefCountedPointer(T *pt)
";

%feature("docstring")  ROOT::Minuit2::MnRefCountedPointer::MnRefCountedPointer "ROOT::Minuit2::MnRefCountedPointer< T >::MnRefCountedPointer(const MnRefCountedPointer< T > &other)
";

%feature("docstring")  ROOT::Minuit2::MnRefCountedPointer::~MnRefCountedPointer "ROOT::Minuit2::MnRefCountedPointer< T >::~MnRefCountedPointer()
";

%feature("docstring")  ROOT::Minuit2::MnRefCountedPointer::IsValid "bool ROOT::Minuit2::MnRefCountedPointer< T >::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::MnRefCountedPointer::Get "T* ROOT::Minuit2::MnRefCountedPointer< T >::Get() const
";

%feature("docstring")  ROOT::Minuit2::MnRefCountedPointer::References "unsigned int ROOT::Minuit2::MnRefCountedPointer< T >::References() const
";

%feature("docstring")  ROOT::Minuit2::MnRefCountedPointer::AddReference "void ROOT::Minuit2::MnRefCountedPointer< T >::AddReference() const
";

%feature("docstring")  ROOT::Minuit2::MnRefCountedPointer::RemoveReference "void ROOT::Minuit2::MnRefCountedPointer< T >::RemoveReference()
";


// File: classROOT_1_1Minuit2_1_1MnReferenceCounter.xml
%feature("docstring") ROOT::Minuit2::MnReferenceCounter "";

%feature("docstring")  ROOT::Minuit2::MnReferenceCounter::MnReferenceCounter "ROOT::Minuit2::MnReferenceCounter::MnReferenceCounter()
";

%feature("docstring")  ROOT::Minuit2::MnReferenceCounter::MnReferenceCounter "ROOT::Minuit2::MnReferenceCounter::MnReferenceCounter(const MnReferenceCounter &other)
";

%feature("docstring")  ROOT::Minuit2::MnReferenceCounter::~MnReferenceCounter "ROOT::Minuit2::MnReferenceCounter::~MnReferenceCounter()
";

%feature("docstring")  ROOT::Minuit2::MnReferenceCounter::References "unsigned int ROOT::Minuit2::MnReferenceCounter::References() const
";

%feature("docstring")  ROOT::Minuit2::MnReferenceCounter::AddReference "void ROOT::Minuit2::MnReferenceCounter::AddReference() const
";

%feature("docstring")  ROOT::Minuit2::MnReferenceCounter::RemoveReference "void ROOT::Minuit2::MnReferenceCounter::RemoveReference() const
";


// File: classROOT_1_1Minuit2_1_1MnScan.xml
%feature("docstring") ROOT::Minuit2::MnScan "

API class for minimization using a scan method to find the minimum; allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.;

C++ includes: MnScan.h
";

%feature("docstring")  ROOT::Minuit2::MnScan::MnScan "ROOT::Minuit2::MnScan::MnScan(const FCNBase &fcn, const std::vector< double > &par, const std::vector< double > &err, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and errors 
";

%feature("docstring")  ROOT::Minuit2::MnScan::MnScan "ROOT::Minuit2::MnScan::MnScan(const FCNBase &fcn, const std::vector< double > &par, unsigned int nrow, const std::vector< double > &cov, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and covariance 
";

%feature("docstring")  ROOT::Minuit2::MnScan::MnScan "ROOT::Minuit2::MnScan::MnScan(const FCNBase &fcn, const std::vector< double > &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnScan::MnScan "ROOT::Minuit2::MnScan::MnScan(const FCNBase &fcn, const MnUserParameters &par, unsigned int stra=1)

construct from  FCNBase +  MnUserParameters
";

%feature("docstring")  ROOT::Minuit2::MnScan::MnScan "ROOT::Minuit2::MnScan::MnScan(const FCNBase &fcn, const MnUserParameters &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNBase +  MnUserParameters +  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnScan::MnScan "ROOT::Minuit2::MnScan::MnScan(const FCNBase &fcn, const MnUserParameterState &par, const MnStrategy &str)

construct from  FCNBase +  MnUserParameterState +  MnStrategy
";

%feature("docstring")  ROOT::Minuit2::MnScan::MnScan "ROOT::Minuit2::MnScan::MnScan(const MnScan &migr)
";

%feature("docstring")  ROOT::Minuit2::MnScan::~MnScan "ROOT::Minuit2::MnScan::~MnScan()
";

%feature("docstring")  ROOT::Minuit2::MnScan::Minimizer "ModularFunctionMinimizer& ROOT::Minuit2::MnScan::Minimizer()
";

%feature("docstring")  ROOT::Minuit2::MnScan::Minimizer "const ModularFunctionMinimizer& ROOT::Minuit2::MnScan::Minimizer() const
";

%feature("docstring")  ROOT::Minuit2::MnScan::Scan "std::vector<std::pair<double, double> > ROOT::Minuit2::MnScan::Scan(unsigned int par, unsigned int maxsteps=41, double low=0., double high=0.)
";


// File: classROOT_1_1Minuit2_1_1MnSeedGenerator.xml
%feature("docstring") ROOT::Minuit2::MnSeedGenerator "

concrete implementation of the  MinimumSeedGenerator interface; used within  ModularFunctionMinimizer;

C++ includes: MnSeedGenerator.h
";

%feature("docstring")  ROOT::Minuit2::MnSeedGenerator::MnSeedGenerator "ROOT::Minuit2::MnSeedGenerator::MnSeedGenerator()
";

%feature("docstring")  ROOT::Minuit2::MnSeedGenerator::~MnSeedGenerator "virtual ROOT::Minuit2::MnSeedGenerator::~MnSeedGenerator()
";


// File: classROOT_1_1Minuit2_1_1MnSimplex.xml
%feature("docstring") ROOT::Minuit2::MnSimplex "

API class for minimization using the Simplex method, which does not need and use the derivatives of the function, but only function values. More information on the minimization method is available here.

It allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.;

C++ includes: MnSimplex.h
";

%feature("docstring")  ROOT::Minuit2::MnSimplex::MnSimplex "ROOT::Minuit2::MnSimplex::MnSimplex(const FCNBase &fcn, const std::vector< double > &par, const std::vector< double > &err, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and errors 
";

%feature("docstring")  ROOT::Minuit2::MnSimplex::MnSimplex "ROOT::Minuit2::MnSimplex::MnSimplex(const FCNBase &fcn, const std::vector< double > &par, unsigned int nrow, const std::vector< double > &cov, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and covariance 
";

%feature("docstring")  ROOT::Minuit2::MnSimplex::MnSimplex "ROOT::Minuit2::MnSimplex::MnSimplex(const FCNBase &fcn, const std::vector< double > &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNBase + std::vector for parameters and  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnSimplex::MnSimplex "ROOT::Minuit2::MnSimplex::MnSimplex(const FCNBase &fcn, const MnUserParameters &par, unsigned int stra=1)

construct from  FCNBase +  MnUserParameters
";

%feature("docstring")  ROOT::Minuit2::MnSimplex::MnSimplex "ROOT::Minuit2::MnSimplex::MnSimplex(const FCNBase &fcn, const MnUserParameters &par, const MnUserCovariance &cov, unsigned int stra=1)

construct from  FCNBase +  MnUserParameters +  MnUserCovariance
";

%feature("docstring")  ROOT::Minuit2::MnSimplex::MnSimplex "ROOT::Minuit2::MnSimplex::MnSimplex(const FCNBase &fcn, const MnUserParameterState &par, const MnStrategy &str)

construct from  FCNBase +  MnUserParameterState +  MnStrategy
";

%feature("docstring")  ROOT::Minuit2::MnSimplex::MnSimplex "ROOT::Minuit2::MnSimplex::MnSimplex(const MnSimplex &migr)
";

%feature("docstring")  ROOT::Minuit2::MnSimplex::~MnSimplex "ROOT::Minuit2::MnSimplex::~MnSimplex()
";

%feature("docstring")  ROOT::Minuit2::MnSimplex::Minimizer "ModularFunctionMinimizer& ROOT::Minuit2::MnSimplex::Minimizer()
";

%feature("docstring")  ROOT::Minuit2::MnSimplex::Minimizer "const ModularFunctionMinimizer& ROOT::Minuit2::MnSimplex::Minimizer() const
";


// File: classROOT_1_1Minuit2_1_1MnStrategy.xml
%feature("docstring") ROOT::Minuit2::MnStrategy "

API class for defining three levels of strategies: low (0), medium (1), high (>=2); acts on: Migrad (behavioural), Minos (lowers strategy by 1 for Minos-own minimization), Hesse (iterations), Numerical2PDerivative (iterations)

C++ includes: MnStrategy.h
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::MnStrategy "ROOT::Minuit2::MnStrategy::MnStrategy()
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::MnStrategy "ROOT::Minuit2::MnStrategy::MnStrategy(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::~MnStrategy "ROOT::Minuit2::MnStrategy::~MnStrategy()
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::Strategy "unsigned int ROOT::Minuit2::MnStrategy::Strategy() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::GradientNCycles "unsigned int ROOT::Minuit2::MnStrategy::GradientNCycles() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::GradientStepTolerance "double ROOT::Minuit2::MnStrategy::GradientStepTolerance() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::GradientTolerance "double ROOT::Minuit2::MnStrategy::GradientTolerance() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::HessianNCycles "unsigned int ROOT::Minuit2::MnStrategy::HessianNCycles() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::HessianStepTolerance "double ROOT::Minuit2::MnStrategy::HessianStepTolerance() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::HessianG2Tolerance "double ROOT::Minuit2::MnStrategy::HessianG2Tolerance() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::HessianGradientNCycles "unsigned int ROOT::Minuit2::MnStrategy::HessianGradientNCycles() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::StorageLevel "int ROOT::Minuit2::MnStrategy::StorageLevel() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::IsLow "bool ROOT::Minuit2::MnStrategy::IsLow() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::IsMedium "bool ROOT::Minuit2::MnStrategy::IsMedium() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::IsHigh "bool ROOT::Minuit2::MnStrategy::IsHigh() const
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::SetLowStrategy "void ROOT::Minuit2::MnStrategy::SetLowStrategy()
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::SetMediumStrategy "void ROOT::Minuit2::MnStrategy::SetMediumStrategy()
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::SetHighStrategy "void ROOT::Minuit2::MnStrategy::SetHighStrategy()
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::SetGradientNCycles "void ROOT::Minuit2::MnStrategy::SetGradientNCycles(unsigned int n)
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::SetGradientStepTolerance "void ROOT::Minuit2::MnStrategy::SetGradientStepTolerance(double stp)
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::SetGradientTolerance "void ROOT::Minuit2::MnStrategy::SetGradientTolerance(double toler)
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::SetHessianNCycles "void ROOT::Minuit2::MnStrategy::SetHessianNCycles(unsigned int n)
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::SetHessianStepTolerance "void ROOT::Minuit2::MnStrategy::SetHessianStepTolerance(double stp)
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::SetHessianG2Tolerance "void ROOT::Minuit2::MnStrategy::SetHessianG2Tolerance(double toler)
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::SetHessianGradientNCycles "void ROOT::Minuit2::MnStrategy::SetHessianGradientNCycles(unsigned int n)
";

%feature("docstring")  ROOT::Minuit2::MnStrategy::SetStorageLevel "void ROOT::Minuit2::MnStrategy::SetStorageLevel(unsigned int level)
";


// File: classROOT_1_1Minuit2_1_1MnTiny.xml
%feature("docstring") ROOT::Minuit2::MnTiny "";

%feature("docstring")  ROOT::Minuit2::MnTiny::MnTiny "ROOT::Minuit2::MnTiny::MnTiny()
";

%feature("docstring")  ROOT::Minuit2::MnTiny::~MnTiny "ROOT::Minuit2::MnTiny::~MnTiny()
";

%feature("docstring")  ROOT::Minuit2::MnTiny::One "double ROOT::Minuit2::MnTiny::One() const
";


// File: classROOT_1_1Minuit2_1_1MnTraceObject.xml
%feature("docstring") ROOT::Minuit2::MnTraceObject "";

%feature("docstring")  ROOT::Minuit2::MnTraceObject::MnTraceObject "ROOT::Minuit2::MnTraceObject::MnTraceObject(int parNumber=-1)
";

%feature("docstring")  ROOT::Minuit2::MnTraceObject::~MnTraceObject "virtual ROOT::Minuit2::MnTraceObject::~MnTraceObject()
";

%feature("docstring")  ROOT::Minuit2::MnTraceObject::Init "virtual void ROOT::Minuit2::MnTraceObject::Init(const MnUserParameterState &state)
";

%feature("docstring")  ROOT::Minuit2::MnTraceObject::UserState "const MnUserParameterState& ROOT::Minuit2::MnTraceObject::UserState() const
";

%feature("docstring")  ROOT::Minuit2::MnTraceObject::SetParNumber "void ROOT::Minuit2::MnTraceObject::SetParNumber(int number)
";

%feature("docstring")  ROOT::Minuit2::MnTraceObject::ParNumber "int ROOT::Minuit2::MnTraceObject::ParNumber() const
";


// File: classROOT_1_1Minuit2_1_1MnUserCovariance.xml
%feature("docstring") ROOT::Minuit2::MnUserCovariance "

Class containing the covariance matrix data represented as a vector of size n*(n+1)/2 Used to hide internal matrix representation to user

C++ includes: MnUserCovariance.h
";

%feature("docstring")  ROOT::Minuit2::MnUserCovariance::MnUserCovariance "ROOT::Minuit2::MnUserCovariance::MnUserCovariance()
";

%feature("docstring")  ROOT::Minuit2::MnUserCovariance::MnUserCovariance "ROOT::Minuit2::MnUserCovariance::MnUserCovariance(const std::vector< double > &data, unsigned int nrow)
";

%feature("docstring")  ROOT::Minuit2::MnUserCovariance::MnUserCovariance "ROOT::Minuit2::MnUserCovariance::MnUserCovariance(const double *data, unsigned int nrow)
";

%feature("docstring")  ROOT::Minuit2::MnUserCovariance::MnUserCovariance "ROOT::Minuit2::MnUserCovariance::MnUserCovariance(unsigned int n)
";

%feature("docstring")  ROOT::Minuit2::MnUserCovariance::~MnUserCovariance "ROOT::Minuit2::MnUserCovariance::~MnUserCovariance()
";

%feature("docstring")  ROOT::Minuit2::MnUserCovariance::MnUserCovariance "ROOT::Minuit2::MnUserCovariance::MnUserCovariance(const MnUserCovariance &cov)
";

%feature("docstring")  ROOT::Minuit2::MnUserCovariance::Scale "void ROOT::Minuit2::MnUserCovariance::Scale(double f)
";

%feature("docstring")  ROOT::Minuit2::MnUserCovariance::Data "const std::vector<double>& ROOT::Minuit2::MnUserCovariance::Data() const
";

%feature("docstring")  ROOT::Minuit2::MnUserCovariance::Nrow "unsigned int ROOT::Minuit2::MnUserCovariance::Nrow() const
";

%feature("docstring")  ROOT::Minuit2::MnUserCovariance::size "unsigned int ROOT::Minuit2::MnUserCovariance::size() const
";


// File: classROOT_1_1Minuit2_1_1MnUserFcn.xml
%feature("docstring") ROOT::Minuit2::MnUserFcn "

Wrapper used by Minuit of FCN interface containing a reference to the transformation object

C++ includes: MnUserFcn.h
";

%feature("docstring")  ROOT::Minuit2::MnUserFcn::MnUserFcn "ROOT::Minuit2::MnUserFcn::MnUserFcn(const FCNBase &fcn, const MnUserTransformation &trafo, int ncall=0)
";

%feature("docstring")  ROOT::Minuit2::MnUserFcn::~MnUserFcn "ROOT::Minuit2::MnUserFcn::~MnUserFcn()
";


// File: classROOT_1_1Minuit2_1_1MnUserParameters.xml
%feature("docstring") ROOT::Minuit2::MnUserParameters "

API class for the user interaction with the parameters; serves as input to the minimizer as well as output from it; users can interact: Fix/release parameters, set values and errors, etc.; parameters can be accessed via their Parameter number (determined internally by Minuit and followed the order how the parameters are created) or via their user-specified Name (10 character string). Minuit has also an internal parameter number which is used during the minimization (the fix parameter are skipped). The parameter number used in this class is the external one. The class  ROOT::Minuit2::MnUserTransformation is used to keep the internal <-> external transformation

C++ includes: MnUserParameters.h
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::MnUserParameters "ROOT::Minuit2::MnUserParameters::MnUserParameters()
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::MnUserParameters "ROOT::Minuit2::MnUserParameters::MnUserParameters(const std::vector< double > &, const std::vector< double > &)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::~MnUserParameters "ROOT::Minuit2::MnUserParameters::~MnUserParameters()
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::MnUserParameters "ROOT::Minuit2::MnUserParameters::MnUserParameters(const MnUserParameters &par)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Trafo "const MnUserTransformation& ROOT::Minuit2::MnUserParameters::Trafo() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::VariableParameters "unsigned int ROOT::Minuit2::MnUserParameters::VariableParameters() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Parameters "const std::vector<ROOT::Minuit2::MinuitParameter>& ROOT::Minuit2::MnUserParameters::Parameters() const

access to parameters (row-wise) 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Params "std::vector<double> ROOT::Minuit2::MnUserParameters::Params() const

access to parameters and errors in column-wise representation 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Errors "std::vector<double> ROOT::Minuit2::MnUserParameters::Errors() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Parameter "const MinuitParameter& ROOT::Minuit2::MnUserParameters::Parameter(unsigned int) const

access to single Parameter 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Add "bool ROOT::Minuit2::MnUserParameters::Add(const std::string &, double, double)

Add free Parameter Name, Value, Error. 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Add "bool ROOT::Minuit2::MnUserParameters::Add(const std::string &, double, double, double, double)

Add limited Parameter Name, Value, Lower bound, Upper bound. 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Add "bool ROOT::Minuit2::MnUserParameters::Add(const std::string &, double)

Add const Parameter Name, vale. 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Fix "void ROOT::Minuit2::MnUserParameters::Fix(unsigned int)

interaction via external number of Parameter 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Release "void ROOT::Minuit2::MnUserParameters::Release(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::RemoveLimits "void ROOT::Minuit2::MnUserParameters::RemoveLimits(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetValue "void ROOT::Minuit2::MnUserParameters::SetValue(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetError "void ROOT::Minuit2::MnUserParameters::SetError(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetLimits "void ROOT::Minuit2::MnUserParameters::SetLimits(unsigned int, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetUpperLimit "void ROOT::Minuit2::MnUserParameters::SetUpperLimit(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetLowerLimit "void ROOT::Minuit2::MnUserParameters::SetLowerLimit(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetName "void ROOT::Minuit2::MnUserParameters::SetName(unsigned int, const std::string &)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Value "double ROOT::Minuit2::MnUserParameters::Value(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Error "double ROOT::Minuit2::MnUserParameters::Error(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Fix "void ROOT::Minuit2::MnUserParameters::Fix(const std::string &)

interaction via Name of Parameter 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Release "void ROOT::Minuit2::MnUserParameters::Release(const std::string &)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetValue "void ROOT::Minuit2::MnUserParameters::SetValue(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetError "void ROOT::Minuit2::MnUserParameters::SetError(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetLimits "void ROOT::Minuit2::MnUserParameters::SetLimits(const std::string &, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetUpperLimit "void ROOT::Minuit2::MnUserParameters::SetUpperLimit(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetLowerLimit "void ROOT::Minuit2::MnUserParameters::SetLowerLimit(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::RemoveLimits "void ROOT::Minuit2::MnUserParameters::RemoveLimits(const std::string &)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Value "double ROOT::Minuit2::MnUserParameters::Value(const std::string &) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Error "double ROOT::Minuit2::MnUserParameters::Error(const std::string &) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Index "unsigned int ROOT::Minuit2::MnUserParameters::Index(const std::string &) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::GetName "const std::string& ROOT::Minuit2::MnUserParameters::GetName(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Name "const char* ROOT::Minuit2::MnUserParameters::Name(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::Precision "const MnMachinePrecision& ROOT::Minuit2::MnUserParameters::Precision() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameters::SetPrecision "void ROOT::Minuit2::MnUserParameters::SetPrecision(double eps)
";


// File: classROOT_1_1Minuit2_1_1MnUserParameterState.xml
%feature("docstring") ROOT::Minuit2::MnUserParameterState "

class which holds the external user and/or internal Minuit representation of the parameters and errors; transformation internal <-> external on demand;

C++ includes: MnUserParameterState.h
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::MnUserParameterState "ROOT::Minuit2::MnUserParameterState::MnUserParameterState()

default constructor (invalid state) 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::MnUserParameterState "ROOT::Minuit2::MnUserParameterState::MnUserParameterState(const std::vector< double > &, const std::vector< double > &)

construct from user parameters (before minimization) 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::MnUserParameterState "ROOT::Minuit2::MnUserParameterState::MnUserParameterState(const MnUserParameters &)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::MnUserParameterState "ROOT::Minuit2::MnUserParameterState::MnUserParameterState(const std::vector< double > &, const std::vector< double > &, unsigned int)

construct from user parameters + covariance (before minimization) 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::MnUserParameterState "ROOT::Minuit2::MnUserParameterState::MnUserParameterState(const std::vector< double > &, const MnUserCovariance &)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::MnUserParameterState "ROOT::Minuit2::MnUserParameterState::MnUserParameterState(const MnUserParameters &, const MnUserCovariance &)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::MnUserParameterState "ROOT::Minuit2::MnUserParameterState::MnUserParameterState(const MinimumState &, double, const MnUserTransformation &)

construct from internal parameters (after minimization) 
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::~MnUserParameterState "ROOT::Minuit2::MnUserParameterState::~MnUserParameterState()
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::MnUserParameterState "ROOT::Minuit2::MnUserParameterState::MnUserParameterState(const MnUserParameterState &state)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Parameters "const MnUserParameters& ROOT::Minuit2::MnUserParameterState::Parameters() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Covariance "const MnUserCovariance& ROOT::Minuit2::MnUserParameterState::Covariance() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::GlobalCC "const MnGlobalCorrelationCoeff& ROOT::Minuit2::MnUserParameterState::GlobalCC() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Hessian "MnUserCovariance ROOT::Minuit2::MnUserParameterState::Hessian() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::IntParameters "const std::vector<double>& ROOT::Minuit2::MnUserParameterState::IntParameters() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::IntCovariance "const MnUserCovariance& ROOT::Minuit2::MnUserParameterState::IntCovariance() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::CovarianceStatus "int ROOT::Minuit2::MnUserParameterState::CovarianceStatus() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Trafo "const MnUserTransformation& ROOT::Minuit2::MnUserParameterState::Trafo() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::IsValid "bool ROOT::Minuit2::MnUserParameterState::IsValid() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::HasCovariance "bool ROOT::Minuit2::MnUserParameterState::HasCovariance() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::HasGlobalCC "bool ROOT::Minuit2::MnUserParameterState::HasGlobalCC() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Fval "double ROOT::Minuit2::MnUserParameterState::Fval() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Edm "double ROOT::Minuit2::MnUserParameterState::Edm() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::NFcn "unsigned int ROOT::Minuit2::MnUserParameterState::NFcn() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::MinuitParameters "const std::vector<ROOT::Minuit2::MinuitParameter>& ROOT::Minuit2::MnUserParameterState::MinuitParameters() const

facade: forward interface of  MnUserParameters and  MnUserTransformation
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Params "std::vector<double> ROOT::Minuit2::MnUserParameterState::Params() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Errors "std::vector<double> ROOT::Minuit2::MnUserParameterState::Errors() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Parameter "const MinuitParameter& ROOT::Minuit2::MnUserParameterState::Parameter(unsigned int i) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Add "void ROOT::Minuit2::MnUserParameterState::Add(const std::string &name, double val, double err)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Add "void ROOT::Minuit2::MnUserParameterState::Add(const std::string &name, double val, double err, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Add "void ROOT::Minuit2::MnUserParameterState::Add(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Fix "void ROOT::Minuit2::MnUserParameterState::Fix(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Release "void ROOT::Minuit2::MnUserParameterState::Release(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::RemoveLimits "void ROOT::Minuit2::MnUserParameterState::RemoveLimits(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetValue "void ROOT::Minuit2::MnUserParameterState::SetValue(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetError "void ROOT::Minuit2::MnUserParameterState::SetError(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetLimits "void ROOT::Minuit2::MnUserParameterState::SetLimits(unsigned int, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetUpperLimit "void ROOT::Minuit2::MnUserParameterState::SetUpperLimit(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetLowerLimit "void ROOT::Minuit2::MnUserParameterState::SetLowerLimit(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetName "void ROOT::Minuit2::MnUserParameterState::SetName(unsigned int iext, const std::string &name)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Value "double ROOT::Minuit2::MnUserParameterState::Value(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Error "double ROOT::Minuit2::MnUserParameterState::Error(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Fix "void ROOT::Minuit2::MnUserParameterState::Fix(const std::string &)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Release "void ROOT::Minuit2::MnUserParameterState::Release(const std::string &)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetValue "void ROOT::Minuit2::MnUserParameterState::SetValue(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetError "void ROOT::Minuit2::MnUserParameterState::SetError(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetLimits "void ROOT::Minuit2::MnUserParameterState::SetLimits(const std::string &, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetUpperLimit "void ROOT::Minuit2::MnUserParameterState::SetUpperLimit(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetLowerLimit "void ROOT::Minuit2::MnUserParameterState::SetLowerLimit(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::RemoveLimits "void ROOT::Minuit2::MnUserParameterState::RemoveLimits(const std::string &)
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Value "double ROOT::Minuit2::MnUserParameterState::Value(const std::string &) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Error "double ROOT::Minuit2::MnUserParameterState::Error(const std::string &) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Index "unsigned int ROOT::Minuit2::MnUserParameterState::Index(const std::string &) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::GetName "const std::string& ROOT::Minuit2::MnUserParameterState::GetName(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Name "const char* ROOT::Minuit2::MnUserParameterState::Name(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Int2ext "double ROOT::Minuit2::MnUserParameterState::Int2ext(unsigned int, double) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Ext2int "double ROOT::Minuit2::MnUserParameterState::Ext2int(unsigned int, double) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::IntOfExt "unsigned int ROOT::Minuit2::MnUserParameterState::IntOfExt(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::ExtOfInt "unsigned int ROOT::Minuit2::MnUserParameterState::ExtOfInt(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::VariableParameters "unsigned int ROOT::Minuit2::MnUserParameterState::VariableParameters() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::Precision "const MnMachinePrecision& ROOT::Minuit2::MnUserParameterState::Precision() const
";

%feature("docstring")  ROOT::Minuit2::MnUserParameterState::SetPrecision "void ROOT::Minuit2::MnUserParameterState::SetPrecision(double eps)
";


// File: classROOT_1_1Minuit2_1_1MnUserTransformation.xml
%feature("docstring") ROOT::Minuit2::MnUserTransformation "

class dealing with the transformation between user specified parameters (external) and internal parameters used for minimization

C++ includes: MnUserTransformation.h
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::MnUserTransformation "ROOT::Minuit2::MnUserTransformation::MnUserTransformation()
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::MnUserTransformation "ROOT::Minuit2::MnUserTransformation::MnUserTransformation(const std::vector< double > &, const std::vector< double > &)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::~MnUserTransformation "ROOT::Minuit2::MnUserTransformation::~MnUserTransformation()
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::MnUserTransformation "ROOT::Minuit2::MnUserTransformation::MnUserTransformation(const MnUserTransformation &trafo)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Int2ext "double ROOT::Minuit2::MnUserTransformation::Int2ext(unsigned int, double) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Int2extError "double ROOT::Minuit2::MnUserTransformation::Int2extError(unsigned int, double, double) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Int2extCovariance "MnUserCovariance ROOT::Minuit2::MnUserTransformation::Int2extCovariance(const MnAlgebraicVector &, const MnAlgebraicSymMatrix &) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Ext2int "double ROOT::Minuit2::MnUserTransformation::Ext2int(unsigned int, double) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::DInt2Ext "double ROOT::Minuit2::MnUserTransformation::DInt2Ext(unsigned int, double) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::IntOfExt "unsigned int ROOT::Minuit2::MnUserTransformation::IntOfExt(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::ExtOfInt "unsigned int ROOT::Minuit2::MnUserTransformation::ExtOfInt(unsigned int internal) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Parameters "const std::vector<MinuitParameter>& ROOT::Minuit2::MnUserTransformation::Parameters() const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::VariableParameters "unsigned int ROOT::Minuit2::MnUserTransformation::VariableParameters() const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::InitialParValues "const std::vector<double>& ROOT::Minuit2::MnUserTransformation::InitialParValues() const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Precision "const MnMachinePrecision& ROOT::Minuit2::MnUserTransformation::Precision() const

forwarded interface 
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetPrecision "void ROOT::Minuit2::MnUserTransformation::SetPrecision(double eps)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Params "std::vector<double> ROOT::Minuit2::MnUserTransformation::Params() const

access to parameters and errors in column-wise representation 
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Errors "std::vector<double> ROOT::Minuit2::MnUserTransformation::Errors() const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Parameter "const MinuitParameter& ROOT::Minuit2::MnUserTransformation::Parameter(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Add "bool ROOT::Minuit2::MnUserTransformation::Add(const std::string &, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Add "bool ROOT::Minuit2::MnUserTransformation::Add(const std::string &, double, double, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Add "bool ROOT::Minuit2::MnUserTransformation::Add(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Fix "void ROOT::Minuit2::MnUserTransformation::Fix(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Release "void ROOT::Minuit2::MnUserTransformation::Release(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::RemoveLimits "void ROOT::Minuit2::MnUserTransformation::RemoveLimits(unsigned int)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetValue "void ROOT::Minuit2::MnUserTransformation::SetValue(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetError "void ROOT::Minuit2::MnUserTransformation::SetError(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetLimits "void ROOT::Minuit2::MnUserTransformation::SetLimits(unsigned int, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetUpperLimit "void ROOT::Minuit2::MnUserTransformation::SetUpperLimit(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetLowerLimit "void ROOT::Minuit2::MnUserTransformation::SetLowerLimit(unsigned int, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetName "void ROOT::Minuit2::MnUserTransformation::SetName(unsigned int, const std::string &)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Value "double ROOT::Minuit2::MnUserTransformation::Value(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Error "double ROOT::Minuit2::MnUserTransformation::Error(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Fix "void ROOT::Minuit2::MnUserTransformation::Fix(const std::string &)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Release "void ROOT::Minuit2::MnUserTransformation::Release(const std::string &)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetValue "void ROOT::Minuit2::MnUserTransformation::SetValue(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetError "void ROOT::Minuit2::MnUserTransformation::SetError(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetLimits "void ROOT::Minuit2::MnUserTransformation::SetLimits(const std::string &, double, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetUpperLimit "void ROOT::Minuit2::MnUserTransformation::SetUpperLimit(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::SetLowerLimit "void ROOT::Minuit2::MnUserTransformation::SetLowerLimit(const std::string &, double)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::RemoveLimits "void ROOT::Minuit2::MnUserTransformation::RemoveLimits(const std::string &)
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Value "double ROOT::Minuit2::MnUserTransformation::Value(const std::string &) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Error "double ROOT::Minuit2::MnUserTransformation::Error(const std::string &) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Index "unsigned int ROOT::Minuit2::MnUserTransformation::Index(const std::string &) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::FindIndex "int ROOT::Minuit2::MnUserTransformation::FindIndex(const std::string &) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::GetName "const std::string& ROOT::Minuit2::MnUserTransformation::GetName(unsigned int) const
";

%feature("docstring")  ROOT::Minuit2::MnUserTransformation::Name "const char* ROOT::Minuit2::MnUserTransformation::Name(unsigned int) const
";


// File: classROOT_1_1Minuit2_1_1MnVectorTransform.xml
%feature("docstring") ROOT::Minuit2::MnVectorTransform "";

%feature("docstring")  ROOT::Minuit2::MnVectorTransform::MnVectorTransform "ROOT::Minuit2::MnVectorTransform::MnVectorTransform()
";

%feature("docstring")  ROOT::Minuit2::MnVectorTransform::~MnVectorTransform "ROOT::Minuit2::MnVectorTransform::~MnVectorTransform()
";


// File: classROOT_1_1Minuit2_1_1ModularFunctionMinimizer.xml
%feature("docstring") ROOT::Minuit2::ModularFunctionMinimizer "

Base common class providing the API for all the minimizer Various  Minimize methods are provided varying on the type of FCN function passesd and on the objects used for the parameters

C++ includes: ModularFunctionMinimizer.h
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::~ModularFunctionMinimizer "virtual ROOT::Minuit2::ModularFunctionMinimizer::~ModularFunctionMinimizer()
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::ModularFunctionMinimizer::Minimize(const FCNBase &, const std::vector< double > &, const std::vector< double > &, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::ModularFunctionMinimizer::Minimize(const FCNGradientBase &, const std::vector< double > &, const std::vector< double > &, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::ModularFunctionMinimizer::Minimize(const FCNBase &, const std::vector< double > &, unsigned int, const std::vector< double > &, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::ModularFunctionMinimizer::Minimize(const FCNGradientBase &, const std::vector< double > &, unsigned int, const std::vector< double > &, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::ModularFunctionMinimizer::Minimize(const FCNBase &, const MnUserParameters &, const MnStrategy &, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::ModularFunctionMinimizer::Minimize(const FCNGradientBase &, const MnUserParameters &, const MnStrategy &, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::ModularFunctionMinimizer::Minimize(const FCNBase &, const MnUserParameters &, const MnUserCovariance &, const MnStrategy &, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::ModularFunctionMinimizer::Minimize(const FCNGradientBase &, const MnUserParameters &, const MnUserCovariance &, const MnStrategy &, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::ModularFunctionMinimizer::Minimize(const FCNBase &, const MnUserParameterState &, const MnStrategy &, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::ModularFunctionMinimizer::Minimize(const FCNGradientBase &, const MnUserParameterState &, const MnStrategy &, unsigned int maxfcn=0, double toler=0.1) const
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::SeedGenerator "virtual const MinimumSeedGenerator& ROOT::Minuit2::ModularFunctionMinimizer::SeedGenerator() const =0
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Builder "virtual const MinimumBuilder& ROOT::Minuit2::ModularFunctionMinimizer::Builder() const =0
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Builder "virtual MinimumBuilder& ROOT::Minuit2::ModularFunctionMinimizer::Builder()=0
";

%feature("docstring")  ROOT::Minuit2::ModularFunctionMinimizer::Minimize "virtual FunctionMinimum ROOT::Minuit2::ModularFunctionMinimizer::Minimize(const MnFcn &, const GradientCalculator &, const MinimumSeed &, const MnStrategy &, unsigned int, double) const
";


// File: classROOT_1_1Minuit2_1_1MPIProcess.xml
%feature("docstring") ROOT::Minuit2::MPIProcess "";

%feature("docstring")  ROOT::Minuit2::MPIProcess::MPIProcess "ROOT::Minuit2::MPIProcess::MPIProcess(unsigned int nelements, unsigned int indexComm)
";

%feature("docstring")  ROOT::Minuit2::MPIProcess::~MPIProcess "ROOT::Minuit2::MPIProcess::~MPIProcess()
";

%feature("docstring")  ROOT::Minuit2::MPIProcess::NumElements4JobIn "unsigned int ROOT::Minuit2::MPIProcess::NumElements4JobIn() const
";

%feature("docstring")  ROOT::Minuit2::MPIProcess::NumElements4JobOut "unsigned int ROOT::Minuit2::MPIProcess::NumElements4JobOut() const
";

%feature("docstring")  ROOT::Minuit2::MPIProcess::NumElements4Job "unsigned int ROOT::Minuit2::MPIProcess::NumElements4Job(unsigned int rank) const
";

%feature("docstring")  ROOT::Minuit2::MPIProcess::StartElementIndex "unsigned int ROOT::Minuit2::MPIProcess::StartElementIndex() const
";

%feature("docstring")  ROOT::Minuit2::MPIProcess::EndElementIndex "unsigned int ROOT::Minuit2::MPIProcess::EndElementIndex() const
";

%feature("docstring")  ROOT::Minuit2::MPIProcess::GetMPISize "unsigned int ROOT::Minuit2::MPIProcess::GetMPISize() const
";

%feature("docstring")  ROOT::Minuit2::MPIProcess::GetMPIRank "unsigned int ROOT::Minuit2::MPIProcess::GetMPIRank() const
";

%feature("docstring")  ROOT::Minuit2::MPIProcess::SyncVector "bool ROOT::Minuit2::MPIProcess::SyncVector(ROOT::Minuit2::MnAlgebraicVector &mnvector)
";

%feature("docstring")  ROOT::Minuit2::MPIProcess::SyncSymMatrixOffDiagonal "bool ROOT::Minuit2::MPIProcess::SyncSymMatrixOffDiagonal(ROOT::Minuit2::MnAlgebraicSymMatrix &mnmatrix)
";

%feature("docstring")  ROOT::Minuit2::MPIProcess::SumReduce "void ROOT::Minuit2::MPIProcess::SumReduce(const double &sub, double &total)
";


// File: classROOT_1_1Minuit2_1_1MPITerminate.xml
%feature("docstring") ROOT::Minuit2::MPITerminate "";

%feature("docstring")  ROOT::Minuit2::MPITerminate::~MPITerminate "ROOT::Minuit2::MPITerminate::~MPITerminate()
";


// File: classTMVA_1_1MsgLogger.xml
%feature("docstring") TMVA::MsgLogger "";

%feature("docstring")  TMVA::MsgLogger::MsgLogger "TMVA::MsgLogger::MsgLogger(const std::string &source)
";


// File: classROOT_1_1Math_1_1MultiNumGradFunction.xml
%feature("docstring") ROOT::Math::MultiNumGradFunction "

MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class  Derivator (based on GSL numerical derivation)

C++ includes: MultiNumGradFunction.h
";

%feature("docstring")  ROOT::Math::MultiNumGradFunction::MultiNumGradFunction "ROOT::Math::MultiNumGradFunction::MultiNumGradFunction(const IMultiGenFunction &f)

Constructor from a IMultiGenFunction interface 
";

%feature("docstring")  ROOT::Math::MultiNumGradFunction::MultiNumGradFunction "ROOT::Math::MultiNumGradFunction::MultiNumGradFunction(FuncType f, int n)

Constructor from a generic function (pointer or reference) and number of dimension implementiong operator () (double * x) 
";

%feature("docstring")  ROOT::Math::MultiNumGradFunction::~MultiNumGradFunction "ROOT::Math::MultiNumGradFunction::~MultiNumGradFunction()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::MultiNumGradFunction::NDim "unsigned int ROOT::Math::MultiNumGradFunction::NDim() const

Retrieve the dimension of the function 
";

%feature("docstring")  ROOT::Math::MultiNumGradFunction::NCalls "unsigned int ROOT::Math::MultiNumGradFunction::NCalls() const
";

%feature("docstring")  ROOT::Math::MultiNumGradFunction::Clone "IMultiGenFunction* ROOT::Math::MultiNumGradFunction::Clone() const

Clone a function. Each derived class must implement their version of the Clone method 
";

%feature("docstring")  ROOT::Math::MultiNumGradFunction::SetOwnership "void ROOT::Math::MultiNumGradFunction::SetOwnership(bool on=true)
";


// File: classMultiOption.xml
%feature("docstring") MultiOption "

Stores a single option for minimization algorithm. Int, double, string values are available. Relies on boost::variant, will be switched to std::variant in C++-17.

C++ includes: MultiOption.h
";

%feature("docstring")  MultiOption::MultiOption "MultiOption::MultiOption(const std::string &name=\"\")
";

%feature("docstring")  MultiOption::MultiOption "MultiOption::MultiOption(const std::string &name, const T &t, const std::string &descripion=\"\")
";

%feature("docstring")  MultiOption::name "std::string MultiOption::name() const
";

%feature("docstring")  MultiOption::description "std::string MultiOption::description() const
";

%feature("docstring")  MultiOption::setDescription "void MultiOption::setDescription(const std::string &description)
";

%feature("docstring")  MultiOption::value "MultiOption::variant_t & MultiOption::value()
";

%feature("docstring")  MultiOption::defaultValue "MultiOption::variant_t & MultiOption::defaultValue()
";

%feature("docstring")  MultiOption::get "T MultiOption::get() const

Returns the option's value. 
";

%feature("docstring")  MultiOption::getDefault "T MultiOption::getDefault() const

Returns the option's default value (i.e. used during construction) 
";

%feature("docstring")  MultiOption::setFromString "void MultiOption::setFromString(const std::string &value)

Sets the value of option from string. TODO find more elegant way (without if/else and boost::lexical_cast 
";


// File: classMultiOptionTest.xml
%feature("docstring") MultiOptionTest "";


// File: classROOT_1_1Minuit2_1_1NegativeG2LineSearch.xml
%feature("docstring") ROOT::Minuit2::NegativeG2LineSearch "

In case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive.

C++ includes: NegativeG2LineSearch.h
";

%feature("docstring")  ROOT::Minuit2::NegativeG2LineSearch::NegativeG2LineSearch "ROOT::Minuit2::NegativeG2LineSearch::NegativeG2LineSearch()
";

%feature("docstring")  ROOT::Minuit2::NegativeG2LineSearch::~NegativeG2LineSearch "ROOT::Minuit2::NegativeG2LineSearch::~NegativeG2LineSearch()
";

%feature("docstring")  ROOT::Minuit2::NegativeG2LineSearch::HasNegativeG2 "bool ROOT::Minuit2::NegativeG2LineSearch::HasNegativeG2(const FunctionGradient &, const MnMachinePrecision &) const
";


// File: structROOT_1_1Math_1_1NullTypeFunc1D.xml
%feature("docstring") ROOT::Math::NullTypeFunc1D "";


// File: classROOT_1_1Minuit2_1_1Numerical2PGradientCalculator.xml
%feature("docstring") ROOT::Minuit2::Numerical2PGradientCalculator "

class performing the numerical gradient calculation

C++ includes: Numerical2PGradientCalculator.h
";

%feature("docstring")  ROOT::Minuit2::Numerical2PGradientCalculator::Numerical2PGradientCalculator "ROOT::Minuit2::Numerical2PGradientCalculator::Numerical2PGradientCalculator(const MnFcn &fcn, const MnUserTransformation &par, const MnStrategy &stra)
";

%feature("docstring")  ROOT::Minuit2::Numerical2PGradientCalculator::~Numerical2PGradientCalculator "virtual ROOT::Minuit2::Numerical2PGradientCalculator::~Numerical2PGradientCalculator()
";

%feature("docstring")  ROOT::Minuit2::Numerical2PGradientCalculator::Fcn "const MnFcn& ROOT::Minuit2::Numerical2PGradientCalculator::Fcn() const
";

%feature("docstring")  ROOT::Minuit2::Numerical2PGradientCalculator::Trafo "const MnUserTransformation& ROOT::Minuit2::Numerical2PGradientCalculator::Trafo() const
";

%feature("docstring")  ROOT::Minuit2::Numerical2PGradientCalculator::Precision "const MnMachinePrecision& ROOT::Minuit2::Numerical2PGradientCalculator::Precision() const
";

%feature("docstring")  ROOT::Minuit2::Numerical2PGradientCalculator::Strategy "const MnStrategy& ROOT::Minuit2::Numerical2PGradientCalculator::Strategy() const
";

%feature("docstring")  ROOT::Minuit2::Numerical2PGradientCalculator::Ncycle "unsigned int ROOT::Minuit2::Numerical2PGradientCalculator::Ncycle() const
";

%feature("docstring")  ROOT::Minuit2::Numerical2PGradientCalculator::StepTolerance "double ROOT::Minuit2::Numerical2PGradientCalculator::StepTolerance() const
";

%feature("docstring")  ROOT::Minuit2::Numerical2PGradientCalculator::GradTolerance "double ROOT::Minuit2::Numerical2PGradientCalculator::GradTolerance() const
";


// File: classmumufit_1_1ObjectiveFunctionAdapter.xml
%feature("docstring") mumufit::ObjectiveFunctionAdapter "

Converts user objective function to function  ROOT expects. Handles time of life of function objects.

C++ includes: ObjectiveFunctionAdapter.h
";

%feature("docstring")  mumufit::ObjectiveFunctionAdapter::ObjectiveFunctionAdapter "ObjectiveFunctionAdapter::ObjectiveFunctionAdapter()
";

%feature("docstring")  mumufit::ObjectiveFunctionAdapter::~ObjectiveFunctionAdapter "ObjectiveFunctionAdapter::~ObjectiveFunctionAdapter()
";

%feature("docstring")  mumufit::ObjectiveFunctionAdapter::rootObjectiveFunction "const RootScalarFunction * ObjectiveFunctionAdapter::rootObjectiveFunction(fcn_scalar_t fcn, const Parameters &parameters)
";

%feature("docstring")  mumufit::ObjectiveFunctionAdapter::rootResidualFunction "const RootResidualFunction * ObjectiveFunctionAdapter::rootResidualFunction(fcn_residual_t fcn, const Parameters &parameters)
";

%feature("docstring")  mumufit::ObjectiveFunctionAdapter::numberOfCalls "int ObjectiveFunctionAdapter::numberOfCalls() const
";

%feature("docstring")  mumufit::ObjectiveFunctionAdapter::numberOfGradientCalls "int ObjectiveFunctionAdapter::numberOfGradientCalls() const
";


// File: classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.xml
%feature("docstring") ROOT::Math::OneDimMultiFunctionAdapter "

OneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one. Given a f(x1,x2,x3,....xn) transforms in a f( x_i) given the coordinate intex i and the vector x[] of the coordinates. It provides the possibility to copy and own the data array of the coordinates or to maintain internally a pointer to an external array for being more efficient. In this last case the user must garantee the life of the given passed pointer

C++ includes: OneDimFunctionAdapter.h
";

%feature("docstring")  ROOT::Math::OneDimMultiFunctionAdapter::OneDimMultiFunctionAdapter "ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::OneDimMultiFunctionAdapter(MultiFuncType f, const double *x, unsigned int icoord=0, const double *p=0)

Constructor from the function object , pointer to an external array of x values and coordinate we want to adapt 
";

%feature("docstring")  ROOT::Math::OneDimMultiFunctionAdapter::OneDimMultiFunctionAdapter "ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::OneDimMultiFunctionAdapter(MultiFuncType f, unsigned int dim=1, unsigned int icoord=0, const double *p=0)

Constructor from the function object , dimension of the function and and coordinate we want to adapt. The coordinate cached vector is created inside and eventually the values must be passed later with the SetX which will copy them 
";

%feature("docstring")  ROOT::Math::OneDimMultiFunctionAdapter::~OneDimMultiFunctionAdapter "virtual ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::~OneDimMultiFunctionAdapter()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::OneDimMultiFunctionAdapter::Clone "virtual OneDimMultiFunctionAdapter* ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::Clone() const

clone 
";

%feature("docstring")  ROOT::Math::OneDimMultiFunctionAdapter::SetX "void ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::SetX(Iterator begin, Iterator end)

Set X values in case vector is own, iterator size must match previous set dimension 
";

%feature("docstring")  ROOT::Math::OneDimMultiFunctionAdapter::SetX "void ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::SetX(double *x)

set pointer without copying the values 
";

%feature("docstring")  ROOT::Math::OneDimMultiFunctionAdapter::SetX "void ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::SetX(const double *x)

set values 
";

%feature("docstring")  ROOT::Math::OneDimMultiFunctionAdapter::SetCoord "void ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::SetCoord(int icoord)
";

%feature("docstring")  ROOT::Math::OneDimMultiFunctionAdapter::OneDimMultiFunctionAdapter "ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::OneDimMultiFunctionAdapter(const OneDimMultiFunctionAdapter &rhs)
";


// File: classROOT_1_1Math_1_1OneDimParamFunctionAdapter.xml
%feature("docstring") ROOT::Math::OneDimParamFunctionAdapter "

OneDimParamFunctionAdapter class to wrap a multi-dim parameteric function in one dimensional one. Given a f(x[],p1,...pn) transforms in a f( p_i) given the param index i and the vectors x[] and p[] of the coordinates and parameters It has to be used carefully, since for efficiency reason it does not copy the parameter object but re-uses the given pointer for the p[] vector. The ParamFuncType reference by default is not const because the operator()(x,p) is not a const method

C++ includes: OneDimFunctionAdapter.h
";

%feature("docstring")  ROOT::Math::OneDimParamFunctionAdapter::OneDimParamFunctionAdapter "ROOT::Math::OneDimParamFunctionAdapter< ParamFuncType >::OneDimParamFunctionAdapter(ParamFuncType f, const double *x, const double *p, unsigned int ipar=0)

Constructor from the function object , x value and coordinate we want to adapt 
";

%feature("docstring")  ROOT::Math::OneDimParamFunctionAdapter::~OneDimParamFunctionAdapter "ROOT::Math::OneDimParamFunctionAdapter< ParamFuncType >::~OneDimParamFunctionAdapter()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Math::OneDimParamFunctionAdapter::Clone "virtual OneDimParamFunctionAdapter* ROOT::Math::OneDimParamFunctionAdapter< ParamFuncType >::Clone() const

clone 
";


// File: classOptionContainer.xml
%feature("docstring") OptionContainer "

Stores multi option (int,double,string) in a container.

C++ includes: OptionContainer.h
";

%feature("docstring")  OptionContainer::OptionContainer "OptionContainer::OptionContainer()
";

%feature("docstring")  OptionContainer::OptionContainer "OptionContainer::OptionContainer(const OptionContainer &other)

Returns true if option with such name already exists. 
";

%feature("docstring")  OptionContainer::addOption "OptionContainer::option_t OptionContainer::addOption(const std::string &optionName, T value, const std::string &description=\"\")
";

%feature("docstring")  OptionContainer::option "OptionContainer::option_t OptionContainer::option(const std::string &optionName)
";

%feature("docstring")  OptionContainer::option "const OptionContainer::option_t OptionContainer::option(const std::string &optionName) const
";

%feature("docstring")  OptionContainer::optionValue "T OptionContainer::optionValue(const std::string &optionName) const
";

%feature("docstring")  OptionContainer::setOptionValue "void OptionContainer::setOptionValue(const std::string &optionName, T value)

Sets the value of option. Option should hold same value type already. 
";

%feature("docstring")  OptionContainer::begin "iterator OptionContainer::begin()
";

%feature("docstring")  OptionContainer::begin "const_iterator OptionContainer::begin() const
";

%feature("docstring")  OptionContainer::end "iterator OptionContainer::end()
";

%feature("docstring")  OptionContainer::end "const_iterator OptionContainer::end() const
";

%feature("docstring")  OptionContainer::size "size_t OptionContainer::size() const
";

%feature("docstring")  OptionContainer::empty "bool OptionContainer::empty() const
";


// File: classOptionContainerTest.xml
%feature("docstring") OptionContainerTest "";


// File: classmumufit_1_1Parameter.xml
%feature("docstring") mumufit::Parameter "

A fittable parameter with value, error, step, and limits.

C++ includes: Parameter.h
";

%feature("docstring")  mumufit::Parameter::Parameter "Parameter::Parameter()
";

%feature("docstring")  mumufit::Parameter::Parameter "Parameter::Parameter(const std::string &name, double value, const AttLimits &limits=AttLimits::limitless(), double step=0.0)

Fit parameter constructor.

Parameters:
-----------

name: 
unique name of fit parameters

value: 
starting value of fit parameter

limits: 
fit parameter limits

step: 
initial step of fit parameter during the minimization, will be calculated automatically, if zero. 
";

%feature("docstring")  mumufit::Parameter::name "std::string Parameter::name() const
";

%feature("docstring")  mumufit::Parameter::startValue "double Parameter::startValue() const
";

%feature("docstring")  mumufit::Parameter::limits "AttLimits Parameter::limits() const
";

%feature("docstring")  mumufit::Parameter::value "double Parameter::value() const
";

%feature("docstring")  mumufit::Parameter::setValue "void Parameter::setValue(double value)
";

%feature("docstring")  mumufit::Parameter::step "double Parameter::step() const
";

%feature("docstring")  mumufit::Parameter::error "double Parameter::error() const
";

%feature("docstring")  mumufit::Parameter::setError "void Parameter::setError(double value)
";


// File: classParameterPlan.xml
%feature("docstring") ParameterPlan "

Defines initial settings of single fit parameter and the final value which has to be found in the course of the fit.

C++ includes: ParameterPlan.h
";

%feature("docstring")  ParameterPlan::ParameterPlan "ParameterPlan::ParameterPlan(const mumufit::Parameter &param, double expected_value, double tolerance=0.01)
";

%feature("docstring")  ParameterPlan::fitParameter "mumufit::Parameter ParameterPlan::fitParameter() const
";

%feature("docstring")  ParameterPlan::expectedValue "double ParameterPlan::expectedValue() const
";

%feature("docstring")  ParameterPlan::tolerance "double ParameterPlan::tolerance() const
";

%feature("docstring")  ParameterPlan::setTolerance "void ParameterPlan::setTolerance(double tolerance)
";


// File: classmumufit_1_1Parameters.xml
%feature("docstring") mumufit::Parameters "

A collection of fit parameters.

C++ includes: Parameters.h
";

%feature("docstring")  mumufit::Parameters::Parameters "mumufit::Parameters::Parameters()=default
";

%feature("docstring")  mumufit::Parameters::add "void Parameters::add(const Parameter &par)
";

%feature("docstring")  mumufit::Parameters::begin "Parameters::const_iterator Parameters::begin() const
";

%feature("docstring")  mumufit::Parameters::end "Parameters::const_iterator Parameters::end() const
";

%feature("docstring")  mumufit::Parameters::begin "Parameters::iterator Parameters::begin()
";

%feature("docstring")  mumufit::Parameters::end "Parameters::iterator Parameters::end()
";

%feature("docstring")  mumufit::Parameters::size "size_t Parameters::size() const
";

%feature("docstring")  mumufit::Parameters::values "std::vector< double > Parameters::values() const
";

%feature("docstring")  mumufit::Parameters::setValues "void Parameters::setValues(const std::vector< double > &values)
";

%feature("docstring")  mumufit::Parameters::errors "std::vector< double > Parameters::errors() const
";

%feature("docstring")  mumufit::Parameters::setErrors "void Parameters::setErrors(const std::vector< double > &errors)
";

%feature("docstring")  mumufit::Parameters::correlationMatrix "Parameters::corr_matrix_t Parameters::correlationMatrix() const
";

%feature("docstring")  mumufit::Parameters::setCorrelationMatrix "void Parameters::setCorrelationMatrix(const corr_matrix_t &matrix)
";

%feature("docstring")  mumufit::Parameters::freeParameterCount "size_t Parameters::freeParameterCount() const

Returns number of free parameters. 
";


// File: classROOT_1_1Fit_1_1ParameterSettings.xml
%feature("docstring") ROOT::Fit::ParameterSettings "

Class, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters.

To be done: add constraints (equality and inequality) as functions of the parameters

C++ includes: ParameterSettings.h
";

%feature("docstring")  ROOT::Fit::ParameterSettings::ParameterSettings "ROOT::Fit::ParameterSettings::ParameterSettings()

Default constructor 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::ParameterSettings "ROOT::Fit::ParameterSettings::ParameterSettings(const std::string &name, double val, double err)

constructor for unlimited named Parameter 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::ParameterSettings "ROOT::Fit::ParameterSettings::ParameterSettings(const std::string &name, double val, double err, double min, double max)

constructor for double limited Parameter. The given value should be within the given limits [min,max] 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::ParameterSettings "ROOT::Fit::ParameterSettings::ParameterSettings(const std::string &name, double val)

constructor for fixed Parameter 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::Set "void ROOT::Fit::ParameterSettings::Set(const std::string &name, double value, double step)

set value and name (unlimited parameter) 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::Set "void ROOT::Fit::ParameterSettings::Set(const std::string &name, double value, double step, double lower, double upper)

set a limited parameter. The given value should be within the given limits [min,max] 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::Set "void ROOT::Fit::ParameterSettings::Set(const std::string &name, double value)

set a fixed parameter 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::~ParameterSettings "ROOT::Fit::ParameterSettings::~ParameterSettings()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::Value "double ROOT::Fit::ParameterSettings::Value() const

copy constructor and assignment operators (leave them to the compiler)

return parameter value 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::StepSize "double ROOT::Fit::ParameterSettings::StepSize() const

return step size 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::LowerLimit "double ROOT::Fit::ParameterSettings::LowerLimit() const

return lower limit value 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::UpperLimit "double ROOT::Fit::ParameterSettings::UpperLimit() const

return upper limit value 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::IsFixed "bool ROOT::Fit::ParameterSettings::IsFixed() const

check if is fixed 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::HasLowerLimit "bool ROOT::Fit::ParameterSettings::HasLowerLimit() const

check if parameter has lower limit 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::HasUpperLimit "bool ROOT::Fit::ParameterSettings::HasUpperLimit() const

check if parameter has upper limit 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::IsBound "bool ROOT::Fit::ParameterSettings::IsBound() const

check if is bound 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::IsDoubleBound "bool ROOT::Fit::ParameterSettings::IsDoubleBound() const

check if is double bound (upper AND lower limit) 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::Name "const std::string& ROOT::Fit::ParameterSettings::Name() const

return name 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::SetName "void ROOT::Fit::ParameterSettings::SetName(const std::string &name)

set name

interaction 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::Fix "void ROOT::Fit::ParameterSettings::Fix()

fix the parameter 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::Release "void ROOT::Fit::ParameterSettings::Release()

release the parameter 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::SetValue "void ROOT::Fit::ParameterSettings::SetValue(double val)

set the value 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::SetStepSize "void ROOT::Fit::ParameterSettings::SetStepSize(double err)

set the step size 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::SetLimits "void ROOT::Fit::ParameterSettings::SetLimits(double low, double up)

set a double side limit, if low == up the parameter is fixed if low > up the limits are removed The current parameter value should be within the given limits [low,up]. If the value is outside the limits, then a new parameter value is set to = (up+low)/2 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::SetUpperLimit "void ROOT::Fit::ParameterSettings::SetUpperLimit(double up)

set a single upper limit 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::SetLowerLimit "void ROOT::Fit::ParameterSettings::SetLowerLimit(double low)

set a single lower limit 
";

%feature("docstring")  ROOT::Fit::ParameterSettings::RemoveLimits "void ROOT::Fit::ParameterSettings::RemoveLimits()

remove all limit 
";


// File: classParametersTest.xml
%feature("docstring") ParametersTest "";


// File: classParameterTest.xml
%feature("docstring") ParameterTest "";


// File: classROOT_1_1Minuit2_1_1ParametricFunction.xml
%feature("docstring") ROOT::Minuit2::ParametricFunction "

Function which has parameters. For example, one could define a one-dimensional Gaussian, by considering x as an input coordinate for the evaluation of the function, and the mean and the square root of the variance as parameters.

AS OF NOW PARAMETRICFUNCTION INHERITS FROM FCNBASE INSTEAD OF GENERICFUNCTION. THIS IS ONLY BECAUSE NUMERICAL2PGRADIENTCALCULATOR NEEDS AN FCNBASE OBJECT AND WILL BE CHANGED!!!!!!!!!!!!!!!!

Todo
 ParametricFunction and all the classes that inherit from it are inheriting also  FCNBase so that the Gradient calculation has the  Up() member function. That is not really good...

C++ includes: ParametricFunction.h
";

%feature("docstring")  ROOT::Minuit2::ParametricFunction::ParametricFunction "ROOT::Minuit2::ParametricFunction::ParametricFunction(const std::vector< double > &params)

Constructor which initializes the  ParametricFunction with the parameters given as input.

Parameters:
-----------

params: 
vector containing the initial Parameter values 
";

%feature("docstring")  ROOT::Minuit2::ParametricFunction::ParametricFunction "ROOT::Minuit2::ParametricFunction::ParametricFunction(int nparams)

Constructor which initializes the  ParametricFunction by setting the number of parameters.

Parameters:
-----------

nparams: 
number of parameters of the parametric function 
";

%feature("docstring")  ROOT::Minuit2::ParametricFunction::~ParametricFunction "virtual ROOT::Minuit2::ParametricFunction::~ParametricFunction()
";

%feature("docstring")  ROOT::Minuit2::ParametricFunction::SetParameters "virtual void ROOT::Minuit2::ParametricFunction::SetParameters(const std::vector< double > &params) const

Sets the parameters of the  ParametricFunction.

Parameters:
-----------

params: 
vector containing the Parameter values 
";

%feature("docstring")  ROOT::Minuit2::ParametricFunction::GetParameters "virtual const std::vector<double>& ROOT::Minuit2::ParametricFunction::GetParameters() const

Accessor for the state of the parameters.

vector containing the present Parameter settings 
";

%feature("docstring")  ROOT::Minuit2::ParametricFunction::NumberOfParameters "virtual unsigned int ROOT::Minuit2::ParametricFunction::NumberOfParameters() const

Accessor for the number of parameters.

the number of function parameters 
";

%feature("docstring")  ROOT::Minuit2::ParametricFunction::GetGradient "virtual std::vector<double> ROOT::Minuit2::ParametricFunction::GetGradient(const std::vector< double > &x) const

Member function returning the Gradient of the function with respect to its variables (but without including gradients with respect to its internal parameters).

Parameters:
-----------

x: 
vector containing the coordinates of the point where the Gradient is to be calculated.

the Gradient vector of the function at the given point. 
";


// File: classPlanFactory.xml
%feature("docstring") PlanFactory "

Factory to generate plans for fitting objective functions.

C++ includes: PlanFactory.h
";

%feature("docstring")  PlanFactory::PlanFactory "PlanFactory::PlanFactory()
";


// File: classROOT_1_1Fit_1_1PoissonLikelihoodFCN.xml
%feature("docstring") ROOT::Fit::PoissonLikelihoodFCN "

class evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case

C++ includes: PoissonLikelihoodFCN.h
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::PoissonLikelihoodFCN "ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::PoissonLikelihoodFCN(const std::shared_ptr< BinData > &data, const std::shared_ptr< IModelFunction > &func, int weight=0, bool extended=true, const ::ROOT::Fit::ExecutionPolicy &executionPolicy=::ROOT::Fit::ExecutionPolicy::kSerial)

Constructor from unbin data set and model function (pdf) 
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::PoissonLikelihoodFCN "ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::PoissonLikelihoodFCN(const BinData &data, const IModelFunction &func, int weight=0, bool extended=true, const ::ROOT::Fit::ExecutionPolicy &executionPolicy=::ROOT::Fit::ExecutionPolicy::kSerial)

Constructor from unbin data set and model function (pdf) managed by the users 
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::~PoissonLikelihoodFCN "virtual ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::~PoissonLikelihoodFCN()

Destructor (no operations) 
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::PoissonLikelihoodFCN "ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::PoissonLikelihoodFCN(const PoissonLikelihoodFCN &f)

Copy constructor 
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::Clone "virtual BaseFunction* ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::Clone() const

clone the function (need to return Base for Windows) 
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::NFitPoints "virtual unsigned int ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::NFitPoints() const
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::DataElement "virtual double ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::DataElement(const double *x, unsigned int i, double *g) const

i-th likelihood element and its gradient 
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::Gradient "virtual void ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::Gradient(const double *x, double *g) const

evaluate gradient 
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::Type "virtual BaseObjFunction::Type_t ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::Type() const

get type of fit method function 
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::IsWeighted "bool ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::IsWeighted() const
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::UseSumOfWeights "void ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::UseSumOfWeights()
";

%feature("docstring")  ROOT::Fit::PoissonLikelihoodFCN::UseSumOfWeightSquare "void ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >::UseSumOfWeightSquare(bool on=true)
";


// File: classPyCallback.xml
%feature("docstring") PyCallback "

Base class to wrap Python callable and pass it to C++. Used in swig interface file, intended to be overloaded from Python.

C++ includes: PyCallback.h
";

%feature("docstring")  PyCallback::PyCallback "PyCallback::PyCallback(CallbackType callback_type=SCALAR)
";

%feature("docstring")  PyCallback::~PyCallback "PyCallback::~PyCallback()
";

%feature("docstring")  PyCallback::callback_type "PyCallback::CallbackType PyCallback::callback_type() const
";

%feature("docstring")  PyCallback::call_scalar "double PyCallback::call_scalar(mumufit::Parameters pars)

Call Python callable and returns its result. Intended to be overloaded in Python.

Parameters:
-----------

pars: 
Fit parameters object (intentionally passed by value).

value of objective function. 
";

%feature("docstring")  PyCallback::call_residuals "std::vector< double > PyCallback::call_residuals(mumufit::Parameters pars)

Call Python callable and returns its result. Intended to be overloaded in Python.

Parameters:
-----------

pars: 
Fit parameters object (intentionally passed by value).

vector of residuals 
";


// File: classROOT_1_1Math_1_1RandomFunctions.xml
%feature("docstring") ROOT::Math::RandomFunctions "";

%feature("docstring")  ROOT::Math::RandomFunctions::RandomFunctions "ROOT::Math::RandomFunctions< Engine, EngineBaseType >::RandomFunctions(Engine &rng)
";

%feature("docstring")  ROOT::Math::RandomFunctions::~RandomFunctions "ROOT::Math::RandomFunctions< Engine, EngineBaseType >::~RandomFunctions()

destructor (no op) we do not mantain the engine) 
";

%feature("docstring")  ROOT::Math::RandomFunctions::Binomial "int ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Binomial(int ntot, double prob)

Generate binomial numbers. 
";

%feature("docstring")  ROOT::Math::RandomFunctions::BreitWigner "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::BreitWigner(double mean, double gamma)

Return a number distributed following a BreitWigner function with mean and gamma. 
";

%feature("docstring")  ROOT::Math::RandomFunctions::Circle "void ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Circle(double &x, double &y, double r)

Generates random vectors, uniformly distributed over a circle of given radius. Input : r = circle radius Output: x,y a random 2-d vector of length r 
";

%feature("docstring")  ROOT::Math::RandomFunctions::Exp "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Exp(double tau)

Returns an exponential deviate. exp( -t/tau ) 
";

%feature("docstring")  ROOT::Math::RandomFunctions::GausBM "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::GausBM(double mean, double sigma)

generate Gaussian number using Box-Muller method 
";

%feature("docstring")  ROOT::Math::RandomFunctions::GausACR "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::GausACR(double mean, double sigma)

generate random numbers according to the Accemptance-Complemet-Ratio method 
";

%feature("docstring")  ROOT::Math::RandomFunctions::Landau "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Landau(double mu, double sigma)

Generate a random number following a Landau distribution with location parameter mu and scale parameter sigma: Landau( (x-mu)/sigma ) 
";

%feature("docstring")  ROOT::Math::RandomFunctions::Poisson "int ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Poisson(double mean)

Generates a random integer N according to a Poisson law. Prob(N) = exp(-mean)*mean^N/Factorial(N) 
";

%feature("docstring")  ROOT::Math::RandomFunctions::PoissonD "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::PoissonD(double mean)
";

%feature("docstring")  ROOT::Math::RandomFunctions::Rannor "void ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Rannor(double &a, double &b)

Generate numbers distributed following a gaussian with mean=0 and sigma=1. Using the Box-Muller method 
";

%feature("docstring")  ROOT::Math::RandomFunctions::Sphere "void ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Sphere(double &x, double &y, double &z, double r)

Generates random vectors, uniformly distributed over the surface of a sphere of given radius. 
";

%feature("docstring")  ROOT::Math::RandomFunctions::Uniform "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Uniform(double a, double b)

generate random numbers following a Uniform distribution in the [a,b] interval 
";

%feature("docstring")  ROOT::Math::RandomFunctions::Uniform "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Uniform(double a)

generate random numbers following a Uniform distribution in the [0,a] interval 
";

%feature("docstring")  ROOT::Math::RandomFunctions::Gaus "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Gaus(double mean, double sigma)

generate Gaussian number using defqault method 
";

%feature("docstring")  ROOT::Math::RandomFunctions::Gamma "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Gamma(double, double)

methods which are only for GSL random generators

Gamma functions (not implemented here, requires a GSL random engine) 
";

%feature("docstring")  ROOT::Math::RandomFunctions::Beta "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Beta(double, double)
";

%feature("docstring")  ROOT::Math::RandomFunctions::LogNormal "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::LogNormal(double, double)
";

%feature("docstring")  ROOT::Math::RandomFunctions::ChiSquare "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::ChiSquare(double)
";

%feature("docstring")  ROOT::Math::RandomFunctions::Rayleigh "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Rayleigh(double)
";

%feature("docstring")  ROOT::Math::RandomFunctions::Logistic "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Logistic(double)
";

%feature("docstring")  ROOT::Math::RandomFunctions::Pareto "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::Pareto(double, double)
";

%feature("docstring")  ROOT::Math::RandomFunctions::FDist "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::FDist(double, double)
";

%feature("docstring")  ROOT::Math::RandomFunctions::tDist "double ROOT::Math::RandomFunctions< Engine, EngineBaseType >::tDist(double)
";

%feature("docstring")  ROOT::Math::RandomFunctions::NegativeBinomial "unsigned int ROOT::Math::RandomFunctions< Engine, EngineBaseType >::NegativeBinomial(double, double)
";

%feature("docstring")  ROOT::Math::RandomFunctions::MultiNomial "std::vector<unsigned int> ROOT::Math::RandomFunctions< Engine, EngineBaseType >::MultiNomial(unsigned int, const std::vector< double > &)
";


// File: classROOT_1_1Math_1_1RandomFunctions_3_01EngineType_00_01ROOT_1_1Math_1_1GSLRandomEngine_01_4.xml
%feature("docstring") ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine > "

Specialized implementation of the Random functions based on the GSL library. These will work onlmy with a  GSLRandomEngine type

C++ includes: GSLRandomFunctions.h
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::RandomFunctions "
ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::RandomFunctions()
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::RandomFunctions "
ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::RandomFunctions(EngineType &rng)
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Engine "
EngineType& ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Engine()
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::GausZig "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::GausZig(double mean, double sigma)
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Gaus "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Gaus(double mean=0, double sigma=1)

Gaussian distribution. Default method (use Ziggurat) 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::GausBM "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::GausBM(double mean=0, double sigma=1)

Gaussian distribution (Box-Muller method) 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::GausR "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::GausR(double mean=0, double sigma=1)

Gaussian distribution (Ratio Method) 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::GaussianTail "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::GaussianTail(double a, double sigma=1)

Gaussian Tail distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Gaussian2D "
void ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Gaussian2D(double sigmaX, double sigmaY, double rho, double &x, double &y)

Bivariate Gaussian distribution with correlation 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Exp "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Exp(double tau)

Exponential distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::BreitWigner "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::BreitWigner(double mean=0., double gamma=1)

Breit Wigner distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Landau "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Landau(double mean=0, double sigma=1)

Landau distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Gamma "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Gamma(double a, double b)

Gamma distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Beta "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Beta(double a, double b)

Beta distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::LogNormal "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::LogNormal(double zeta, double sigma)

Log Normal distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::ChiSquare "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::ChiSquare(double nu)

Chi square distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::FDist "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::FDist(double nu1, double nu2)

F distrbution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::tDist "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::tDist(double nu)

t student distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Rayleigh "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Rayleigh(double sigma)

Rayleigh distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Logistic "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Logistic(double a)

Logistic distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Pareto "
double ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Pareto(double a, double b)

Pareto distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Circle "
void ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Circle(double &x, double &y, double r=1)

generate random numbers in a 2D circle of radious 1 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Sphere "
void ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Sphere(double &x, double &y, double &z, double r=1)

generate random numbers in a 3D sphere of radious 1 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Poisson "
unsigned int ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Poisson(double mu)

Poisson distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Binomial "
unsigned int ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Binomial(unsigned int ntot, double prob)

Binomial distribution 
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::NegativeBinomial "
unsigned int ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::NegativeBinomial(double n, double prob)

Negative Binomial distribution First parameter is n, second is probability To be consistent with  Random::Binomial
";

%feature("docstring")  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Multinomial "
std::vector<unsigned int> ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >::Multinomial(unsigned int ntot, const std::vector< double > &p)

Multinomial distribution 
";


// File: classROOT_1_1Math_1_1RandomFunctionsImpl.xml
%feature("docstring") ROOT::Math::RandomFunctionsImpl "

Definition of the generic impelmentation class for the  RandomFunctions. Needs to have specialized implementations on the different type of engines

C++ includes: RandomFunctions.h
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl::SetEngine "void ROOT::Math::RandomFunctionsImpl< EngineBaseType >::SetEngine(void *)
";


// File: classROOT_1_1Math_1_1RandomFunctionsImpl_3_01TRandomEngine_01_4.xml
%feature("docstring") ROOT::Math::RandomFunctionsImpl< TRandomEngine > "

Implementation class for the RandomFunction for all the engined that derives from  TRandomEngine class, which defines an interface which has TRandomEngine::Rndm() In this way we can have a common implementation for the  RandomFunctions

C++ includes: RandomFunctions.h
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::RandomFunctionsImpl "
ROOT::Math::RandomFunctionsImpl< TRandomEngine >::RandomFunctionsImpl()

class constructor 
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::SetEngine "
void ROOT::Math::RandomFunctionsImpl< TRandomEngine >::SetEngine(void *r)
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Binomial "
int ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Binomial(int ntot, double prob)

Generate binomial numbers. 
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::BreitWigner "
double ROOT::Math::RandomFunctionsImpl< TRandomEngine >::BreitWigner(double mean, double gamma)

Return a number distributed following a BreitWigner function with mean and gamma. 
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Circle "
void ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Circle(double &x, double &y, double r)

Generates random vectors, uniformly distributed over a circle of given radius. Input : r = circle radius Output: x,y a random 2-d vector of length r 
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Exp "
double ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Exp(double tau)

Returns an exponential deviate. exp( -t/tau ) 
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::GausBM "
double ROOT::Math::RandomFunctionsImpl< TRandomEngine >::GausBM(double mean, double sigma)

generate Gaussian number using Box-Muller method 
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::GausACR "
double ROOT::Math::RandomFunctionsImpl< TRandomEngine >::GausACR(double mean, double sigma)

generate random numbers according to the Accemptance-Complemet-Ratio method 
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Poisson "
int ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Poisson(double mean)

Generate a random number following a Landau distribution with location parameter mu and scale parameter sigma: Landau( (x-mu)/sigma ) Generates a random integer N according to a Poisson law. Prob(N) = exp(-mean)*mean^N/Factorial(N) 
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::PoissonD "
double ROOT::Math::RandomFunctionsImpl< TRandomEngine >::PoissonD(double mean)
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Rannor "
void ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Rannor(double &a, double &b)

Generate numbers distributed following a gaussian with mean=0 and sigma=1. Using the Box-Muller method 
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Sphere "
void ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Sphere(double &x, double &y, double &z, double r)

Generates random vectors, uniformly distributed over the surface of a sphere of given radius. 
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Uniform "
double ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Uniform(double a, double b)

generate random numbers following a Uniform distribution in the [a,b] interval 
";

%feature("docstring")  ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Uniform "
double ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Uniform(double a)
";


// File: classRealLimits.xml
%feature("docstring") RealLimits "

Limits for a real fit parameter.

C++ includes: RealLimits.h
";

%feature("docstring")  RealLimits::RealLimits "RealLimits::RealLimits()
";

%feature("docstring")  RealLimits::hasLowerLimit "bool RealLimits::hasLowerLimit() const

if has lower limit 
";

%feature("docstring")  RealLimits::lowerLimit "double RealLimits::lowerLimit() const

Returns lower limit. 
";

%feature("docstring")  RealLimits::setLowerLimit "void RealLimits::setLowerLimit(double value)

Sets lower limit. 
";

%feature("docstring")  RealLimits::removeLowerLimit "void RealLimits::removeLowerLimit()

remove lower limit 
";

%feature("docstring")  RealLimits::hasUpperLimit "bool RealLimits::hasUpperLimit() const

if has upper limit 
";

%feature("docstring")  RealLimits::upperLimit "double RealLimits::upperLimit() const

Returns upper limit. 
";

%feature("docstring")  RealLimits::setUpperLimit "void RealLimits::setUpperLimit(double value)

Sets upper limit. 
";

%feature("docstring")  RealLimits::removeUpperLimit "void RealLimits::removeUpperLimit()

remove upper limit 
";

%feature("docstring")  RealLimits::hasLowerAndUpperLimits "bool RealLimits::hasLowerAndUpperLimits() const

if has lower and upper limit 
";

%feature("docstring")  RealLimits::setLimits "void RealLimits::setLimits(double xmin, double xmax)

Sets lower and upper limits. 
";

%feature("docstring")  RealLimits::removeLimits "void RealLimits::removeLimits()

remove limits 
";

%feature("docstring")  RealLimits::isInRange "bool RealLimits::isInRange(double value) const

returns true if proposed value is in limits range 
";

%feature("docstring")  RealLimits::toString "std::string RealLimits::toString() const
";

%feature("docstring")  RealLimits::isLimitless "bool RealLimits::isLimitless() const
";

%feature("docstring")  RealLimits::isPositive "bool RealLimits::isPositive() const
";

%feature("docstring")  RealLimits::isNonnegative "bool RealLimits::isNonnegative() const
";

%feature("docstring")  RealLimits::isLowerLimited "bool RealLimits::isLowerLimited() const
";

%feature("docstring")  RealLimits::isUpperLimited "bool RealLimits::isUpperLimited() const
";

%feature("docstring")  RealLimits::isLimited "bool RealLimits::isLimited() const
";


// File: classRealLimitsTest.xml
%feature("docstring") RealLimitsTest "";


// File: classmumufit_1_1ResidualFunctionAdapter.xml
%feature("docstring") mumufit::ResidualFunctionAdapter "

Provides  RootResidualFunction which will be minimizer by  ROOT. Converts  ROOT calls to the call of fcn_residual_t.

C++ includes: ResidualFunctionAdapter.h
";

%feature("docstring")  mumufit::ResidualFunctionAdapter::ResidualFunctionAdapter "ResidualFunctionAdapter::ResidualFunctionAdapter(fcn_residual_t func, const Parameters &parameters)
";

%feature("docstring")  mumufit::ResidualFunctionAdapter::rootResidualFunction "const RootResidualFunction * ResidualFunctionAdapter::rootResidualFunction()
";


// File: classResidualTestPlan.xml
%feature("docstring") ResidualTestPlan "";

%feature("docstring")  ResidualTestPlan::ResidualTestPlan "ResidualTestPlan::ResidualTestPlan(const std::string &name, test_funct_t func)
";

%feature("docstring")  ResidualTestPlan::residualFunction "fcn_residual_t ResidualTestPlan::residualFunction()
";

%feature("docstring")  ResidualTestPlan::checkMinimizer "bool ResidualTestPlan::checkMinimizer(mumufit::Minimizer &minimizer)

Runs minimization and check minimization result. 
";


// File: structrng__state__st.xml
%feature("docstring") rng_state_st "";


// File: classRootResidualFunction.xml
%feature("docstring") RootResidualFunction "

Minimizer function with access to single data element residuals, required by Fumili2 and GSLMultiMin minimizers.

C++ includes: RootResidualFunction.h
";

%feature("docstring")  RootResidualFunction::RootResidualFunction "RootResidualFunction::RootResidualFunction(scalar_function_t objective_fun, gradient_function_t gradient_fun, size_t npars, size_t ndatasize)

Constructs  RootResidualFunction. 
";

%feature("docstring")  RootResidualFunction::Type "RootResidualFunction::Type_t RootResidualFunction::Type() const override

return the type of method, override if needed 
";

%feature("docstring")  RootResidualFunction::Clone "ROOT::Math::IMultiGenFunction * RootResidualFunction::Clone() const override
";

%feature("docstring")  RootResidualFunction::DataElement "double RootResidualFunction::DataElement(const double *pars, unsigned int index, double *gradients=0) const override

Evaluation of single data element residual. Will be called by  ROOT minimizer.

Returns residual value for given data element index. Transform call of ancient pointer based function to safer gradient_function_t.

Parameters:
-----------

pars: 
array of fit parameter values from the minimizer

index: 
index of residual element

gradients: 
if not zero, then array where we have to put gradients

value of residual for given data element index 
";


// File: classRootScalarFunction.xml
%feature("docstring") RootScalarFunction "

The chi2 function for use in minimizers.

C++ includes: RootScalarFunction.h
";

%feature("docstring")  RootScalarFunction::RootScalarFunction "RootScalarFunction::RootScalarFunction(root_scalar_t fcn, int ndims)
";


// File: classRosenbrockPlan.xml
%feature("docstring") RosenbrockPlan "

Setting for standalone fit of Rosenbrock function.

C++ includes: PlanCases.h
";

%feature("docstring")  RosenbrockPlan::RosenbrockPlan "RosenbrockPlan::RosenbrockPlan()

Plan to minimize a Rosenbrock function. start point: F(-1.2,1.0) = 24.20 minimum : F(1.0,1.0) = 0. 
";


// File: classmumufit_1_1ScalarFunctionAdapter.xml
%feature("docstring") mumufit::ScalarFunctionAdapter "

Converts user objective function to chi2 like function which  ROOT expects.

More precisely,  ROOT call to std::function<double(const double*)> will cause the call of user function std::function<double(std::vector<double>)>, where function input parameters will be current values fit parameters.

C++ includes: ScalarFunctionAdapter.h
";

%feature("docstring")  mumufit::ScalarFunctionAdapter::ScalarFunctionAdapter "ScalarFunctionAdapter::ScalarFunctionAdapter(fcn_scalar_t func, const Parameters &parameters)
";

%feature("docstring")  mumufit::ScalarFunctionAdapter::rootObjectiveFunction "const RootScalarFunction * ScalarFunctionAdapter::rootObjectiveFunction()
";


// File: classScalarTestPlan.xml
%feature("docstring") ScalarTestPlan "

Testing logic for Minimizer and scalar-type objective functions.

C++ includes: ScalarTestPlan.h
";

%feature("docstring")  ScalarTestPlan::ScalarTestPlan "ScalarTestPlan::ScalarTestPlan(const std::string &name, scalar_function_t func, double expected_minimum, double tolerance=0.01)
";

%feature("docstring")  ScalarTestPlan::checkMinimizer "bool ScalarTestPlan::checkMinimizer(mumufit::Minimizer &minimizer)

Runs minimization and check minimization result. 
";


// File: classROOT_1_1Minuit2_1_1ScanBuilder.xml
%feature("docstring") ROOT::Minuit2::ScanBuilder "

Performs a minimization using the simplex method of Nelder and Mead (ref. Comp. J. 7, 308 (1965)).

C++ includes: ScanBuilder.h
";

%feature("docstring")  ROOT::Minuit2::ScanBuilder::ScanBuilder "ROOT::Minuit2::ScanBuilder::ScanBuilder()
";

%feature("docstring")  ROOT::Minuit2::ScanBuilder::~ScanBuilder "ROOT::Minuit2::ScanBuilder::~ScanBuilder()
";

%feature("docstring")  ROOT::Minuit2::ScanBuilder::Minimum "virtual FunctionMinimum ROOT::Minuit2::ScanBuilder::Minimum(const MnFcn &, const GradientCalculator &, const MinimumSeed &, const MnStrategy &, unsigned int, double) const
";


// File: classROOT_1_1Minuit2_1_1ScanMinimizer.xml
%feature("docstring") ROOT::Minuit2::ScanMinimizer "

Class implementing the required methods for a minimization using SCAN API is provided in the upper  ROOT::Minuit2::ModularFunctionMinimizer class

C++ includes: ScanMinimizer.h
";

%feature("docstring")  ROOT::Minuit2::ScanMinimizer::ScanMinimizer "ROOT::Minuit2::ScanMinimizer::ScanMinimizer()
";

%feature("docstring")  ROOT::Minuit2::ScanMinimizer::~ScanMinimizer "ROOT::Minuit2::ScanMinimizer::~ScanMinimizer()
";

%feature("docstring")  ROOT::Minuit2::ScanMinimizer::SeedGenerator "const MinimumSeedGenerator& ROOT::Minuit2::ScanMinimizer::SeedGenerator() const
";

%feature("docstring")  ROOT::Minuit2::ScanMinimizer::Builder "const MinimumBuilder& ROOT::Minuit2::ScanMinimizer::Builder() const
";

%feature("docstring")  ROOT::Minuit2::ScanMinimizer::Builder "MinimumBuilder& ROOT::Minuit2::ScanMinimizer::Builder()
";


// File: classSimAnMinimizer.xml
%feature("docstring") SimAnMinimizer "

Wrapper for the CERN  ROOT facade of the GSL simmulated annealing minimizer.

C++ includes: SimAnMinimizer.h
";

%feature("docstring")  SimAnMinimizer::SimAnMinimizer "SimAnMinimizer::SimAnMinimizer()
";

%feature("docstring")  SimAnMinimizer::~SimAnMinimizer "SimAnMinimizer::~SimAnMinimizer() override
";

%feature("docstring")  SimAnMinimizer::setPrintLevel "void SimAnMinimizer::setPrintLevel(int value)

Sets minimizer internal print level. Default value is 0 (silent). 
";

%feature("docstring")  SimAnMinimizer::printLevel "int SimAnMinimizer::printLevel() const
";

%feature("docstring")  SimAnMinimizer::setMaxIterations "void SimAnMinimizer::setMaxIterations(int value)

Sets maximum number of iterations to try at each step. 
";

%feature("docstring")  SimAnMinimizer::maxIterations "int SimAnMinimizer::maxIterations() const
";

%feature("docstring")  SimAnMinimizer::setIterationsAtEachTemp "void SimAnMinimizer::setIterationsAtEachTemp(int value)

Sets number of iterations at each temperature. 
";

%feature("docstring")  SimAnMinimizer::iterationsAtEachTemp "int SimAnMinimizer::iterationsAtEachTemp() const
";

%feature("docstring")  SimAnMinimizer::setStepSize "void SimAnMinimizer::setStepSize(double value)

Sets max step size used in random walk. 
";

%feature("docstring")  SimAnMinimizer::stepSize "double SimAnMinimizer::stepSize() const
";

%feature("docstring")  SimAnMinimizer::setBoltzmannK "void SimAnMinimizer::setBoltzmannK(double value)

Sets Boltzmann distribution parameter: k. 
";

%feature("docstring")  SimAnMinimizer::boltzmannK "double SimAnMinimizer::boltzmannK() const
";

%feature("docstring")  SimAnMinimizer::setBoltzmannInitialTemp "void SimAnMinimizer::setBoltzmannInitialTemp(double value)

Sets Boltzmann distribution parameter: initial temperature. 
";

%feature("docstring")  SimAnMinimizer::boltzmannInitialTemp "double SimAnMinimizer::boltzmannInitialTemp() const
";

%feature("docstring")  SimAnMinimizer::setBoltzmannMu "void SimAnMinimizer::setBoltzmannMu(double value)

Sets Boltzmann distribution parameter: mu. 
";

%feature("docstring")  SimAnMinimizer::boltzmannMu "double SimAnMinimizer::boltzmannMu() const
";

%feature("docstring")  SimAnMinimizer::setBoltzmannMinTemp "void SimAnMinimizer::setBoltzmannMinTemp(double value)

Sets Boltzmann distribution parameter: minimal temperature. 
";

%feature("docstring")  SimAnMinimizer::boltzmannMinTemp "double SimAnMinimizer::boltzmannMinTemp() const
";

%feature("docstring")  SimAnMinimizer::statusMap "std::map< std::string, std::string > SimAnMinimizer::statusMap() const override

Returns map of string representing different minimizer statuses. 
";


// File: classROOT_1_1Minuit2_1_1SimplexBuilder.xml
%feature("docstring") ROOT::Minuit2::SimplexBuilder "

Performs a minimization using the simplex method of Nelder and Mead (ref. Comp. J. 7, 308 (1965)).

C++ includes: SimplexBuilder.h
";

%feature("docstring")  ROOT::Minuit2::SimplexBuilder::SimplexBuilder "ROOT::Minuit2::SimplexBuilder::SimplexBuilder()
";

%feature("docstring")  ROOT::Minuit2::SimplexBuilder::~SimplexBuilder "ROOT::Minuit2::SimplexBuilder::~SimplexBuilder()
";

%feature("docstring")  ROOT::Minuit2::SimplexBuilder::Minimum "virtual FunctionMinimum ROOT::Minuit2::SimplexBuilder::Minimum(const MnFcn &, const GradientCalculator &, const MinimumSeed &, const MnStrategy &, unsigned int, double) const
";


// File: classROOT_1_1Minuit2_1_1SimplexMinimizer.xml
%feature("docstring") ROOT::Minuit2::SimplexMinimizer "

Class implementing the required methods for a minimization using Simplex. API is provided in the upper  ROOT::Minuit2::ModularFunctionMinimizer class

C++ includes: SimplexMinimizer.h
";

%feature("docstring")  ROOT::Minuit2::SimplexMinimizer::SimplexMinimizer "ROOT::Minuit2::SimplexMinimizer::SimplexMinimizer()
";

%feature("docstring")  ROOT::Minuit2::SimplexMinimizer::~SimplexMinimizer "ROOT::Minuit2::SimplexMinimizer::~SimplexMinimizer()
";

%feature("docstring")  ROOT::Minuit2::SimplexMinimizer::SeedGenerator "const MinimumSeedGenerator& ROOT::Minuit2::SimplexMinimizer::SeedGenerator() const
";

%feature("docstring")  ROOT::Minuit2::SimplexMinimizer::Builder "const MinimumBuilder& ROOT::Minuit2::SimplexMinimizer::Builder() const
";

%feature("docstring")  ROOT::Minuit2::SimplexMinimizer::Builder "MinimumBuilder& ROOT::Minuit2::SimplexMinimizer::Builder()
";


// File: classROOT_1_1Minuit2_1_1SimplexParameters.xml
%feature("docstring") ROOT::Minuit2::SimplexParameters "

class describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process.

C++ includes: SimplexParameters.h
";

%feature("docstring")  ROOT::Minuit2::SimplexParameters::SimplexParameters "ROOT::Minuit2::SimplexParameters::SimplexParameters(const std::vector< std::pair< double, MnAlgebraicVector > > &simpl, unsigned int jh, unsigned int jl)
";

%feature("docstring")  ROOT::Minuit2::SimplexParameters::~SimplexParameters "ROOT::Minuit2::SimplexParameters::~SimplexParameters()
";

%feature("docstring")  ROOT::Minuit2::SimplexParameters::Update "void ROOT::Minuit2::SimplexParameters::Update(double, const MnAlgebraicVector &)
";

%feature("docstring")  ROOT::Minuit2::SimplexParameters::Simplex "const std::vector<std::pair<double, MnAlgebraicVector> >& ROOT::Minuit2::SimplexParameters::Simplex() const
";

%feature("docstring")  ROOT::Minuit2::SimplexParameters::Jh "unsigned int ROOT::Minuit2::SimplexParameters::Jh() const
";

%feature("docstring")  ROOT::Minuit2::SimplexParameters::Jl "unsigned int ROOT::Minuit2::SimplexParameters::Jl() const
";

%feature("docstring")  ROOT::Minuit2::SimplexParameters::Edm "double ROOT::Minuit2::SimplexParameters::Edm() const
";

%feature("docstring")  ROOT::Minuit2::SimplexParameters::Dirin "MnAlgebraicVector ROOT::Minuit2::SimplexParameters::Dirin() const
";


// File: classROOT_1_1Minuit2_1_1SimplexSeedGenerator.xml
%feature("docstring") ROOT::Minuit2::SimplexSeedGenerator "

generate Simplex starting point (state)

C++ includes: SimplexSeedGenerator.h
";

%feature("docstring")  ROOT::Minuit2::SimplexSeedGenerator::SimplexSeedGenerator "ROOT::Minuit2::SimplexSeedGenerator::SimplexSeedGenerator()
";

%feature("docstring")  ROOT::Minuit2::SimplexSeedGenerator::~SimplexSeedGenerator "ROOT::Minuit2::SimplexSeedGenerator::~SimplexSeedGenerator()
";


// File: classROOT_1_1Minuit2_1_1SinParameterTransformation.xml
%feature("docstring") ROOT::Minuit2::SinParameterTransformation "

class for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one

C++ includes: SinParameterTransformation.h
";

%feature("docstring")  ROOT::Minuit2::SinParameterTransformation::SinParameterTransformation "ROOT::Minuit2::SinParameterTransformation::SinParameterTransformation()
";

%feature("docstring")  ROOT::Minuit2::SinParameterTransformation::~SinParameterTransformation "ROOT::Minuit2::SinParameterTransformation::~SinParameterTransformation()
";

%feature("docstring")  ROOT::Minuit2::SinParameterTransformation::Int2ext "double ROOT::Minuit2::SinParameterTransformation::Int2ext(double Value, double Upper, double Lower) const
";

%feature("docstring")  ROOT::Minuit2::SinParameterTransformation::Ext2int "double ROOT::Minuit2::SinParameterTransformation::Ext2int(double Value, double Upper, double Lower, const MnMachinePrecision &) const
";

%feature("docstring")  ROOT::Minuit2::SinParameterTransformation::DInt2Ext "double ROOT::Minuit2::SinParameterTransformation::DInt2Ext(double Value, double Upper, double Lower) const
";


// File: classROOT_1_1Math_1_1SinVariableTransformation.xml
%feature("docstring") ROOT::Math::SinVariableTransformation "

Sin Transformation class for dealing with double bounded variables

C++ includes: MinimizerVariableTransformation.h
";

%feature("docstring")  ROOT::Math::SinVariableTransformation::~SinVariableTransformation "virtual ROOT::Math::SinVariableTransformation::~SinVariableTransformation()
";

%feature("docstring")  ROOT::Math::SinVariableTransformation::Int2ext "double ROOT::Math::SinVariableTransformation::Int2ext(double value, double lower, double upper) const
";

%feature("docstring")  ROOT::Math::SinVariableTransformation::Ext2int "double ROOT::Math::SinVariableTransformation::Ext2int(double value, double lower, double upper) const
";

%feature("docstring")  ROOT::Math::SinVariableTransformation::DInt2Ext "double ROOT::Math::SinVariableTransformation::DInt2Ext(double value, double lower, double upper) const
";


// File: classROOT_1_1Fit_1_1SparseData.xml
%feature("docstring") ROOT::Fit::SparseData "";

%feature("docstring")  ROOT::Fit::SparseData::SparseData "ROOT::Fit::SparseData::SparseData(std::vector< double > &min, std::vector< double > &max)
";

%feature("docstring")  ROOT::Fit::SparseData::SparseData "ROOT::Fit::SparseData::SparseData(const unsigned int dim, double min[], double max[])
";

%feature("docstring")  ROOT::Fit::SparseData::~SparseData "ROOT::Fit::SparseData::~SparseData()
";

%feature("docstring")  ROOT::Fit::SparseData::NPoints "unsigned int ROOT::Fit::SparseData::NPoints() const
";

%feature("docstring")  ROOT::Fit::SparseData::NDim "unsigned int ROOT::Fit::SparseData::NDim() const
";

%feature("docstring")  ROOT::Fit::SparseData::Add "void ROOT::Fit::SparseData::Add(std::vector< double > &min, std::vector< double > &max, const double content, const double error=1.0)
";

%feature("docstring")  ROOT::Fit::SparseData::GetPoint "void ROOT::Fit::SparseData::GetPoint(const unsigned int i, std::vector< double > &min, std::vector< double > &max, double &content, double &error)
";

%feature("docstring")  ROOT::Fit::SparseData::PrintList "void ROOT::Fit::SparseData::PrintList() const
";

%feature("docstring")  ROOT::Fit::SparseData::GetBinData "void ROOT::Fit::SparseData::GetBinData(BinData &) const
";

%feature("docstring")  ROOT::Fit::SparseData::GetBinDataIntegral "void ROOT::Fit::SparseData::GetBinDataIntegral(BinData &) const
";

%feature("docstring")  ROOT::Fit::SparseData::GetBinDataNoZeros "void ROOT::Fit::SparseData::GetBinDataNoZeros(BinData &) const
";


// File: classROOT_1_1Minuit2_1_1SqrtLowParameterTransformation.xml
%feature("docstring") ROOT::Minuit2::SqrtLowParameterTransformation "

Transformation from external to internal Parameter based on sqrt(1 + x**2)

This transformation applies for the case of single side Lower Parameter limits

C++ includes: SqrtLowParameterTransformation.h
";

%feature("docstring")  ROOT::Minuit2::SqrtLowParameterTransformation::SqrtLowParameterTransformation "ROOT::Minuit2::SqrtLowParameterTransformation::SqrtLowParameterTransformation()
";

%feature("docstring")  ROOT::Minuit2::SqrtLowParameterTransformation::~SqrtLowParameterTransformation "ROOT::Minuit2::SqrtLowParameterTransformation::~SqrtLowParameterTransformation()
";

%feature("docstring")  ROOT::Minuit2::SqrtLowParameterTransformation::Int2ext "double ROOT::Minuit2::SqrtLowParameterTransformation::Int2ext(double Value, double Lower) const
";

%feature("docstring")  ROOT::Minuit2::SqrtLowParameterTransformation::Ext2int "double ROOT::Minuit2::SqrtLowParameterTransformation::Ext2int(double Value, double Lower, const MnMachinePrecision &) const
";

%feature("docstring")  ROOT::Minuit2::SqrtLowParameterTransformation::DInt2Ext "double ROOT::Minuit2::SqrtLowParameterTransformation::DInt2Ext(double Value, double Lower) const
";


// File: classROOT_1_1Math_1_1SqrtLowVariableTransformation.xml
%feature("docstring") ROOT::Math::SqrtLowVariableTransformation "

Sqrt Transformation class for dealing with lower bounded variables

C++ includes: MinimizerVariableTransformation.h
";

%feature("docstring")  ROOT::Math::SqrtLowVariableTransformation::~SqrtLowVariableTransformation "virtual ROOT::Math::SqrtLowVariableTransformation::~SqrtLowVariableTransformation()
";

%feature("docstring")  ROOT::Math::SqrtLowVariableTransformation::Int2ext "double ROOT::Math::SqrtLowVariableTransformation::Int2ext(double value, double lower, double upper) const
";

%feature("docstring")  ROOT::Math::SqrtLowVariableTransformation::Ext2int "double ROOT::Math::SqrtLowVariableTransformation::Ext2int(double value, double lower, double upper) const
";

%feature("docstring")  ROOT::Math::SqrtLowVariableTransformation::DInt2Ext "double ROOT::Math::SqrtLowVariableTransformation::DInt2Ext(double value, double lower, double upper) const
";


// File: classROOT_1_1Minuit2_1_1SqrtUpParameterTransformation.xml
%feature("docstring") ROOT::Minuit2::SqrtUpParameterTransformation "

Transformation from external to internal Parameter based on sqrt(1 + x**2)

This transformation applies for the case of single side Upper Parameter limits

C++ includes: SqrtUpParameterTransformation.h
";

%feature("docstring")  ROOT::Minuit2::SqrtUpParameterTransformation::SqrtUpParameterTransformation "ROOT::Minuit2::SqrtUpParameterTransformation::SqrtUpParameterTransformation()
";

%feature("docstring")  ROOT::Minuit2::SqrtUpParameterTransformation::~SqrtUpParameterTransformation "ROOT::Minuit2::SqrtUpParameterTransformation::~SqrtUpParameterTransformation()
";

%feature("docstring")  ROOT::Minuit2::SqrtUpParameterTransformation::Int2ext "double ROOT::Minuit2::SqrtUpParameterTransformation::Int2ext(double Value, double Upper) const
";

%feature("docstring")  ROOT::Minuit2::SqrtUpParameterTransformation::Ext2int "double ROOT::Minuit2::SqrtUpParameterTransformation::Ext2int(double Value, double Upper, const MnMachinePrecision &) const
";

%feature("docstring")  ROOT::Minuit2::SqrtUpParameterTransformation::DInt2Ext "double ROOT::Minuit2::SqrtUpParameterTransformation::DInt2Ext(double Value, double Upper) const
";


// File: classROOT_1_1Math_1_1SqrtUpVariableTransformation.xml
%feature("docstring") ROOT::Math::SqrtUpVariableTransformation "

Sqrt Transformation class for dealing with upper bounded variables

C++ includes: MinimizerVariableTransformation.h
";

%feature("docstring")  ROOT::Math::SqrtUpVariableTransformation::~SqrtUpVariableTransformation "virtual ROOT::Math::SqrtUpVariableTransformation::~SqrtUpVariableTransformation()
";

%feature("docstring")  ROOT::Math::SqrtUpVariableTransformation::Int2ext "double ROOT::Math::SqrtUpVariableTransformation::Int2ext(double value, double lower, double upper) const
";

%feature("docstring")  ROOT::Math::SqrtUpVariableTransformation::Ext2int "double ROOT::Math::SqrtUpVariableTransformation::Ext2int(double value, double lower, double upper) const
";

%feature("docstring")  ROOT::Math::SqrtUpVariableTransformation::DInt2Ext "double ROOT::Math::SqrtUpVariableTransformation::DInt2Ext(double value, double lower, double upper) const
";


// File: classROOT_1_1Minuit2_1_1StackAllocator.xml
%feature("docstring") ROOT::Minuit2::StackAllocator "

StackAllocator controls the memory allocation/deallocation of Minuit. If  MN_NO_THREAD_SAVE is defined, memory is taken from a pre-allocated piece of heap memory which is then used like a stack, otherwise via standard malloc/free. Note that defining  MN_NO_THREAD_SAVE makes the code thread- unsave. The gain in performance is mainly for cost-cheap FCN functions.

C++ includes: StackAllocator.h
";

%feature("docstring")  ROOT::Minuit2::StackAllocator::StackAllocator "ROOT::Minuit2::StackAllocator::StackAllocator()
";

%feature("docstring")  ROOT::Minuit2::StackAllocator::~StackAllocator "ROOT::Minuit2::StackAllocator::~StackAllocator()
";

%feature("docstring")  ROOT::Minuit2::StackAllocator::Allocate "void* ROOT::Minuit2::StackAllocator::Allocate(size_t nBytes)
";

%feature("docstring")  ROOT::Minuit2::StackAllocator::Deallocate "void ROOT::Minuit2::StackAllocator::Deallocate(void *p)
";

%feature("docstring")  ROOT::Minuit2::StackAllocator::ReadInt "int ROOT::Minuit2::StackAllocator::ReadInt(int offset)
";

%feature("docstring")  ROOT::Minuit2::StackAllocator::WriteInt "void ROOT::Minuit2::StackAllocator::WriteInt(int offset, int Value)
";

%feature("docstring")  ROOT::Minuit2::StackAllocator::ToInt "int ROOT::Minuit2::StackAllocator::ToInt(void *p)
";

%feature("docstring")  ROOT::Minuit2::StackAllocator::AlignedSize "int ROOT::Minuit2::StackAllocator::AlignedSize(int nBytes)
";

%feature("docstring")  ROOT::Minuit2::StackAllocator::CheckOverflow "void ROOT::Minuit2::StackAllocator::CheckOverflow(int n)
";

%feature("docstring")  ROOT::Minuit2::StackAllocator::CheckConsistency "bool ROOT::Minuit2::StackAllocator::CheckConsistency()
";


// File: classROOT_1_1Minuit2_1_1StackAllocatorHolder.xml
%feature("docstring") ROOT::Minuit2::StackAllocatorHolder "";


// File: classROOT_1_1Minuit2_1_1StackError.xml
%feature("docstring") ROOT::Minuit2::StackError "";


// File: classROOT_1_1Minuit2_1_1StackOverflow.xml
%feature("docstring") ROOT::Minuit2::StackOverflow "

define stack allocator symbol

C++ includes: StackAllocator.h
";


// File: classStandaloneFitTest.xml
%feature("docstring") StandaloneFitTest "

Collection of objective functions for minimization library testing. Borrowed from StressFit test framework of http://root.cern.ch.

C++ includes: ClassicalTestFunctions.h
";


// File: classROOT_1_1Minuit2_1_1sym.xml
%feature("docstring") ROOT::Minuit2::sym "";


// File: classTestMinimizer.xml
%feature("docstring") TestMinimizer "

A trivial minimizer that calls the objective function once. Used to test the whole chain.

C++ includes: TestMinimizer.h
";

%feature("docstring")  TestMinimizer::TestMinimizer "TestMinimizer::TestMinimizer()
";

%feature("docstring")  TestMinimizer::~TestMinimizer "TestMinimizer::~TestMinimizer() override
";

%feature("docstring")  TestMinimizer::minimizerName "std::string TestMinimizer::minimizerName() const final

return name of the minimizer 
";

%feature("docstring")  TestMinimizer::algorithmName "std::string TestMinimizer::algorithmName() const final

return name of the minimization algorithm 
";

%feature("docstring")  TestMinimizer::minimize_scalar "MinimizerResult TestMinimizer::minimize_scalar(fcn_scalar_t fcn, mumufit::Parameters parameters) override

run minimization 
";


// File: classTestMinimizerPlan.xml
%feature("docstring") TestMinimizerPlan "

Special plan to test  TestMinimizer.

C++ includes: PlanCases.h
";

%feature("docstring")  TestMinimizerPlan::TestMinimizerPlan "TestMinimizerPlan::TestMinimizerPlan()
";


// File: classTNamed.xml
%feature("docstring") TNamed "";

%feature("docstring")  TNamed::TNamed "TNamed::TNamed(std::string name={}, std::string descr={})
";

%feature("docstring")  TNamed::~TNamed "virtual TNamed::~TNamed()=default
";


// File: classTObject.xml
%feature("docstring") TObject "";

%feature("docstring")  TObject::~TObject "virtual TObject::~TObject()=default
";


// File: classTRandom.xml
%feature("docstring") TRandom "";

%feature("docstring")  TRandom::TRandom "TRandom::TRandom(UInt_t seed=65539)
";

%feature("docstring")  TRandom::~TRandom "virtual TRandom::~TRandom()
";

%feature("docstring")  TRandom::Binomial "virtual Int_t TRandom::Binomial(Int_t ntot, Double_t prob)
";

%feature("docstring")  TRandom::BreitWigner "virtual Double_t TRandom::BreitWigner(Double_t mean=0, Double_t gamma=1)
";

%feature("docstring")  TRandom::Circle "virtual void TRandom::Circle(Double_t &x, Double_t &y, Double_t r)
";

%feature("docstring")  TRandom::Exp "virtual Double_t TRandom::Exp(Double_t tau)
";

%feature("docstring")  TRandom::Gaus "virtual Double_t TRandom::Gaus(Double_t mean=0, Double_t sigma=1)
";

%feature("docstring")  TRandom::GetSeed "virtual UInt_t TRandom::GetSeed() const
";

%feature("docstring")  TRandom::Integer "virtual UInt_t TRandom::Integer(UInt_t imax)
";

%feature("docstring")  TRandom::Poisson "virtual Int_t TRandom::Poisson(Double_t mean)
";

%feature("docstring")  TRandom::PoissonD "virtual Double_t TRandom::PoissonD(Double_t mean)
";

%feature("docstring")  TRandom::Rannor "virtual void TRandom::Rannor(Float_t &a, Float_t &b)
";

%feature("docstring")  TRandom::Rannor "virtual void TRandom::Rannor(Double_t &a, Double_t &b)
";

%feature("docstring")  TRandom::SetSeed "virtual void TRandom::SetSeed(ULong_t seed=0)
";

%feature("docstring")  TRandom::Rndm "virtual Double_t TRandom::Rndm()
";

%feature("docstring")  TRandom::Rndm "virtual Double_t TRandom::Rndm(Int_t)
";

%feature("docstring")  TRandom::RndmArray "virtual void TRandom::RndmArray(Int_t n, Float_t *array)
";

%feature("docstring")  TRandom::RndmArray "virtual void TRandom::RndmArray(Int_t n, Double_t *array)
";

%feature("docstring")  TRandom::Sphere "virtual void TRandom::Sphere(Double_t &x, Double_t &y, Double_t &z, Double_t r)
";

%feature("docstring")  TRandom::Uniform "virtual Double_t TRandom::Uniform(Double_t x1=1)
";

%feature("docstring")  TRandom::Uniform "virtual Double_t TRandom::Uniform(Double_t x1, Double_t x2)
";


// File: classTRandom2.xml
%feature("docstring") TRandom2 "";

%feature("docstring")  TRandom2::TRandom2 "TRandom2::TRandom2(UInt_t seed=1)
";

%feature("docstring")  TRandom2::~TRandom2 "virtual TRandom2::~TRandom2()
";

%feature("docstring")  TRandom2::Rndm "virtual Double_t TRandom2::Rndm()
";

%feature("docstring")  TRandom2::RndmArray "virtual void TRandom2::RndmArray(Int_t n, Float_t *array)
";

%feature("docstring")  TRandom2::RndmArray "virtual void TRandom2::RndmArray(Int_t n, Double_t *array)
";

%feature("docstring")  TRandom2::SetSeed "virtual void TRandom2::SetSeed(ULong_t seed=0)
";

%feature("docstring")  TRandom2::Rndm "virtual Double_t TRandom::Rndm()
";

%feature("docstring")  TRandom2::Rndm "virtual Double_t TRandom::Rndm(Int_t)
";


// File: classTRandom3.xml
%feature("docstring") TRandom3 "";

%feature("docstring")  TRandom3::TRandom3 "TRandom3::TRandom3(UInt_t seed=4357)
";

%feature("docstring")  TRandom3::~TRandom3 "virtual TRandom3::~TRandom3()
";

%feature("docstring")  TRandom3::GetSeed "virtual UInt_t TRandom3::GetSeed() const
";

%feature("docstring")  TRandom3::Rndm "virtual Double_t TRandom3::Rndm()
";

%feature("docstring")  TRandom3::RndmArray "virtual void TRandom3::RndmArray(Int_t n, Float_t *array)
";

%feature("docstring")  TRandom3::RndmArray "virtual void TRandom3::RndmArray(Int_t n, Double_t *array)
";

%feature("docstring")  TRandom3::SetSeed "virtual void TRandom3::SetSeed(ULong_t seed=0)
";

%feature("docstring")  TRandom3::Rndm "virtual Double_t TRandom::Rndm()
";

%feature("docstring")  TRandom3::Rndm "virtual Double_t TRandom::Rndm(Int_t)
";


// File: classROOT_1_1Math_1_1TRandomEngine.xml
%feature("docstring") ROOT::Math::TRandomEngine "";

%feature("docstring")  ROOT::Math::TRandomEngine::Rndm "virtual double ROOT::Math::TRandomEngine::Rndm()=0
";

%feature("docstring")  ROOT::Math::TRandomEngine::~TRandomEngine "virtual ROOT::Math::TRandomEngine::~TRandomEngine()
";


// File: classROOT_1_1TUUID.xml
%feature("docstring") ROOT::TUUID "";

%feature("docstring")  ROOT::TUUID::TUUID "ROOT::TUUID::TUUID()
";

%feature("docstring")  ROOT::TUUID::GetUUID "void ROOT::TUUID::GetUUID(UChar_t uuid[16]) const
";


// File: classTMVA_1_1Types.xml
%feature("docstring") TMVA::Types "";


// File: classROOT_1_1Fit_1_1UnBinData.xml
%feature("docstring") ROOT::Fit::UnBinData "

Class describing the unbinned data sets (just x coordinates values) of any dimensions        There is the option to construct UnBindata copying the data in (using the DataVector class)
       or using pointer to external data (DataWrapper) class.
       In general is found to be more efficient to copy the data.
       In case of really large data sets for limiting memory consumption then the other option can be used
       Specialized constructor exists for using external data up to 3 dimensions.

When the data are copying in the number of points can be set later (or re-set) using Initialize and
       the data are inserted one by one using the Add method.
       It is mandatory to set the size before using the Add method.

@ingroup  FitData

C++ includes: UnBinData.h
";

%feature("docstring")  ROOT::Fit::UnBinData::UnBinData "ROOT::Fit::UnBinData::UnBinData(unsigned int maxpoints=0, unsigned int dim=1, bool isWeighted=false)

constructor from dimension of point and max number of points (to pre-allocate vector) 
";

%feature("docstring")  ROOT::Fit::UnBinData::UnBinData "ROOT::Fit::UnBinData::UnBinData(const DataRange &range, unsigned int maxpoints=0, unsigned int dim=1, bool isWeighted=false)

constructor from range and default option 
";

%feature("docstring")  ROOT::Fit::UnBinData::UnBinData "ROOT::Fit::UnBinData::UnBinData(const DataOptions &opt, const DataRange &range, unsigned int maxpoints=0, unsigned int dim=1, bool isWeighted=false)

constructor from options and range 
";

%feature("docstring")  ROOT::Fit::UnBinData::UnBinData "ROOT::Fit::UnBinData::UnBinData(unsigned int n, const double *dataX)

constructor for 1D external data (data are not copied inside) 
";

%feature("docstring")  ROOT::Fit::UnBinData::UnBinData "ROOT::Fit::UnBinData::UnBinData(unsigned int n, const double *dataX, const double *dataY, bool isWeighted=false)

constructor for 2D external data (data are not copied inside) or 1D data with a weight (if isWeighted = true) 
";

%feature("docstring")  ROOT::Fit::UnBinData::UnBinData "ROOT::Fit::UnBinData::UnBinData(unsigned int n, const double *dataX, const double *dataY, const double *dataZ, bool isWeighted=false)

constructor for 3D external data (data are not copied inside) or 2D data with a weight (if isWeighted = true) 
";

%feature("docstring")  ROOT::Fit::UnBinData::UnBinData "ROOT::Fit::UnBinData::UnBinData(unsigned int n, unsigned int dim, Iterator dataItr, bool isWeighted=false)

constructor for multi-dim external data (data are not copied inside) Uses as argument an iterator of a list (or vector) containing the const double * of the data An example could be the std::vector<const double *>::begin In case of weighted data, the external data must have a dim+1 lists of data The apssed dim refers just to the coordinate size 
";

%feature("docstring")  ROOT::Fit::UnBinData::UnBinData "ROOT::Fit::UnBinData::UnBinData(unsigned int maxpoints, const double *dataX, const DataRange &range)

constructor for 1D data and a range (data are copied inside according to the given range) 
";

%feature("docstring")  ROOT::Fit::UnBinData::UnBinData "ROOT::Fit::UnBinData::UnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const DataRange &range, bool isWeighted=false)

constructor for 2D data and a range (data are copied inside according to the given range) or 1 1D data set + weight. If is weighted dataY is the pointer to the list of the weights 
";

%feature("docstring")  ROOT::Fit::UnBinData::UnBinData "ROOT::Fit::UnBinData::UnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const double *dataZ, const DataRange &range, bool isWeighted=false)

constructor for 3D data and a range (data are copied inside according to the given range) or a 2D data set + weights. If is weighted dataZ is the pointer to the list of the weights 
";

%feature("docstring")  ROOT::Fit::UnBinData::UnBinData "ROOT::Fit::UnBinData::UnBinData(unsigned int maxpoints, unsigned int dim, Iterator dataItr, const DataRange &range, bool isWeighted=false)

constructor for multi-dim external data and a range (data are copied inside according to the range) Uses as argument an iterator of a list (or vector) containing the const double * of the data An example could be the std::vector<const double *>::begin 
";

%feature("docstring")  ROOT::Fit::UnBinData::~UnBinData "virtual ROOT::Fit::UnBinData::~UnBinData()

destructor, delete pointer to internal data or external data wrapper 
";

%feature("docstring")  ROOT::Fit::UnBinData::Add "void ROOT::Fit::UnBinData::Add(double x)

preallocate a data set given size and dimension of the coordinates if a vector already exists with correct dimension (point size) extend the existing one to a total size of maxpoints (equivalent to a Resize) add one dim coordinate data (unweighted) 
";

%feature("docstring")  ROOT::Fit::UnBinData::Add "void ROOT::Fit::UnBinData::Add(double x, double y)

add 2-dim coordinate data can also be used to add 1-dim data with a weight 
";

%feature("docstring")  ROOT::Fit::UnBinData::Add "void ROOT::Fit::UnBinData::Add(double x, double y, double z)

add 3-dim coordinate data can also be used to add 2-dim data with a weight 
";

%feature("docstring")  ROOT::Fit::UnBinData::Add "void ROOT::Fit::UnBinData::Add(const double *x)

add multi-dim coordinate data 
";

%feature("docstring")  ROOT::Fit::UnBinData::Add "void ROOT::Fit::UnBinData::Add(const double *x, double w)

add multi-dim coordinate data + weight 
";

%feature("docstring")  ROOT::Fit::UnBinData::Weight "double ROOT::Fit::UnBinData::Weight(unsigned int ipoint) const

return weight 
";

%feature("docstring")  ROOT::Fit::UnBinData::WeightsPtr "const double* ROOT::Fit::UnBinData::WeightsPtr(unsigned int ipoint) const
";

%feature("docstring")  ROOT::Fit::UnBinData::NDim "unsigned int ROOT::Fit::UnBinData::NDim() const

return coordinate data dimension 
";

%feature("docstring")  ROOT::Fit::UnBinData::IsWeighted "bool ROOT::Fit::UnBinData::IsWeighted() const
";

%feature("docstring")  ROOT::Fit::UnBinData::Append "void ROOT::Fit::UnBinData::Append(unsigned int newPoints, unsigned int dim=1, bool isWeighted=false)
";


// File: classROOT_1_1Minuit2_1_1VariableMetricBuilder.xml
%feature("docstring") ROOT::Minuit2::VariableMetricBuilder "

Build (find) function minimum using the Variable Metric method (MIGRAD) Two possible error updators can be choosen
Davidon : this is the standard formula used in Migrad

BFGS this is the new formula based on BFGS algorithm (see Broyden–Fletcher–Goldfarb–Shanno algorithm https://en.wikipedia.org/wiki/Broyden–Fletcher–Goldfarb–Shanno_algorithm )

C++ includes: VariableMetricBuilder.h
";

%feature("docstring")  ROOT::Minuit2::VariableMetricBuilder::VariableMetricBuilder "ROOT::Minuit2::VariableMetricBuilder::VariableMetricBuilder(ErrorUpdatorType type=kDavidon)
";

%feature("docstring")  ROOT::Minuit2::VariableMetricBuilder::~VariableMetricBuilder "ROOT::Minuit2::VariableMetricBuilder::~VariableMetricBuilder()
";

%feature("docstring")  ROOT::Minuit2::VariableMetricBuilder::Minimum "virtual FunctionMinimum ROOT::Minuit2::VariableMetricBuilder::Minimum(const MnFcn &, const GradientCalculator &, const MinimumSeed &, const MnStrategy &, unsigned int, double) const
";

%feature("docstring")  ROOT::Minuit2::VariableMetricBuilder::Minimum "FunctionMinimum ROOT::Minuit2::VariableMetricBuilder::Minimum(const MnFcn &, const GradientCalculator &, const MinimumSeed &, std::vector< MinimumState > &, unsigned int, double) const
";

%feature("docstring")  ROOT::Minuit2::VariableMetricBuilder::Estimator "const VariableMetricEDMEstimator& ROOT::Minuit2::VariableMetricBuilder::Estimator() const
";

%feature("docstring")  ROOT::Minuit2::VariableMetricBuilder::ErrorUpdator "const MinimumErrorUpdator& ROOT::Minuit2::VariableMetricBuilder::ErrorUpdator() const
";

%feature("docstring")  ROOT::Minuit2::VariableMetricBuilder::AddResult "void ROOT::Minuit2::VariableMetricBuilder::AddResult(std::vector< MinimumState > &result, const MinimumState &state) const
";


// File: classROOT_1_1Minuit2_1_1VariableMetricEDMEstimator.xml
%feature("docstring") ROOT::Minuit2::VariableMetricEDMEstimator "";

%feature("docstring")  ROOT::Minuit2::VariableMetricEDMEstimator::VariableMetricEDMEstimator "ROOT::Minuit2::VariableMetricEDMEstimator::VariableMetricEDMEstimator()
";

%feature("docstring")  ROOT::Minuit2::VariableMetricEDMEstimator::~VariableMetricEDMEstimator "ROOT::Minuit2::VariableMetricEDMEstimator::~VariableMetricEDMEstimator()
";

%feature("docstring")  ROOT::Minuit2::VariableMetricEDMEstimator::Estimate "double ROOT::Minuit2::VariableMetricEDMEstimator::Estimate(const FunctionGradient &, const MinimumError &) const
";


// File: classROOT_1_1Minuit2_1_1VariableMetricMinimizer.xml
%feature("docstring") ROOT::Minuit2::VariableMetricMinimizer "

Instantiates the SeedGenerator and  MinimumBuilder for Variable Metric Minimization method. API is provided in the upper  ROOT::Minuit2::ModularFunctionMinimizer class

C++ includes: VariableMetricMinimizer.h
";

%feature("docstring")  ROOT::Minuit2::VariableMetricMinimizer::VariableMetricMinimizer "ROOT::Minuit2::VariableMetricMinimizer::VariableMetricMinimizer()
";

%feature("docstring")  ROOT::Minuit2::VariableMetricMinimizer::VariableMetricMinimizer "ROOT::Minuit2::VariableMetricMinimizer::VariableMetricMinimizer(BFGSType)
";

%feature("docstring")  ROOT::Minuit2::VariableMetricMinimizer::~VariableMetricMinimizer "ROOT::Minuit2::VariableMetricMinimizer::~VariableMetricMinimizer()
";

%feature("docstring")  ROOT::Minuit2::VariableMetricMinimizer::SeedGenerator "const MinimumSeedGenerator& ROOT::Minuit2::VariableMetricMinimizer::SeedGenerator() const
";

%feature("docstring")  ROOT::Minuit2::VariableMetricMinimizer::Builder "const MinimumBuilder& ROOT::Minuit2::VariableMetricMinimizer::Builder() const
";

%feature("docstring")  ROOT::Minuit2::VariableMetricMinimizer::Builder "MinimumBuilder& ROOT::Minuit2::VariableMetricMinimizer::Builder()
";


// File: classROOT_1_1Minuit2_1_1vec.xml
%feature("docstring") ROOT::Minuit2::vec "";


// File: classROOT_1_1Minuit2_1_1VectorOuterProduct.xml
%feature("docstring") ROOT::Minuit2::VectorOuterProduct "";

%feature("docstring")  ROOT::Minuit2::VectorOuterProduct::VectorOuterProduct "ROOT::Minuit2::VectorOuterProduct< M, T >::VectorOuterProduct(const M &obj)
";

%feature("docstring")  ROOT::Minuit2::VectorOuterProduct::~VectorOuterProduct "ROOT::Minuit2::VectorOuterProduct< M, T >::~VectorOuterProduct()
";

%feature("docstring")  ROOT::Minuit2::VectorOuterProduct::Obj "const M& ROOT::Minuit2::VectorOuterProduct< M, T >::Obj() const
";


// File: classWallclockTimer.xml
%feature("docstring") WallclockTimer "

A timer for measuring real (wall-clock) time spent between 'start' and 'stop' commands.

C++ includes: WallclockTimer.h
";

%feature("docstring")  WallclockTimer::WallclockTimer "WallclockTimer::WallclockTimer()
";

%feature("docstring")  WallclockTimer::~WallclockTimer "WallclockTimer::~WallclockTimer()
";

%feature("docstring")  WallclockTimer::start "void WallclockTimer::start()
";

%feature("docstring")  WallclockTimer::stop "void WallclockTimer::stop()
";

%feature("docstring")  WallclockTimer::runTime "double WallclockTimer::runTime() const

returns run time in sec. 
";


// File: structWallclockTimerState.xml
%feature("docstring") WallclockTimerState "

Internal state of a  WallclockTimer object. 
";


// File: classWoodFourPlan.xml
%feature("docstring") WoodFourPlan "

Setting for standalone fit of WoodFour function.

C++ includes: PlanCases.h
";

%feature("docstring")  WoodFourPlan::WoodFourPlan "WoodFourPlan::WoodFourPlan()

Plan for WoodFour function start point: F(-3,-1,-3,-1) = 19192 minimum : F(1,1,1,1) = 0. 
";


// File: classROOT_1_1Math_1_1WrappedFunction.xml
%feature("docstring") ROOT::Math::WrappedFunction "

Template class to wrap any C++ callable object which takes one argument i.e. implementing operator() (double x) in a One-dimensional function interface. It provides a ROOT::Math::IGenFunction-like signature

Note: If you want to wrap just the reference (to avoid copying) you need to use Func& or const Func & as template parameter. The former should be used when the operator() is not a const method of Func

C++ includes: WrappedFunction.h
";

%feature("docstring")  ROOT::Math::WrappedFunction::WrappedFunction "ROOT::Math::WrappedFunction< Func >::WrappedFunction(Func f)

construct from the pointer to the object and the member function 
";

%feature("docstring")  ROOT::Math::WrappedFunction::Clone "WrappedFunction* ROOT::Math::WrappedFunction< Func >::Clone() const

clone (required by the interface) 
";


// File: classROOT_1_1Math_1_1WrappedMemFunction.xml
%feature("docstring") ROOT::Math::WrappedMemFunction "

Template class to wrap any member function of a class taking a double and returning a double in a 1D function interface For example, if you have a class like: struct X { double Eval(double x); }; you can wrapped in the following way:  WrappedMemFunction<X, double ( X::* ) (double) > f;

C++ includes: WrappedFunction.h
";

%feature("docstring")  ROOT::Math::WrappedMemFunction::WrappedMemFunction "ROOT::Math::WrappedMemFunction< FuncObj, MemFuncPtr >::WrappedMemFunction(FuncObj &obj, MemFuncPtr memFn)

construct from the pointer to the object and the member function 
";

%feature("docstring")  ROOT::Math::WrappedMemFunction::Clone "WrappedMemFunction* ROOT::Math::WrappedMemFunction< FuncObj, MemFuncPtr >::Clone() const

clone (required by the interface) 
";


// File: classROOT_1_1Math_1_1WrappedMemMultiFunction.xml
%feature("docstring") ROOT::Math::WrappedMemMultiFunction "";

%feature("docstring")  ROOT::Math::WrappedMemMultiFunction::WrappedMemMultiFunction "ROOT::Math::WrappedMemMultiFunction< FuncObj, MemFuncPtr >::WrappedMemMultiFunction(FuncObj &obj, MemFuncPtr memFn, unsigned int dim=1)

construct from the pointer to the object and the member function 
";

%feature("docstring")  ROOT::Math::WrappedMemMultiFunction::Clone "WrappedMemMultiFunction* ROOT::Math::WrappedMemMultiFunction< FuncObj, MemFuncPtr >::Clone() const

clone (required by the interface) 
";

%feature("docstring")  ROOT::Math::WrappedMemMultiFunction::NDim "unsigned int ROOT::Math::WrappedMemMultiFunction< FuncObj, MemFuncPtr >::NDim() const

Retrieve the dimension of the function 
";


// File: classROOT_1_1Math_1_1WrappedMultiFunction.xml
%feature("docstring") ROOT::Math::WrappedMultiFunction "

Template class to wrap any C++ callable object implementing operator() (const double * x) in a multi-dimensional function interface. It provides a ROOT::Math::IGenMultiFunction-like signature

Note: If you want to wrap just the reference (to avoid copying) you need to use Func& or const Func & as template parameter. The former should be used when the operator() is not a const method of Func

C++ includes: WrappedFunction.h
";

%feature("docstring")  ROOT::Math::WrappedMultiFunction::WrappedMultiFunction "ROOT::Math::WrappedMultiFunction< Func >::WrappedMultiFunction(Func f, unsigned int dim=1)

construct from the pointer to the object and the member function 
";

%feature("docstring")  ROOT::Math::WrappedMultiFunction::Clone "WrappedMultiFunction* ROOT::Math::WrappedMultiFunction< Func >::Clone() const

clone (required by the interface) 
";

%feature("docstring")  ROOT::Math::WrappedMultiFunction::NDim "unsigned int ROOT::Math::WrappedMultiFunction< Func >::NDim() const

Retrieve the dimension of the function 
";


// File: classROOT_1_1Math_1_1WrappedParamFunction.xml
%feature("docstring") ROOT::Math::WrappedParamFunction "

WrappedParamFunction class to wrap any multi-dimensional function pbject implementing the operator()(const double * x, const double * p) in an interface-like IParamFunction with a vector storing and caching internally the parameter values

C++ includes: WrappedParamFunction.h
";

%feature("docstring")  ROOT::Math::WrappedParamFunction::WrappedParamFunction "ROOT::Math::WrappedParamFunction< FuncPtr >::WrappedParamFunction(FuncPtr func, unsigned int dim=1, unsigned int npar=0, double *par=0)

Constructor a wrapped function from a pointer to a callable object, the function dimension and number of parameters which are set to zero by default 
";

%feature("docstring")  ROOT::Math::WrappedParamFunction::WrappedParamFunction "ROOT::Math::WrappedParamFunction< FuncPtr >::WrappedParamFunction(FuncPtr func, unsigned int dim, Iterator begin, Iterator end)

Constructor a wrapped function from a pointer to a callable object, the function dimension and an iterator specifying begin and end of parameters 
";

%feature("docstring")  ROOT::Math::WrappedParamFunction::Clone "IMultiGenFunction* ROOT::Math::WrappedParamFunction< FuncPtr >::Clone() const

clone the function 
";

%feature("docstring")  ROOT::Math::WrappedParamFunction::Parameters "const double* ROOT::Math::WrappedParamFunction< FuncPtr >::Parameters() const

Access the parameter values 
";

%feature("docstring")  ROOT::Math::WrappedParamFunction::SetParameters "void ROOT::Math::WrappedParamFunction< FuncPtr >::SetParameters(const double *p)

Set the parameter values

Parameters:
-----------

p: 
vector of doubles containing the parameter values.

to be defined: can user change number of params ? At the moment no. 
";

%feature("docstring")  ROOT::Math::WrappedParamFunction::NPar "unsigned int ROOT::Math::WrappedParamFunction< FuncPtr >::NPar() const

Return the number of Parameters 
";

%feature("docstring")  ROOT::Math::WrappedParamFunction::NDim "unsigned int ROOT::Math::WrappedParamFunction< FuncPtr >::NDim() const

Retrieve the dimension of the function 
";


// File: classROOT_1_1Math_1_1WrappedParamFunctionGen.xml
%feature("docstring") ROOT::Math::WrappedParamFunctionGen "

WrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(const double * ) in an interface-like IParamFunction, by fixing some of the variables and define them as parameters. i.e. transform any multi-dim function in a parametric function

C++ includes: WrappedParamFunction.h
";

%feature("docstring")  ROOT::Math::WrappedParamFunctionGen::WrappedParamFunctionGen "ROOT::Math::WrappedParamFunctionGen< FuncPtr >::WrappedParamFunctionGen(const FuncPtr &func, unsigned int dim, unsigned int npar, const double *par, const unsigned int *idx)

Constructor a wrapped function from a pointer to a generic callable object implemention operator()(const double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which becames parameters in the new API 
";

%feature("docstring")  ROOT::Math::WrappedParamFunctionGen::WrappedParamFunctionGen "ROOT::Math::WrappedParamFunctionGen< FuncPtr >::WrappedParamFunctionGen(FuncPtr &func, unsigned int dim, unsigned int npar, const double *par, const unsigned int *idx)

Constructor as before but taking now a non - const pointer to a callable object. This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects 
";

%feature("docstring")  ROOT::Math::WrappedParamFunctionGen::Clone "IMultiGenFunction* ROOT::Math::WrappedParamFunctionGen< FuncPtr >::Clone() const

clone the function 
";

%feature("docstring")  ROOT::Math::WrappedParamFunctionGen::Parameters "const double* ROOT::Math::WrappedParamFunctionGen< FuncPtr >::Parameters() const

Access the parameter values 
";

%feature("docstring")  ROOT::Math::WrappedParamFunctionGen::SetParameters "void ROOT::Math::WrappedParamFunctionGen< FuncPtr >::SetParameters(const double *p)

Set the parameter values

Parameters:
-----------

p: 
vector of doubles containing the parameter values.

to be defined: can user change number of params ? At the moment no. 
";

%feature("docstring")  ROOT::Math::WrappedParamFunctionGen::NPar "unsigned int ROOT::Math::WrappedParamFunctionGen< FuncPtr >::NPar() const

Return the number of Parameters 
";

%feature("docstring")  ROOT::Math::WrappedParamFunctionGen::NDim "unsigned int ROOT::Math::WrappedParamFunctionGen< FuncPtr >::NDim() const
";


// File: namespace_0d201.xml


// File: namespace_0d203.xml


// File: namespace_0d211.xml


// File: namespace_0d215.xml


// File: namespace_0d217.xml


// File: namespace_0d229.xml


// File: namespace_0d243.xml


// File: namespace_0d245.xml


// File: namespace_0d253.xml


// File: namespace_0d263.xml


// File: namespace_0d279.xml


// File: namespace_0d65.xml


// File: namespaceMath.xml


// File: namespacemumufit.xml


// File: namespacemumufit_1_1internal.xml
%feature("docstring")  mumufit::internal::reportToString "std::string mumufit::internal::reportToString(const MinimizerAdapter &minimizer)

Reports results of minimization in the form of multi-line string. 
";


// File: namespacemumufit_1_1stringUtils.xml
%feature("docstring")  mumufit::stringUtils::matchesPattern "bool mumufit::stringUtils::matchesPattern(const std::string &text, const std::string &wildcardPattern)

Returns true if text matches pattern with wildcards '*' and '?'. 
";

%feature("docstring")  mumufit::stringUtils::split "std::vector< std::string > mumufit::stringUtils::split(const std::string &text, const std::string &delimeter)

Split string into vector of string using delimeter.

Returns token vector obtained by splitting string at delimiters. 
";

%feature("docstring")  mumufit::stringUtils::scientific "std::string mumufit::stringUtils::scientific(const T value, int n=10)

Returns scientific string representing given value of any numeric type. 
";


// File: namespacemumufit_1_1test.xml
%feature("docstring")  mumufit::test::create_new "T* mumufit::test::create_new()

Returns new instance of class T.

This templated function is used in catalogs in form of a function pointer 'create_new<T>', with no function arguments supplied. Equivalently, we could use a lambda function '[](){return new T;}'. 
";


// File: namespacemumufit_1_1utils.xml
%feature("docstring")  mumufit::utils::toString "std::string mumufit::utils::toString(const std::vector< std::string > &v, const std::string &delim=\"\")
";

%feature("docstring")  mumufit::utils::gslErrorDescriptionMap "std::map< int, std::string > mumufit::utils::gslErrorDescriptionMap()

Returns translation of GSL error code to string. 
";

%feature("docstring")  mumufit::utils::gslErrorDescription "std::string mumufit::utils::gslErrorDescription(int errorCode)
";

%feature("docstring")  mumufit::utils::numbersDiffer "bool mumufit::utils::numbersDiffer(double a, double b, double tol)
";

%feature("docstring")  mumufit::utils::sectionString "std::string mumufit::utils::sectionString(const std::string &sectionName=\"\", size_t report_width=80)

Returns horizontal line of 80 characters length with section name in it. 
";


// File: namespaceROOT.xml


// File: namespaceROOT_1_1Fit.xml


// File: namespaceROOT_1_1Fit_1_1FitUtil.xml
%feature("docstring")  ROOT::Fit::FitUtil::EvaluateChi2 "double ROOT::Fit::FitUtil::EvaluateChi2(const IModelFunction &func, const BinData &data, const double *x, unsigned int &nPoints, ROOT::Fit::ExecutionPolicy executionPolicy, unsigned nChunks=0)

Chi2 Functions evaluate the Chi2 given a model function and the data at the point x. return also nPoints as the effective number of used points in the Chi2 evaluation 
";

%feature("docstring")  ROOT::Fit::FitUtil::EvaluateChi2Effective "double ROOT::Fit::FitUtil::EvaluateChi2Effective(const IModelFunction &func, const BinData &data, const double *x, unsigned int &nPoints)

evaluate the effective Chi2 given a model function and the data at the point x. The effective chi2 uses the errors on the coordinates : W = 1/(sigma_y**2 + ( sigma_x_i * df/dx_i )**2 ) return also nPoints as the effective number of used points in the Chi2 evaluation 
";

%feature("docstring")  ROOT::Fit::FitUtil::EvaluateChi2Gradient "void ROOT::Fit::FitUtil::EvaluateChi2Gradient(const IModelFunction &func, const BinData &data, const double *x, double *grad, unsigned int &nPoints, ROOT::Fit::ExecutionPolicy executionPolicy=ROOT::Fit::ExecutionPolicy::kSerial, unsigned nChunks=0)

evaluate the Chi2 gradient given a model function and the data at the point x. return also nPoints as the effective number of used points in the Chi2 evaluation 
";

%feature("docstring")  ROOT::Fit::FitUtil::EvaluateLogL "double ROOT::Fit::FitUtil::EvaluateLogL(const IModelFunction &func, const UnBinData &data, const double *p, int iWeight, bool extended, unsigned int &nPoints, ROOT::Fit::ExecutionPolicy executionPolicy, unsigned nChunks=0)

evaluate the LogL given a model function and the data at the point x. return also nPoints as the effective number of used points in the LogL evaluation 
";

%feature("docstring")  ROOT::Fit::FitUtil::EvaluateLogLGradient "void ROOT::Fit::FitUtil::EvaluateLogLGradient(const IModelFunction &func, const UnBinData &data, const double *x, double *grad, unsigned int &nPoints, ROOT::Fit::ExecutionPolicy executionPolicy=ROOT::Fit::ExecutionPolicy::kSerial, unsigned nChunks=0)

evaluate the LogL gradient given a model function and the data at the point x. return also nPoints as the effective number of used points in the LogL evaluation 
";

%feature("docstring")  ROOT::Fit::FitUtil::EvaluatePoissonLogL "double ROOT::Fit::FitUtil::EvaluatePoissonLogL(const IModelFunction &func, const BinData &data, const double *x, int iWeight, bool extended, unsigned int &nPoints, ROOT::Fit::ExecutionPolicy executionPolicy, unsigned nChunks=0)

evaluate the Poisson LogL given a model function and the data at the point x. return also nPoints as the effective number of used points in the LogL evaluation By default is extended, pass extedend to false if want to be not extended (MultiNomial) 
";

%feature("docstring")  ROOT::Fit::FitUtil::EvaluatePoissonLogLGradient "void ROOT::Fit::FitUtil::EvaluatePoissonLogLGradient(const IModelFunction &func, const BinData &data, const double *x, double *grad, unsigned int &nPoints, ROOT::Fit::ExecutionPolicy executionPolicy=ROOT::Fit::ExecutionPolicy::kSerial, unsigned nChunks=0)

evaluate the Poisson LogL given a model function and the data at the point x. return also nPoints as the effective number of used points in the LogL evaluation 
";

%feature("docstring")  ROOT::Fit::FitUtil::EvaluateChi2Residual "double ROOT::Fit::FitUtil::EvaluateChi2Residual(const IModelFunction &func, const BinData &data, const double *x, unsigned int ipoint, double *g=0)

evaluate the residual contribution to the Chi2 given a model function and the BinPoint data and if the pointer g is not null evaluate also the gradient of the residual. If the function provides parameter derivatives they are used otherwise a simple derivative calculation is used 
";

%feature("docstring")  ROOT::Fit::FitUtil::EvaluatePdf "double ROOT::Fit::FitUtil::EvaluatePdf(const IModelFunction &func, const UnBinData &data, const double *x, unsigned int ipoint, double *g=0)

evaluate the pdf contribution to the LogL given a model function and the BinPoint data. If the pointer g is not null evaluate also the gradient of the pdf. If the function provides parameter derivatives they are used otherwise a simple derivative calculation is used 
";

%feature("docstring")  ROOT::Fit::FitUtil::EvaluatePoissonBinPdf "double ROOT::Fit::FitUtil::EvaluatePoissonBinPdf(const IModelFunction &func, const BinData &data, const double *x, unsigned int ipoint, double *g=0)

evaluate the pdf contribution to the Poisson LogL given a model function and the BinPoint data. If the pointer g is not null evaluate also the gradient of the Poisson pdf. If the function provides parameter derivatives they are used otherwise a simple derivative calculation is used 
";

%feature("docstring")  ROOT::Fit::FitUtil::setAutomaticChunking "unsigned ROOT::Fit::FitUtil::setAutomaticChunking(unsigned nEvents)
";


// File: namespaceROOT_1_1Math.xml
%feature("docstring")  ROOT::Math::Cephes::Pi "double ROOT::Math::Pi()

Mathematical constants 
";

%feature("docstring")  ROOT::Math::Cephes::log1p "double ROOT::Math::log1p(double x)

log(1+x) with error cancelatio when x is small

declarations for functions which are not implemented by some compilers 
";

%feature("docstring")  ROOT::Math::Cephes::expm1 "double ROOT::Math::expm1(double x)

exp(x) -1 with error cancellation when x is small 
";

%feature("docstring")  ROOT::Math::Cephes::beta_cdf_c "double ROOT::Math::beta_cdf_c(double x, double a, double b)

Complement of the cumulative distribution function of the beta distribution. Upper tail of the integral of the #beta_pdf 
";

%feature("docstring")  ROOT::Math::Cephes::beta_cdf "double ROOT::Math::beta_cdf(double x, double a, double b)

Cumulative distribution function of the beta distribution Upper tail of the integral of the #beta_pdf 
";

%feature("docstring")  ROOT::Math::Cephes::breitwigner_cdf_c "double ROOT::Math::breitwigner_cdf_c(double x, double gamma, double x0=0)

Complement of the cumulative distribution function (upper tail) of the Breit_Wigner distribution and it is similar (just a different parameter definition) to the Cauchy distribution (see #cauchy_cdf_c )

\\\\[ D(x) = \\\\int_{x}^{+\\\\infty} \\\\frac{1}{\\\\pi} \\\\frac{\\\\frac{1}{2} \\\\Gamma}{x'^2 + (\\\\frac{1}{2} \\\\Gamma)^2} dx' \\\\]
";

%feature("docstring")  ROOT::Math::Cephes::breitwigner_cdf "double ROOT::Math::breitwigner_cdf(double x, double gamma, double x0=0)

Cumulative distribution function (lower tail) of the Breit_Wigner distribution and it is similar (just a different parameter definition) to the Cauchy distribution (see #cauchy_cdf )

\\\\[ D(x) = \\\\int_{-\\\\infty}^{x} \\\\frac{1}{\\\\pi} \\\\frac{b}{x'^2 + (\\\\frac{1}{2} \\\\Gamma)^2} dx' \\\\]
";

%feature("docstring")  ROOT::Math::Cephes::cauchy_cdf_c "double ROOT::Math::cauchy_cdf_c(double x, double b, double x0=0)

Complement of the cumulative distribution function (upper tail) of the Cauchy distribution which is also Lorentzian distribution. It is similar (just a different parameter definition) to the Breit_Wigner distribution (see #breitwigner_cdf_c )

\\\\[ D(x) = \\\\int_{x}^{+\\\\infty} \\\\frac{1}{\\\\pi} \\\\frac{ b }{ (x'-m)^2 + b^2} dx' \\\\]

For detailed description see Mathworld. 
";

%feature("docstring")  ROOT::Math::Cephes::cauchy_cdf "double ROOT::Math::cauchy_cdf(double x, double b, double x0=0)

Cumulative distribution function (lower tail) of the Cauchy distribution which is also Lorentzian distribution. It is similar (just a different parameter definition) to the Breit_Wigner distribution (see #breitwigner_cdf )

\\\\[ D(x) = \\\\int_{-\\\\infty}^{x} \\\\frac{1}{\\\\pi} \\\\frac{ b }{ (x'-m)^2 + b^2} dx' \\\\]

For detailed description see Mathworld. 
";

%feature("docstring")  ROOT::Math::Cephes::chisquared_cdf_c "double ROOT::Math::chisquared_cdf_c(double x, double r, double x0=0)

Complement of the cumulative distribution function of the  $\\\\chi^2$ distribution with  $r$ degrees of freedom (upper tail).

\\\\[ D_{r}(x) = \\\\int_{x}^{+\\\\infty} \\\\frac{1}{\\\\Gamma(r/2) 2^{r/2}} x'^{r/2-1} e^{-x'/2} dx' \\\\]

For detailed description see Mathworld. It is implemented using the incomplete gamma function, ROOT::Math::inc_gamma_c, from Cephes
";

%feature("docstring")  ROOT::Math::Cephes::chisquared_cdf "double ROOT::Math::chisquared_cdf(double x, double r, double x0=0)

Cumulative distribution function of the  $\\\\chi^2$ distribution with  $r$ degrees of freedom (lower tail).

\\\\[ D_{r}(x) = \\\\int_{-\\\\infty}^{x} \\\\frac{1}{\\\\Gamma(r/2) 2^{r/2}} x'^{r/2-1} e^{-x'/2} dx' \\\\]

For detailed description see Mathworld. It is implemented using the incomplete gamma function, ROOT::Math::inc_gamma_c, from Cephes
";

%feature("docstring")  ROOT::Math::Cephes::crystalball_cdf "double ROOT::Math::crystalball_cdf(double x, double alpha, double n, double sigma, double x0=0)

Cumulative distribution for the Crystal Ball distribution function

See the definition of the Crystal Ball function at Wikipedia.

The distribution is defined only for n > 1 when the integral converges 
";

%feature("docstring")  ROOT::Math::Cephes::crystalball_cdf_c "double ROOT::Math::crystalball_cdf_c(double x, double alpha, double n, double sigma, double x0=0)

Complement of the Cumulative distribution for the Crystal Ball distribution

See the definition of the Crystal Ball function at Wikipedia.

The distribution is defined only for n > 1 when the integral converges 
";

%feature("docstring")  ROOT::Math::Cephes::crystalball_integral "double ROOT::Math::crystalball_integral(double x, double alpha, double n, double sigma, double x0=0)

Integral of the not-normalized Crystal Ball function

See the definition of the Crystal Ball function at Wikipedia.

see ROOT::Math::crystalball_function for the function evaluation. 
";

%feature("docstring")  ROOT::Math::Cephes::exponential_cdf_c "double ROOT::Math::exponential_cdf_c(double x, double lambda, double x0=0)

Complement of the cumulative distribution function of the exponential distribution (upper tail).

\\\\[ D(x) = \\\\int_{x}^{+\\\\infty} \\\\lambda e^{-\\\\lambda x'} dx' \\\\]

For detailed description see Mathworld. 
";

%feature("docstring")  ROOT::Math::Cephes::exponential_cdf "double ROOT::Math::exponential_cdf(double x, double lambda, double x0=0)

Cumulative distribution function of the exponential distribution (lower tail).

\\\\[ D(x) = \\\\int_{-\\\\infty}^{x} \\\\lambda e^{-\\\\lambda x'} dx' \\\\]

For detailed description see Mathworld. 
";

%feature("docstring")  ROOT::Math::Cephes::fdistribution_cdf_c "double ROOT::Math::fdistribution_cdf_c(double x, double n, double m, double x0=0)

Complement of the cumulative distribution function of the F-distribution (upper tail).

\\\\[ D_{n,m}(x) = \\\\int_{x}^{+\\\\infty} \\\\frac{\\\\Gamma(\\\\frac{n+m}{2})}{\\\\Gamma(\\\\frac{n}{2}) \\\\Gamma(\\\\frac{m}{2})} n^{n/2} m^{m/2} x'^{n/2 -1} (m+nx')^{-(n+m)/2} dx' \\\\]

For detailed description see Mathworld. It is implemented using the incomplete beta function, ROOT::Math::inc_beta, from Cephes
";

%feature("docstring")  ROOT::Math::Cephes::fdistribution_cdf "double ROOT::Math::fdistribution_cdf(double x, double n, double m, double x0=0)

Cumulative distribution function of the F-distribution (lower tail).

\\\\[ D_{n,m}(x) = \\\\int_{-\\\\infty}^{x} \\\\frac{\\\\Gamma(\\\\frac{n+m}{2})}{\\\\Gamma(\\\\frac{n}{2}) \\\\Gamma(\\\\frac{m}{2})} n^{n/2} m^{m/2} x'^{n/2 -1} (m+nx')^{-(n+m)/2} dx' \\\\]

For detailed description see Mathworld. It is implemented using the incomplete beta function, ROOT::Math::inc_beta, from Cephes
";

%feature("docstring")  ROOT::Math::Cephes::gamma_cdf_c "double ROOT::Math::gamma_cdf_c(double x, double alpha, double theta, double x0=0)

Complement of the cumulative distribution function of the gamma distribution (upper tail).

\\\\[ D(x) = \\\\int_{x}^{+\\\\infty} {1 \\\\over \\\\Gamma(\\\\alpha) \\\\theta^{\\\\alpha}} x'^{\\\\alpha-1} e^{-x'/\\\\theta} dx' \\\\]

For detailed description see Mathworld. It is implemented using the incomplete gamma function, ROOT::Math::inc_gamma, from Cephes
";

%feature("docstring")  ROOT::Math::Cephes::gamma_cdf "double ROOT::Math::gamma_cdf(double x, double alpha, double theta, double x0=0)

Cumulative distribution function of the gamma distribution (lower tail).

\\\\[ D(x) = \\\\int_{-\\\\infty}^{x} {1 \\\\over \\\\Gamma(\\\\alpha) \\\\theta^{\\\\alpha}} x'^{\\\\alpha-1} e^{-x'/\\\\theta} dx' \\\\]

For detailed description see Mathworld. It is implemented using the incomplete gamma function, ROOT::Math::inc_gamma, from Cephes
";

%feature("docstring")  ROOT::Math::Cephes::landau_cdf "double ROOT::Math::landau_cdf(double x, double xi=1, double x0=0)

Cumulative distribution function of the Landau distribution (lower tail).

\\\\[ D(x) = \\\\int_{-\\\\infty}^{x} p(x) dx \\\\]

where  $p(x)$ is the Landau probability density function :  \\\\[ p(x) = \\\\frac{1}{\\\\xi} \\\\phi (\\\\lambda) \\\\] with  \\\\[ \\\\phi(\\\\lambda) = \\\\frac{1}{2 \\\\pi i}\\\\int_{c-i\\\\infty}^{c+i\\\\infty} e^{\\\\lambda s + s \\\\log{s}} ds\\\\] with  $\\\\lambda = (x-x_0)/\\\\xi$. For a detailed description see K.S. Klbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111[Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (DISLAN) is used.

Parameters:
-----------

x: 
The argument  $x$

xi: 
The width parameter  $\\\\xi$

x0: 
The location parameter  $x_0$
";

%feature("docstring")  ROOT::Math::Cephes::landau_cdf_c "double ROOT::Math::landau_cdf_c(double x, double xi=1, double x0=0)

Complement of the distribution function of the Landau distribution (upper tail).

\\\\[ D(x) = \\\\int_{x}^{+\\\\infty} p(x) dx \\\\]

where p(x) is the Landau probability density function. It is implemented simply as 1. - #landau_cdf

Parameters:
-----------

x: 
The argument  $x$

xi: 
The width parameter  $\\\\xi$

x0: 
The location parameter  $x_0$
";

%feature("docstring")  ROOT::Math::Cephes::lognormal_cdf_c "double ROOT::Math::lognormal_cdf_c(double x, double m, double s, double x0=0)

Complement of the cumulative distribution function of the lognormal distribution (upper tail).

\\\\[ D(x) = \\\\int_{x}^{+\\\\infty} {1 \\\\over x' \\\\sqrt{2 \\\\pi s^2} } e^{-(\\\\ln{x'} - m)^2/2 s^2} dx' \\\\]

For detailed description see Mathworld. 
";

%feature("docstring")  ROOT::Math::Cephes::lognormal_cdf "double ROOT::Math::lognormal_cdf(double x, double m, double s, double x0=0)

Cumulative distribution function of the lognormal distribution (lower tail).

\\\\[ D(x) = \\\\int_{-\\\\infty}^{x} {1 \\\\over x' \\\\sqrt{2 \\\\pi s^2} } e^{-(\\\\ln{x'} - m)^2/2 s^2} dx' \\\\]

For detailed description see Mathworld. 
";

%feature("docstring")  ROOT::Math::Cephes::normal_cdf_c "double ROOT::Math::normal_cdf_c(double x, double sigma=1, double x0=0)

Complement of the cumulative distribution function of the normal (Gaussian) distribution (upper tail).

\\\\[ D(x) = \\\\int_{x}^{+\\\\infty} {1 \\\\over \\\\sqrt{2 \\\\pi \\\\sigma^2}} e^{-x'^2 / 2\\\\sigma^2} dx' \\\\]

For detailed description see Mathworld. 
";

%feature("docstring")  ROOT::Math::Cephes::gaussian_cdf_c "double ROOT::Math::gaussian_cdf_c(double x, double sigma=1, double x0=0)

Alternative name for same function. 
";

%feature("docstring")  ROOT::Math::Cephes::normal_cdf "double ROOT::Math::normal_cdf(double x, double sigma=1, double x0=0)

Cumulative distribution function of the normal (Gaussian) distribution (lower tail).

\\\\[ D(x) = \\\\int_{-\\\\infty}^{x} {1 \\\\over \\\\sqrt{2 \\\\pi \\\\sigma^2}} e^{-x'^2 / 2\\\\sigma^2} dx' \\\\]

For detailed description see Mathworld. 
";

%feature("docstring")  ROOT::Math::Cephes::gaussian_cdf "double ROOT::Math::gaussian_cdf(double x, double sigma=1, double x0=0)

Alternative name for same function. 
";

%feature("docstring")  ROOT::Math::Cephes::tdistribution_cdf_c "double ROOT::Math::tdistribution_cdf_c(double x, double r, double x0=0)

Complement of the cumulative distribution function of Student's t-distribution (upper tail).

\\\\[ D_{r}(x) = \\\\int_{x}^{+\\\\infty} \\\\frac{\\\\Gamma(\\\\frac{r+1}{2})}{\\\\sqrt{r \\\\pi}\\\\Gamma(\\\\frac{r}{2})} \\\\left( 1+\\\\frac{x'^2}{r}\\\\right)^{-(r+1)/2} dx' \\\\]

For detailed description see Mathworld. It is implemented using the incomplete beta function, ROOT::Math::inc_beta, from Cephes
";

%feature("docstring")  ROOT::Math::Cephes::tdistribution_cdf "double ROOT::Math::tdistribution_cdf(double x, double r, double x0=0)

Cumulative distribution function of Student's t-distribution (lower tail).

\\\\[ D_{r}(x) = \\\\int_{-\\\\infty}^{x} \\\\frac{\\\\Gamma(\\\\frac{r+1}{2})}{\\\\sqrt{r \\\\pi}\\\\Gamma(\\\\frac{r}{2})} \\\\left( 1+\\\\frac{x'^2}{r}\\\\right)^{-(r+1)/2} dx' \\\\]

For detailed description see Mathworld. It is implemented using the incomplete beta function, ROOT::Math::inc_beta, from Cephes
";

%feature("docstring")  ROOT::Math::Cephes::uniform_cdf_c "double ROOT::Math::uniform_cdf_c(double x, double a, double b, double x0=0)

Complement of the cumulative distribution function of the uniform (flat) distribution (upper tail).

\\\\[ D(x) = \\\\int_{x}^{+\\\\infty} {1 \\\\over (b-a)} dx' \\\\]

For detailed description see Mathworld. 
";

%feature("docstring")  ROOT::Math::Cephes::uniform_cdf "double ROOT::Math::uniform_cdf(double x, double a, double b, double x0=0)

Cumulative distribution function of the uniform (flat) distribution (lower tail).

\\\\[ D(x) = \\\\int_{-\\\\infty}^{x} {1 \\\\over (b-a)} dx' \\\\]

For detailed description see Mathworld. 
";

%feature("docstring")  ROOT::Math::Cephes::poisson_cdf_c "double ROOT::Math::poisson_cdf_c(unsigned int n, double mu)

Complement of the cumulative distribution function of the Poisson distribution. Upper tail of the integral of the #poisson_pdf 
";

%feature("docstring")  ROOT::Math::Cephes::poisson_cdf "double ROOT::Math::poisson_cdf(unsigned int n, double mu)

Cumulative distribution function of the Poisson distribution Lower tail of the integral of the #poisson_pdf 
";

%feature("docstring")  ROOT::Math::Cephes::binomial_cdf_c "double ROOT::Math::binomial_cdf_c(unsigned int k, double p, unsigned int n)

Complement of the cumulative distribution function of the Binomial distribution. Upper tail of the integral of the #binomial_pdf 
";

%feature("docstring")  ROOT::Math::Cephes::binomial_cdf "double ROOT::Math::binomial_cdf(unsigned int k, double p, unsigned int n)

Cumulative distribution function of the Binomial distribution Lower tail of the integral of the #binomial_pdf 
";

%feature("docstring")  ROOT::Math::Cephes::negative_binomial_cdf_c "double ROOT::Math::negative_binomial_cdf_c(unsigned int k, double p, double n)

Complement of the cumulative distribution function of the Negative Binomial distribution. Upper tail of the integral of the #negative_binomial_pdf 
";

%feature("docstring")  ROOT::Math::Cephes::negative_binomial_cdf "double ROOT::Math::negative_binomial_cdf(unsigned int k, double p, double n)

Cumulative distribution function of the Negative Binomial distribution Lower tail of the integral of the #negative_binomial_pdf 
";

%feature("docstring")  ROOT::Math::Cephes::landau_xm1 "double ROOT::Math::landau_xm1(double x, double xi=1, double x0=0)

First moment (mean) of the truncated Landau distribution.  \\\\[ \\\\frac{1}{D (x)} \\\\int_{-\\\\infty}^{x} t\\\\, p(t) d t \\\\] where  $p(x)$ is the Landau distribution and  $D(x)$ its cumulative distribution function.

For detailed description see K.S. Klbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111[Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (XM1LAN) is used

Parameters:
-----------

x: 
The argument  $x$

xi: 
The width parameter  $\\\\xi$

x0: 
The location parameter  $x_0$
";

%feature("docstring")  ROOT::Math::Cephes::landau_xm2 "double ROOT::Math::landau_xm2(double x, double xi=1, double x0=0)

Second moment of the truncated Landau distribution.  \\\\[ \\\\frac{1}{D (x)} \\\\int_{-\\\\infty}^{x} t^2\\\\, p(t) d t \\\\] where  $p(x)$ is the Landau distribution and  $D(x)$ its cumulative distribution function.

For detailed description see K.S. Klbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111[Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (XM1LAN) is used

Parameters:
-----------

x: 
The argument  $x$

xi: 
The width parameter  $\\\\xi$

x0: 
The location parameter  $x_0$
";

%feature("docstring")  ROOT::Math::Cephes::Polynomialeval "double ROOT::Math::Polynomialeval(double x, double *a, unsigned int N)
";

%feature("docstring")  ROOT::Math::Cephes::Polynomial1eval "double ROOT::Math::Polynomial1eval(double x, double *a, unsigned int N)
";


// File: namespaceROOT_1_1Math_1_1Cephes.xml
%feature("docstring")  ROOT::Math::Cephes::igamc "double ROOT::Math::Cephes::igamc(double a, double x)

incomplete complementary gamma function igamc(a, x) = 1 - igam(a, x) 
";

%feature("docstring")  ROOT::Math::Cephes::igam "double ROOT::Math::Cephes::igam(double a, double x)
";

%feature("docstring")  ROOT::Math::Cephes::lgam "double ROOT::Math::Cephes::lgam(double x)
";

%feature("docstring")  ROOT::Math::Cephes::gamma "double ROOT::Math::Cephes::gamma(double x)
";

%feature("docstring")  ROOT::Math::Cephes::beta "double ROOT::Math::Cephes::beta(double z, double w)
";

%feature("docstring")  ROOT::Math::Cephes::incbet "double ROOT::Math::Cephes::incbet(double aa, double bb, double xx)
";

%feature("docstring")  ROOT::Math::Cephes::incbcf "double ROOT::Math::Cephes::incbcf(double a, double b, double x)
";

%feature("docstring")  ROOT::Math::Cephes::incbd "double ROOT::Math::Cephes::incbd(double a, double b, double x)
";

%feature("docstring")  ROOT::Math::Cephes::pseries "double ROOT::Math::Cephes::pseries(double a, double b, double x)
";

%feature("docstring")  ROOT::Math::Cephes::erf "double ROOT::Math::Cephes::erf(double a)
";

%feature("docstring")  ROOT::Math::Cephes::erfc "double ROOT::Math::Cephes::erfc(double a)
";

%feature("docstring")  ROOT::Math::Cephes::ndtri "double ROOT::Math::Cephes::ndtri(double y)
";

%feature("docstring")  ROOT::Math::Cephes::igami "double ROOT::Math::Cephes::igami(double a, double y)
";

%feature("docstring")  ROOT::Math::Cephes::incbi "double ROOT::Math::Cephes::incbi(double a, double b, double y)
";


// File: namespaceROOT_1_1Math_1_1Minim1D.xml


// File: namespaceROOT_1_1Math_1_1Util.xml
%feature("docstring")  ROOT::Math::Util::ToString "std::string ROOT::Math::Util::ToString(const T &val)

Utility function for conversion to strings 
";

%feature("docstring")  ROOT::Math::Util::EvalLog "T ROOT::Math::Util::EvalLog(T x)

safe evaluation of log(x) with a protections against negative or zero argument to the log smooth linear extrapolation below function values smaller than epsilon (better than a simple cut-off) 
";


// File: namespaceROOT_1_1Minuit2.xml
%feature("docstring")  ROOT::Minuit2::Inverse "ABObj<sym, MatrixInverse<sym, ABObj<sym, LASymMatrix, double>, double>, double> ROOT::Minuit2::Inverse(const ABObj< sym, LASymMatrix, double > &obj)

LAPACK Algebra functions specialize the Invert function for  LASymMatrix
";

%feature("docstring")  ROOT::Minuit2::Invert "int ROOT::Minuit2::Invert(LASymMatrix &)
";

%feature("docstring")  ROOT::Minuit2::Invert_undef_sym "int ROOT::Minuit2::Invert_undef_sym(LASymMatrix &)
";

%feature("docstring")  ROOT::Minuit2::Outer_product "ABObj<sym, VectorOuterProduct<ABObj<vec, LAVector, double>, double>, double> ROOT::Minuit2::Outer_product(const ABObj< vec, LAVector, double > &obj)

LAPACK Algebra function specialize the Outer_product function for  LAVector; 
";

%feature("docstring")  ROOT::Minuit2::Outer_prod "void ROOT::Minuit2::Outer_prod(LASymMatrix &, const LAVector &, double f=1.)
";

%feature("docstring")  ROOT::Minuit2::Mndaxpy "int ROOT::Minuit2::Mndaxpy(unsigned int, double, const double *, int, double *, int)
";

%feature("docstring")  ROOT::Minuit2::Mndscal "int ROOT::Minuit2::Mndscal(unsigned int, double, double *, int)
";

%feature("docstring")  ROOT::Minuit2::Mndspmv "int ROOT::Minuit2::Mndspmv(const char *, unsigned int, double, const double *, const double *, int, double, double *, int)
";

%feature("docstring")  ROOT::Minuit2::Inverse "ABObj<mt, MatrixInverse<mt, ABObj<mt, M, T>, T>, T> ROOT::Minuit2::Inverse(const ABObj< mt, M, T > &obj)
";

%feature("docstring")  ROOT::Minuit2::Outer_product "ABObj<sym, VectorOuterProduct<ABObj<vec, M, T>, T>, T> ROOT::Minuit2::Outer_product(const ABObj< vec, M, T > &obj)
";


// File: namespaceTestFunctions.xml
%feature("docstring")  TestFunctions::RosenBrock "double TestFunctions::RosenBrock(const std::vector< double > &par)

RosenBrock function: F(x,y) = 100 (y-x^2)^2 + (1-x)^2 start point: F(-1.2,1.0) = 24.20 minimum : F(1.0,1.0) = 0. 
";

%feature("docstring")  TestFunctions::WoodFour "double TestFunctions::WoodFour(const std::vector< double > &par)

Fourth-degree polynomial F(w,x,y,z) = 100 (y-w^2)^2 + (w-1)^2 + 90 (z-y^2)^2
(1-y)^2 + 10.1 [(x-1)^2 + (z-1)^2]

19.8 (x-1)(z-1)

start point: F(-3,-1,-3,-1) = 19192 minimum : F(1,1,1,1) = 0. 
";

%feature("docstring")  TestFunctions::DecayingSin "double TestFunctions::DecayingSin(double x, const std::vector< double > &par)

Decaying sinus from lmfit tutorial. 
";


// File: namespaceTMath.xml
%feature("docstring")  TMath::Abs "Short_t TMath::Abs(Short_t d)
";

%feature("docstring")  TMath::Abs "Int_t TMath::Abs(Int_t d)
";

%feature("docstring")  TMath::Abs "Long_t TMath::Abs(Long_t d)
";

%feature("docstring")  TMath::Abs "Long64_t TMath::Abs(Long64_t d)
";

%feature("docstring")  TMath::Abs "Float_t TMath::Abs(Float_t d)
";

%feature("docstring")  TMath::Abs "Double_t TMath::Abs(Double_t d)
";

%feature("docstring")  TMath::Abs "LongDouble_t TMath::Abs(LongDouble_t d)
";

%feature("docstring")  TMath::Even "Bool_t TMath::Even(Long_t a)
";

%feature("docstring")  TMath::Odd "Bool_t TMath::Odd(Long_t a)
";

%feature("docstring")  TMath::SignBit "Bool_t TMath::SignBit(Integer a)
";

%feature("docstring")  TMath::SignBit "Bool_t TMath::SignBit(Float_t a)
";

%feature("docstring")  TMath::SignBit "Bool_t TMath::SignBit(Double_t a)
";

%feature("docstring")  TMath::SignBit "Bool_t TMath::SignBit(LongDouble_t a)
";

%feature("docstring")  TMath::Sign "T1 TMath::Sign(T1 a, T2 b)
";

%feature("docstring")  TMath::Sign "Float_t TMath::Sign(Float_t a, Float_t b)
";

%feature("docstring")  TMath::Sign "Double_t TMath::Sign(Double_t a, Double_t b)
";

%feature("docstring")  TMath::Sign "LongDouble_t TMath::Sign(LongDouble_t a, LongDouble_t b)
";

%feature("docstring")  TMath::Min "Short_t TMath::Min(Short_t a, Short_t b)
";

%feature("docstring")  TMath::Min "UShort_t TMath::Min(UShort_t a, UShort_t b)
";

%feature("docstring")  TMath::Min "Int_t TMath::Min(Int_t a, Int_t b)
";

%feature("docstring")  TMath::Min "UInt_t TMath::Min(UInt_t a, UInt_t b)
";

%feature("docstring")  TMath::Min "Long_t TMath::Min(Long_t a, Long_t b)
";

%feature("docstring")  TMath::Min "ULong_t TMath::Min(ULong_t a, ULong_t b)
";

%feature("docstring")  TMath::Min "Long64_t TMath::Min(Long64_t a, Long64_t b)
";

%feature("docstring")  TMath::Min "ULong64_t TMath::Min(ULong64_t a, ULong64_t b)
";

%feature("docstring")  TMath::Min "Float_t TMath::Min(Float_t a, Float_t b)
";

%feature("docstring")  TMath::Min "Double_t TMath::Min(Double_t a, Double_t b)
";

%feature("docstring")  TMath::Max "Short_t TMath::Max(Short_t a, Short_t b)
";

%feature("docstring")  TMath::Max "UShort_t TMath::Max(UShort_t a, UShort_t b)
";

%feature("docstring")  TMath::Max "Int_t TMath::Max(Int_t a, Int_t b)
";

%feature("docstring")  TMath::Max "UInt_t TMath::Max(UInt_t a, UInt_t b)
";

%feature("docstring")  TMath::Max "Long_t TMath::Max(Long_t a, Long_t b)
";

%feature("docstring")  TMath::Max "ULong_t TMath::Max(ULong_t a, ULong_t b)
";

%feature("docstring")  TMath::Max "Long64_t TMath::Max(Long64_t a, Long64_t b)
";

%feature("docstring")  TMath::Max "ULong64_t TMath::Max(ULong64_t a, ULong64_t b)
";

%feature("docstring")  TMath::Max "Float_t TMath::Max(Float_t a, Float_t b)
";

%feature("docstring")  TMath::Max "Double_t TMath::Max(Double_t a, Double_t b)
";

%feature("docstring")  TMath::Range "Short_t TMath::Range(Short_t lb, Short_t ub, Short_t x)
";

%feature("docstring")  TMath::Range "Int_t TMath::Range(Int_t lb, Int_t ub, Int_t x)
";

%feature("docstring")  TMath::Range "Long_t TMath::Range(Long_t lb, Long_t ub, Long_t x)
";

%feature("docstring")  TMath::Range "ULong_t TMath::Range(ULong_t lb, ULong_t ub, ULong_t x)
";

%feature("docstring")  TMath::Range "Double_t TMath::Range(Double_t lb, Double_t ub, Double_t x)
";

%feature("docstring")  TMath::NextPrime "Long_t TMath::NextPrime(Long_t x)
";

%feature("docstring")  TMath::Pi "constexpr Double_t TMath::Pi()
";

%feature("docstring")  TMath::TwoPi "constexpr Double_t TMath::TwoPi()
";

%feature("docstring")  TMath::PiOver2 "constexpr Double_t TMath::PiOver2()
";

%feature("docstring")  TMath::PiOver4 "constexpr Double_t TMath::PiOver4()
";

%feature("docstring")  TMath::InvPi "constexpr Double_t TMath::InvPi()
";

%feature("docstring")  TMath::RadToDeg "constexpr Double_t TMath::RadToDeg()
";

%feature("docstring")  TMath::DegToRad "constexpr Double_t TMath::DegToRad()
";

%feature("docstring")  TMath::Sqrt2 "constexpr Double_t TMath::Sqrt2()
";

%feature("docstring")  TMath::E "constexpr Double_t TMath::E()
";

%feature("docstring")  TMath::Ln10 "constexpr Double_t TMath::Ln10()
";

%feature("docstring")  TMath::LogE "constexpr Double_t TMath::LogE()
";

%feature("docstring")  TMath::C "constexpr Double_t TMath::C()
";

%feature("docstring")  TMath::Ccgs "constexpr Double_t TMath::Ccgs()
";

%feature("docstring")  TMath::CUncertainty "constexpr Double_t TMath::CUncertainty()
";

%feature("docstring")  TMath::G "constexpr Double_t TMath::G()
";

%feature("docstring")  TMath::Gcgs "constexpr Double_t TMath::Gcgs()
";

%feature("docstring")  TMath::GUncertainty "constexpr Double_t TMath::GUncertainty()
";

%feature("docstring")  TMath::GhbarC "constexpr Double_t TMath::GhbarC()
";

%feature("docstring")  TMath::GhbarCUncertainty "constexpr Double_t TMath::GhbarCUncertainty()
";

%feature("docstring")  TMath::Gn "constexpr Double_t TMath::Gn()
";

%feature("docstring")  TMath::GnUncertainty "constexpr Double_t TMath::GnUncertainty()
";

%feature("docstring")  TMath::H "constexpr Double_t TMath::H()
";

%feature("docstring")  TMath::Hcgs "constexpr Double_t TMath::Hcgs()
";

%feature("docstring")  TMath::HUncertainty "constexpr Double_t TMath::HUncertainty()
";

%feature("docstring")  TMath::Hbar "constexpr Double_t TMath::Hbar()
";

%feature("docstring")  TMath::Hbarcgs "constexpr Double_t TMath::Hbarcgs()
";

%feature("docstring")  TMath::HbarUncertainty "constexpr Double_t TMath::HbarUncertainty()
";

%feature("docstring")  TMath::HC "constexpr Double_t TMath::HC()
";

%feature("docstring")  TMath::HCcgs "constexpr Double_t TMath::HCcgs()
";

%feature("docstring")  TMath::K "constexpr Double_t TMath::K()
";

%feature("docstring")  TMath::Kcgs "constexpr Double_t TMath::Kcgs()
";

%feature("docstring")  TMath::KUncertainty "constexpr Double_t TMath::KUncertainty()
";

%feature("docstring")  TMath::Sigma "constexpr Double_t TMath::Sigma()
";

%feature("docstring")  TMath::SigmaUncertainty "constexpr Double_t TMath::SigmaUncertainty()
";

%feature("docstring")  TMath::Na "constexpr Double_t TMath::Na()
";

%feature("docstring")  TMath::NaUncertainty "constexpr Double_t TMath::NaUncertainty()
";

%feature("docstring")  TMath::R "constexpr Double_t TMath::R()
";

%feature("docstring")  TMath::RUncertainty "constexpr Double_t TMath::RUncertainty()
";

%feature("docstring")  TMath::MWair "constexpr Double_t TMath::MWair()
";

%feature("docstring")  TMath::Rgair "constexpr Double_t TMath::Rgair()
";

%feature("docstring")  TMath::EulerGamma "constexpr Double_t TMath::EulerGamma()
";

%feature("docstring")  TMath::Qe "constexpr Double_t TMath::Qe()
";

%feature("docstring")  TMath::QeUncertainty "constexpr Double_t TMath::QeUncertainty()
";

%feature("docstring")  TMath::Sin "Double_t TMath::Sin(Double_t)
";

%feature("docstring")  TMath::Cos "Double_t TMath::Cos(Double_t)
";

%feature("docstring")  TMath::Tan "Double_t TMath::Tan(Double_t)
";

%feature("docstring")  TMath::SinH "Double_t TMath::SinH(Double_t)
";

%feature("docstring")  TMath::CosH "Double_t TMath::CosH(Double_t)
";

%feature("docstring")  TMath::TanH "Double_t TMath::TanH(Double_t)
";

%feature("docstring")  TMath::ASin "Double_t TMath::ASin(Double_t)
";

%feature("docstring")  TMath::ACos "Double_t TMath::ACos(Double_t)
";

%feature("docstring")  TMath::ATan "Double_t TMath::ATan(Double_t)
";

%feature("docstring")  TMath::ATan2 "Double_t TMath::ATan2(Double_t, Double_t)
";

%feature("docstring")  TMath::ASinH "Double_t TMath::ASinH(Double_t)
";

%feature("docstring")  TMath::ACosH "Double_t TMath::ACosH(Double_t)
";

%feature("docstring")  TMath::ATanH "Double_t TMath::ATanH(Double_t)
";

%feature("docstring")  TMath::Hypot "Double_t TMath::Hypot(Double_t x, Double_t y)
";

%feature("docstring")  TMath::Ceil "Double_t TMath::Ceil(Double_t x)
";

%feature("docstring")  TMath::CeilNint "Int_t TMath::CeilNint(Double_t x)
";

%feature("docstring")  TMath::Floor "Double_t TMath::Floor(Double_t x)
";

%feature("docstring")  TMath::FloorNint "Int_t TMath::FloorNint(Double_t x)
";

%feature("docstring")  TMath::Nint "Int_t TMath::Nint(T x)
";

%feature("docstring")  TMath::Sq "Double_t TMath::Sq(Double_t x)
";

%feature("docstring")  TMath::Sqrt "Double_t TMath::Sqrt(Double_t x)
";

%feature("docstring")  TMath::Exp "Double_t TMath::Exp(Double_t x)
";

%feature("docstring")  TMath::Ldexp "Double_t TMath::Ldexp(Double_t x, Int_t exp)
";

%feature("docstring")  TMath::Factorial "Double_t TMath::Factorial(Int_t i)
";

%feature("docstring")  TMath::Power "LongDouble_t TMath::Power(LongDouble_t x, LongDouble_t y)
";

%feature("docstring")  TMath::Power "LongDouble_t TMath::Power(LongDouble_t x, Long64_t y)
";

%feature("docstring")  TMath::Power "LongDouble_t TMath::Power(Long64_t x, Long64_t y)
";

%feature("docstring")  TMath::Power "Double_t TMath::Power(Double_t x, Double_t y)
";

%feature("docstring")  TMath::Power "Double_t TMath::Power(Double_t x, Int_t y)
";

%feature("docstring")  TMath::Log "Double_t TMath::Log(Double_t x)
";

%feature("docstring")  TMath::Log2 "Double_t TMath::Log2(Double_t x)
";

%feature("docstring")  TMath::Log10 "Double_t TMath::Log10(Double_t x)
";

%feature("docstring")  TMath::Finite "Int_t TMath::Finite(Double_t x)
";

%feature("docstring")  TMath::Finite "Int_t TMath::Finite(Float_t x)
";

%feature("docstring")  TMath::IsNaN "Bool_t TMath::IsNaN(Double_t x)
";

%feature("docstring")  TMath::IsNaN "Bool_t TMath::IsNaN(Float_t x)
";

%feature("docstring")  TMath::QuietNaN "Double_t TMath::QuietNaN()
";

%feature("docstring")  TMath::SignalingNaN "Double_t TMath::SignalingNaN()
";

%feature("docstring")  TMath::Infinity "Double_t TMath::Infinity()
";

%feature("docstring")  TMath::Hypot "Long_t TMath::Hypot(Long_t x, Long_t y)
";

%feature("docstring")  TMath::AreEqualAbs "Bool_t TMath::AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon)
";

%feature("docstring")  TMath::AreEqualRel "Bool_t TMath::AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)
";

%feature("docstring")  TMath::MinElement "T TMath::MinElement(Long64_t n, const T *a)
";

%feature("docstring")  TMath::MaxElement "T TMath::MaxElement(Long64_t n, const T *a)
";

%feature("docstring")  TMath::LocMin "Long64_t TMath::LocMin(Long64_t n, const T *a)
";

%feature("docstring")  TMath::LocMin "Iterator TMath::LocMin(Iterator first, Iterator last)
";

%feature("docstring")  TMath::LocMax "Long64_t TMath::LocMax(Long64_t n, const T *a)
";

%feature("docstring")  TMath::LocMax "Iterator TMath::LocMax(Iterator first, Iterator last)
";

%feature("docstring")  TMath::BinarySearch "Long64_t TMath::BinarySearch(Long64_t n, const T *array, T value)
";

%feature("docstring")  TMath::BinarySearch "Long64_t TMath::BinarySearch(Long64_t n, const T **array, T value)
";

%feature("docstring")  TMath::BinarySearch "Iterator TMath::BinarySearch(Iterator first, Iterator last, Element value)
";

%feature("docstring")  TMath::Sort "void TMath::Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)
";

%feature("docstring")  TMath::SortItr "void TMath::SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down=kTRUE)
";

%feature("docstring")  TMath::BubbleHigh "void TMath::BubbleHigh(Int_t Narr, Double_t *arr1, Int_t *arr2)
";

%feature("docstring")  TMath::BubbleLow "void TMath::BubbleLow(Int_t Narr, Double_t *arr1, Int_t *arr2)
";

%feature("docstring")  TMath::Permute "Bool_t TMath::Permute(Int_t n, Int_t *a)
";

%feature("docstring")  TMath::Quantiles "void TMath::Quantiles(Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=0, Int_t type=7)
";

%feature("docstring")  TMath::IsInside "Bool_t TMath::IsInside(T xp, T yp, Int_t np, T *x, T *y)
";

%feature("docstring")  TMath::Cross "T * TMath::Cross(const T v1[3], const T v2[3], T out[3])
";

%feature("docstring")  TMath::Normalize "Float_t TMath::Normalize(Float_t v[3])
";

%feature("docstring")  TMath::Normalize "Double_t TMath::Normalize(Double_t v[3])
";

%feature("docstring")  TMath::NormCross "T TMath::NormCross(const T v1[3], const T v2[3], T out[3])
";

%feature("docstring")  TMath::Normal2Plane "T * TMath::Normal2Plane(const T v1[3], const T v2[3], const T v3[3], T normal[3])
";

%feature("docstring")  TMath::RootsCubic "Bool_t TMath::RootsCubic(const Double_t coef[4], Double_t &a, Double_t &b, Double_t &c)
";

%feature("docstring")  TMath::Binomial "Double_t TMath::Binomial(Int_t n, Int_t k)
";

%feature("docstring")  TMath::BinomialI "Double_t TMath::BinomialI(Double_t p, Int_t n, Int_t k)
";

%feature("docstring")  TMath::BreitWigner "Double_t TMath::BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1)
";

%feature("docstring")  TMath::CauchyDist "Double_t TMath::CauchyDist(Double_t x, Double_t t=0, Double_t s=1)
";

%feature("docstring")  TMath::ChisquareQuantile "Double_t TMath::ChisquareQuantile(Double_t p, Double_t ndf)
";

%feature("docstring")  TMath::FDist "Double_t TMath::FDist(Double_t F, Double_t N, Double_t M)
";

%feature("docstring")  TMath::FDistI "Double_t TMath::FDistI(Double_t F, Double_t N, Double_t M)
";

%feature("docstring")  TMath::Gaus "Double_t TMath::Gaus(Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE)
";

%feature("docstring")  TMath::KolmogorovProb "Double_t TMath::KolmogorovProb(Double_t z)
";

%feature("docstring")  TMath::Landau "Double_t TMath::Landau(Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE)
";

%feature("docstring")  TMath::LandauI "Double_t TMath::LandauI(Double_t x)
";

%feature("docstring")  TMath::LaplaceDist "Double_t TMath::LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)
";

%feature("docstring")  TMath::LaplaceDistI "Double_t TMath::LaplaceDistI(Double_t x, Double_t alpha=0, Double_t beta=1)
";

%feature("docstring")  TMath::LogNormal "Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta=0, Double_t m=1)
";

%feature("docstring")  TMath::NormQuantile "Double_t TMath::NormQuantile(Double_t p)
";

%feature("docstring")  TMath::Poisson "Double_t TMath::Poisson(Double_t x, Double_t par)
";

%feature("docstring")  TMath::PoissonI "Double_t TMath::PoissonI(Double_t x, Double_t par)
";

%feature("docstring")  TMath::Prob "Double_t TMath::Prob(Double_t chi2, Int_t ndf)
";

%feature("docstring")  TMath::Student "Double_t TMath::Student(Double_t T, Double_t ndf)
";

%feature("docstring")  TMath::StudentI "Double_t TMath::StudentI(Double_t T, Double_t ndf)
";

%feature("docstring")  TMath::StudentQuantile "Double_t TMath::StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail=kTRUE)
";

%feature("docstring")  TMath::Vavilov "Double_t TMath::Vavilov(Double_t x, Double_t kappa, Double_t beta2)
";

%feature("docstring")  TMath::VavilovI "Double_t TMath::VavilovI(Double_t x, Double_t kappa, Double_t beta2)
";

%feature("docstring")  TMath::Voigt "Double_t TMath::Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r=4)
";

%feature("docstring")  TMath::Mean "Double_t TMath::Mean(Long64_t n, const T *a, const Double_t *w=0)
";

%feature("docstring")  TMath::Mean "Double_t TMath::Mean(Iterator first, Iterator last)
";

%feature("docstring")  TMath::Mean "Double_t TMath::Mean(Iterator first, Iterator last, WeightIterator wfirst)
";

%feature("docstring")  TMath::GeomMean "Double_t TMath::GeomMean(Long64_t n, const T *a)
";

%feature("docstring")  TMath::GeomMean "Double_t TMath::GeomMean(Iterator first, Iterator last)
";

%feature("docstring")  TMath::RMS "Double_t TMath::RMS(Long64_t n, const T *a, const Double_t *w=0)
";

%feature("docstring")  TMath::RMS "Double_t TMath::RMS(Iterator first, Iterator last)
";

%feature("docstring")  TMath::RMS "Double_t TMath::RMS(Iterator first, Iterator last, WeightIterator wfirst)
";

%feature("docstring")  TMath::StdDev "Double_t TMath::StdDev(Long64_t n, const T *a, const Double_t *w=0)
";

%feature("docstring")  TMath::StdDev "Double_t TMath::StdDev(Iterator first, Iterator last)
";

%feature("docstring")  TMath::StdDev "Double_t TMath::StdDev(Iterator first, Iterator last, WeightIterator wfirst)
";

%feature("docstring")  TMath::Median "Double_t TMath::Median(Long64_t n, const T *a, const Double_t *w=0, Long64_t *work=0)
";

%feature("docstring")  TMath::KOrdStat "Element TMath::KOrdStat(Size n, const Element *a, Size k, Size *work=0)
";

%feature("docstring")  TMath::Beta "Double_t TMath::Beta(Double_t p, Double_t q)
";

%feature("docstring")  TMath::BetaCf "Double_t TMath::BetaCf(Double_t x, Double_t a, Double_t b)
";

%feature("docstring")  TMath::BetaDist "Double_t TMath::BetaDist(Double_t x, Double_t p, Double_t q)
";

%feature("docstring")  TMath::BetaDistI "Double_t TMath::BetaDistI(Double_t x, Double_t p, Double_t q)
";

%feature("docstring")  TMath::BetaIncomplete "Double_t TMath::BetaIncomplete(Double_t x, Double_t a, Double_t b)
";

%feature("docstring")  TMath::BesselI "Double_t TMath::BesselI(Int_t n, Double_t x)
";

%feature("docstring")  TMath::BesselK "Double_t TMath::BesselK(Int_t n, Double_t x)
";

%feature("docstring")  TMath::BesselI0 "Double_t TMath::BesselI0(Double_t x)
";

%feature("docstring")  TMath::BesselK0 "Double_t TMath::BesselK0(Double_t x)
";

%feature("docstring")  TMath::BesselI1 "Double_t TMath::BesselI1(Double_t x)
";

%feature("docstring")  TMath::BesselK1 "Double_t TMath::BesselK1(Double_t x)
";

%feature("docstring")  TMath::BesselJ0 "Double_t TMath::BesselJ0(Double_t x)
";

%feature("docstring")  TMath::BesselJ1 "Double_t TMath::BesselJ1(Double_t x)
";

%feature("docstring")  TMath::BesselY0 "Double_t TMath::BesselY0(Double_t x)
";

%feature("docstring")  TMath::BesselY1 "Double_t TMath::BesselY1(Double_t x)
";

%feature("docstring")  TMath::StruveH0 "Double_t TMath::StruveH0(Double_t x)
";

%feature("docstring")  TMath::StruveH1 "Double_t TMath::StruveH1(Double_t x)
";

%feature("docstring")  TMath::StruveL0 "Double_t TMath::StruveL0(Double_t x)
";

%feature("docstring")  TMath::StruveL1 "Double_t TMath::StruveL1(Double_t x)
";

%feature("docstring")  TMath::DiLog "Double_t TMath::DiLog(Double_t x)
";

%feature("docstring")  TMath::Erf "Double_t TMath::Erf(Double_t x)
";

%feature("docstring")  TMath::ErfInverse "Double_t TMath::ErfInverse(Double_t x)
";

%feature("docstring")  TMath::Erfc "Double_t TMath::Erfc(Double_t x)
";

%feature("docstring")  TMath::ErfcInverse "Double_t TMath::ErfcInverse(Double_t x)
";

%feature("docstring")  TMath::Freq "Double_t TMath::Freq(Double_t x)
";

%feature("docstring")  TMath::Gamma "Double_t TMath::Gamma(Double_t z)
";

%feature("docstring")  TMath::Gamma "Double_t TMath::Gamma(Double_t a, Double_t x)
";

%feature("docstring")  TMath::GammaDist "Double_t TMath::GammaDist(Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1)
";

%feature("docstring")  TMath::LnGamma "Double_t TMath::LnGamma(Double_t z)
";


// File: namespaceTMVA.xml
%feature("docstring")  TMVA::Endl "MsgLogger& TMVA::Endl(MsgLogger &ml)
";


// File: RConfig_8h.xml


// File: Riostream_8h.xml


// File: Rtypes_8h.xml


// File: RtypesCore_8h.xml


// File: TError_8h.xml
%feature("docstring")  insert_messages "void insert_messages(std::stringstream &ss)
";

%feature("docstring")  insert_messages "void insert_messages(std::stringstream &ss, T var1, Types... var2)
";

%feature("docstring")  logHelperMessage "void logHelperMessage(std::string severity, Args &&... args)
";

%feature("docstring")  Info "void Info(Ts &&... args)
";

%feature("docstring")  Error "void Error(Ts &&... args)
";

%feature("docstring")  Warning "void Warning(Ts &&... args)
";


// File: TMathBase_8h.xml


// File: TNamed_8h.xml


// File: TObject_8h.xml


// File: TString_8h.xml


// File: TUUID_8h.xml


// File: BinData_8h.xml


// File: Chi2FCN_8h.xml


// File: DataOptions_8h.xml


// File: DataRange_8h.xml


// File: FcnAdapter_8h.xml


// File: FitConfig_8h.xml


// File: FitResult_8h.xml


// File: Fitter_8h.xml


// File: FitUtil_8h.xml


// File: LogLikelihoodFCN_8h.xml


// File: ParameterSettings_8h.xml


// File: PoissonLikelihoodFCN_8h.xml


// File: SparseData_8h.xml


// File: UnBinData_8h.xml


// File: BasicMinimizer_8h.xml


// File: Derivator_8h.xml


// File: DistFunc_8h.xml


// File: Error_8h.xml


// File: FitMethodFunction_8h.xml


// File: Functor_8h.xml


// File: GenAlgoOptions_8h.xml


// File: 3rdParty_2RootMinimizers_2mathcore_2Math_2GeneticMinimizer_8h.xml


// File: Adapter_2GeneticMinimizer_8h.xml


// File: GSL1DMinimizerWrapper_8h.xml


// File: GSLDerivator_8h.xml


// File: GSLFunctionAdapter_8h.xml


// File: GSLFunctionWrapper_8h.xml


// File: GSLMinimizer_8h.xml


// File: GSLMinimizer1D_8h.xml


// File: GSLMultiFit_8h.xml


// File: GSLMultiFitFunctionAdapter_8h.xml


// File: GSLMultiFitFunctionWrapper_8h.xml


// File: GSLMultiMinFunctionAdapter_8h.xml


// File: GSLMultiMinFunctionWrapper_8h.xml


// File: 3rdParty_2RootMinimizers_2mathcore_2Math_2GSLMultiMinimizer_8h.xml


// File: Adapter_2GSLMultiMinimizer_8h.xml


// File: GSLNLSMinimizer_8h.xml


// File: GSLRandomFunctions_8h.xml


// File: GSLRndmEngines_8h.xml


// File: GSLRngROOTWrapper_8h.xml


// File: GSLRngWrapper_8h.xml


// File: GSLSimAnMinimizer_8h.xml


// File: GSLSimAnnealing_8h.xml


// File: IFunction_8h.xml


// File: IFunctionfwd_8h.xml


// File: IMinimizer1D_8h.xml


// File: IOptions_8h.xml


// File: IParamFunction_8h.xml


// File: IParamFunctionfwd_8h.xml


// File: Math_8h.xml


// File: 3rdParty_2RootMinimizers_2mathcore_2Math_2Minimizer_8h.xml


// File: Kernel_2Minimizer_8h.xml


// File: 3rdParty_2RootMinimizers_2mathcore_2Math_2MinimizerOptions_8h.xml


// File: Minimizer_2MinimizerOptions_8h.xml


// File: MinimizerVariableTransformation_8h.xml


// File: MinimTransformFunction_8h.xml


// File: MinimTransformVariable_8h.xml


// File: mixmax_8h.xml
%feature("docstring")  rng_get_N "int rng_get_N(void)
";

%feature("docstring")  rng_alloc "rng_state_t* rng_alloc()
";

%feature("docstring")  rng_free "int rng_free(rng_state_t *X)
";

%feature("docstring")  rng_copy "rng_state_t* rng_copy(myuint *Y)
";

%feature("docstring")  read_state "void read_state(rng_state_t *X, const char filename[])
";

%feature("docstring")  print_state "void print_state(rng_state_t *X)
";

%feature("docstring")  iterate "int iterate(rng_state_t *X)
";

%feature("docstring")  iterate_raw_vec "myuint iterate_raw_vec(myuint *Y, myuint sumtotOld)
";

%feature("docstring")  seed_uniquestream "void seed_uniquestream(rng_state_t *X, myID_t clusterID, myID_t machineID, myID_t runID, myID_t streamID)
";

%feature("docstring")  seed_spbox "void seed_spbox(rng_state_t *X, myuint seed)
";

%feature("docstring")  seed_vielbein "void seed_vielbein(rng_state_t *X, unsigned int i)
";

%feature("docstring")  fill_array "void fill_array(rng_state_t *X, unsigned int n, double *array)
";

%feature("docstring")  iterate_and_fill_array "void iterate_and_fill_array(rng_state_t *X, double *array)
";

%feature("docstring")  precalc "myuint precalc(rng_state_t *X)
";

%feature("docstring")  apply_bigskip "myuint apply_bigskip(myuint *Vout, myuint *Vin, myID_t clusterID, myID_t machineID, myID_t runID, myID_t streamID)
";

%feature("docstring")  branch_inplace "void branch_inplace(rng_state_t *Xin, myID_t *ID)
";

%feature("docstring")  modadd "myuint modadd(myuint foo, myuint bar)
";

%feature("docstring")  fmodmulM61 "myuint fmodmulM61(myuint cum, myuint s, myuint a)
";

%feature("docstring")  GET_BY_MACRO "myuint GET_BY_MACRO(rng_state_t *X)
";

%feature("docstring")  get_next_float_BY_MACRO "double get_next_float_BY_MACRO(rng_state_t *X)
";


// File: MixMaxEngine_8h.xml


// File: MixMaxEngineImpl_8h.xml


// File: MultiNumGradFunction_8h.xml


// File: OneDimFunctionAdapter_8h.xml


// File: PdfFuncMathCore_8h.xml


// File: ProbFuncMathCore_8h.xml


// File: RandomFunctions_8h.xml


// File: SpecFuncCephes_8h.xml


// File: SpecFuncMathCore_8h.xml


// File: TRandomEngine_8h.xml


// File: 3rdParty_2RootMinimizers_2mathcore_2Math_2Types_8h.xml


// File: 3rdParty_2RootMinimizers_2TMVA_2Types_8h.xml


// File: Minimizer_2Types_8h.xml


// File: Util_8h.xml


// File: WrappedFunction_8h.xml


// File: WrappedParamFunction_8h.xml


// File: TMath_8h.xml


// File: TRandom_8h.xml


// File: TRandom2_8h.xml


// File: TRandom3_8h.xml


// File: ABObj_8h.xml


// File: ABProd_8h.xml


// File: ABSum_8h.xml


// File: ABTypes_8h.xml


// File: AnalyticalGradientCalculator_8h.xml


// File: BasicFunctionGradient_8h.xml


// File: BasicFunctionMinimum_8h.xml


// File: BasicMinimumError_8h.xml


// File: BasicMinimumParameters_8h.xml


// File: BasicMinimumSeed_8h.xml


// File: BasicMinimumState_8h.xml


// File: BFGSErrorUpdator_8h.xml


// File: CombinedMinimizer_8h.xml


// File: CombinedMinimumBuilder_8h.xml


// File: ContoursError_8h.xml


// File: DavidonErrorUpdator_8h.xml


// File: FCNAdapter_8h.xml


// File: FCNBase_8h.xml


// File: FCNGradAdapter_8h.xml


// File: FCNGradientBase_8h.xml


// File: FumiliBuilder_8h.xml


// File: FumiliChi2FCN_8h.xml


// File: FumiliErrorUpdator_8h.xml


// File: FumiliFCNAdapter_8h.xml


// File: FumiliFCNBase_8h.xml


// File: FumiliGradientCalculator_8h.xml


// File: FumiliMaximumLikelihoodFCN_8h.xml


// File: FumiliMinimizer_8h.xml


// File: FumiliStandardChi2FCN_8h.xml


// File: FumiliStandardMaximumLikelihoodFCN_8h.xml


// File: FunctionGradient_8h.xml


// File: FunctionMinimizer_8h.xml


// File: FunctionMinimum_8h.xml


// File: GenericFunction_8h.xml


// File: GradientCalculator_8h.xml


// File: HessianGradientCalculator_8h.xml


// File: InitialGradientCalculator_8h.xml


// File: LaInverse_8h.xml


// File: LaOuterProduct_8h.xml


// File: LaProd_8h.xml


// File: LaSum_8h.xml


// File: LASymMatrix_8h.xml


// File: LAVector_8h.xml


// File: MatrixInverse_8h.xml


// File: MinimumBuilder_8h.xml


// File: MinimumError_8h.xml


// File: MinimumErrorUpdator_8h.xml


// File: MinimumParameters_8h.xml


// File: MinimumSeed_8h.xml


// File: MinimumSeedGenerator_8h.xml


// File: MinimumState_8h.xml


// File: MinosError_8h.xml


// File: 3rdParty_2RootMinimizers_2Minuit2_2Minuit2Minimizer_8h.xml


// File: Adapter_2Minuit2Minimizer_8h.xml


// File: MinuitParameter_8h.xml


// File: MnApplication_8h.xml


// File: MnConfig_8h.xml


// File: MnContours_8h.xml


// File: MnCovarianceSqueeze_8h.xml


// File: MnCross_8h.xml


// File: MnEigen_8h.xml


// File: MnFcn_8h.xml


// File: MnFumiliMinimize_8h.xml


// File: MnFunctionCross_8h.xml


// File: MnGlobalCorrelationCoeff_8h.xml


// File: MnHesse_8h.xml


// File: MnLineSearch_8h.xml


// File: MnMachinePrecision_8h.xml


// File: MnMatrix_8h.xml


// File: MnMigrad_8h.xml


// File: MnMinimize_8h.xml


// File: MnMinos_8h.xml


// File: MnParabola_8h.xml


// File: MnParabolaFactory_8h.xml


// File: MnParabolaPoint_8h.xml


// File: MnParameterScan_8h.xml


// File: MnPlot_8h.xml


// File: MnPosDef_8h.xml


// File: MnPrint_8h.xml


// File: MnRefCountedPointer_8h.xml


// File: MnReferenceCounter_8h.xml


// File: MnScan_8h.xml


// File: MnSeedGenerator_8h.xml


// File: MnSimplex_8h.xml


// File: MnStrategy_8h.xml


// File: MnTiny_8h.xml


// File: MnTraceObject_8h.xml


// File: MnUserCovariance_8h.xml


// File: MnUserFcn_8h.xml


// File: MnUserParameters_8h.xml


// File: MnUserParameterState_8h.xml


// File: MnUserTransformation_8h.xml


// File: MnVectorTransform_8h.xml


// File: ModularFunctionMinimizer_8h.xml


// File: MPIProcess_8h.xml


// File: NegativeG2LineSearch_8h.xml


// File: Numerical2PGradientCalculator_8h.xml


// File: ParametricFunction_8h.xml


// File: ScanBuilder_8h.xml


// File: ScanMinimizer_8h.xml


// File: SimplexBuilder_8h.xml


// File: SimplexMinimizer_8h.xml


// File: SimplexParameters_8h.xml


// File: SimplexSeedGenerator_8h.xml


// File: SinParameterTransformation_8h.xml


// File: SqrtLowParameterTransformation_8h.xml


// File: SqrtUpParameterTransformation_8h.xml


// File: StackAllocator_8h.xml


// File: VariableMetricBuilder_8h.xml


// File: VariableMetricEDMEstimator_8h.xml


// File: VariableMetricMinimizer_8h.xml


// File: VectorOuterProduct_8h.xml


// File: GeneticAlgorithm_8h.xml


// File: GeneticGenes_8h.xml


// File: GeneticPopulation_8h.xml


// File: GeneticRange_8h.xml


// File: IFitterTarget_8h.xml


// File: Interval_8h.xml


// File: MsgLogger_8h.xml


// File: GeneticMinimizer_8cpp.xml


// File: GSLLevenbergMarquardtMinimizer_8cpp.xml


// File: GSLLevenbergMarquardtMinimizer_8h.xml


// File: GSLMultiMinimizer_8cpp.xml


// File: IFunctionAdapter_8cpp.xml


// File: IFunctionAdapter_8h.xml


// File: MinimizerAdapter_8cpp.xml


// File: MinimizerAdapter_8h.xml


// File: Minuit2Minimizer_8cpp.xml


// File: ObjectiveFunctionAdapter_8cpp.xml


// File: ObjectiveFunctionAdapter_8h.xml


// File: Report_8cpp.xml


// File: Report_8h.xml


// File: ResidualFunctionAdapter_8cpp.xml


// File: ResidualFunctionAdapter_8h.xml


// File: RootResidualFunction_8cpp.xml


// File: RootResidualFunction_8h.xml


// File: RootScalarFunction_8cpp.xml


// File: RootScalarFunction_8h.xml


// File: ScalarFunctionAdapter_8cpp.xml


// File: ScalarFunctionAdapter_8h.xml


// File: SimAnMinimizer_8cpp.xml


// File: SimAnMinimizer_8h.xml


// File: FitOptions_8cpp.xml


// File: FitOptions_8h.xml


// File: Kernel_8cpp.xml


// File: Kernel_8h.xml


// File: Minimizer_8cpp.xml


// File: MinimizerFactory_8cpp.xml


// File: MinimizerFactory_8h.xml


// File: PyCallback_8cpp.xml


// File: PyCallback_8h.xml


// File: IMinimizer_8cpp.xml


// File: IMinimizer_8h.xml


// File: MinimizerCatalog_8cpp.xml


// File: MinimizerCatalog_8h.xml


// File: MinimizerInfo_8cpp.xml


// File: MinimizerInfo_8h.xml


// File: MinimizerOptions_8cpp.xml


// File: MinimizerResult_8cpp.xml


// File: MinimizerResult_8h.xml


// File: TestMinimizer_8cpp.xml


// File: TestMinimizer_8h.xml


// File: AttLimits_8cpp.xml


// File: AttLimits_8h.xml


// File: Attributes_8h.xml


// File: Parameter_8cpp.xml


// File: Parameter_8h.xml


// File: ParameterPlan_8h.xml


// File: Parameters_8cpp.xml


// File: Parameters_8h.xml


// File: RealLimits_8cpp.xml


// File: RealLimits_8h.xml


// File: ClassicalTestFunctions_8cpp.xml


// File: ClassicalTestFunctions_8h.xml


// File: MinimizerTests_8cpp.xml
%feature("docstring")  run "bool run(const std::string &minimizer_name, const std::string &algorithm_name, const std::string &fit_plan_name, const std::string &options=\"\")
";

%feature("docstring")  TEST_F "TEST_F(Minimize, MinuitTestV1)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, MinuitTestV2)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, MinuitTestV3)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, SteepestDescentTestV2)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, ConjugateFRTestV1)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, ConjugateFRTestV2)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, ConjugatePRTestV1)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, ConjugatePRTestV2)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, BfgsTestV1)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, BfgsTestV2)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, Bfgs2TestV1)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, Bfgs2TestV2)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, GSLSimAnTestV1)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, GSLSimAnTestV2)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, GeneticTestV1)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, GeneticTestV2)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, FumiliTestV3)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, LevenbergMarquardtV3)
";

%feature("docstring")  TEST_F "TEST_F(Minimize, TestMinimizerV1)
";


// File: PlanCases_8cpp.xml


// File: PlanCases_8h.xml


// File: PlanFactory_8cpp.xml


// File: PlanFactory_8h.xml


// File: ResidualTestPlan_8cpp.xml


// File: ResidualTestPlan_8h.xml


// File: ScalarTestPlan_8cpp.xml


// File: ScalarTestPlan_8h.xml


// File: AttLimitsTest_8cpp.xml
%feature("docstring")  TEST_F "TEST_F(AttLimitsTest, InitialState)
";

%feature("docstring")  TEST_F "TEST_F(AttLimitsTest, LowerLimited)
";

%feature("docstring")  TEST_F "TEST_F(AttLimitsTest, UpperLimited)
";

%feature("docstring")  TEST_F "TEST_F(AttLimitsTest, Fixed)
";

%feature("docstring")  TEST_F "TEST_F(AttLimitsTest, Limited)
";


// File: MinimizerOptionsTest_8cpp.xml
%feature("docstring")  TEST_F "TEST_F(MinimizerOptionsTest, toOptionString)
";

%feature("docstring")  TEST_F "TEST_F(MinimizerOptionsTest, setOptionsFromString)
";


// File: MultiOptionTest_8cpp.xml
%feature("docstring")  TEST_F "TEST_F(MultiOptionTest, Variant)
";

%feature("docstring")  TEST_F "TEST_F(MultiOptionTest, Construction)
";

%feature("docstring")  TEST_F "TEST_F(MultiOptionTest, Copying)
";

%feature("docstring")  TEST_F "TEST_F(MultiOptionTest, Assignment)
";

%feature("docstring")  TEST_F "TEST_F(MultiOptionTest, SetFromString)
";


// File: OptionContainerTest_8cpp.xml
%feature("docstring")  TEST_F "TEST_F(OptionContainerTest, addOption)
";

%feature("docstring")  TEST_F "TEST_F(OptionContainerTest, getOptionValue)
";

%feature("docstring")  TEST_F "TEST_F(OptionContainerTest, setOptionValue)
";

%feature("docstring")  TEST_F "TEST_F(OptionContainerTest, Copying)
";

%feature("docstring")  TEST_F "TEST_F(OptionContainerTest, Assignment)
";


// File: ParametersTest_8cpp.xml
%feature("docstring")  TEST_F "TEST_F(ParametersTest, defaultConstructor)
";

%feature("docstring")  TEST_F "TEST_F(ParametersTest, addParameter)
";

%feature("docstring")  TEST_F "TEST_F(ParametersTest, setters)
";

%feature("docstring")  TEST_F "TEST_F(ParametersTest, freeParameterCount)
";


// File: ParameterTest_8cpp.xml
%feature("docstring")  TEST_F "TEST_F(ParameterTest, defaultConstructor)
";

%feature("docstring")  TEST_F "TEST_F(ParameterTest, fullConstructor)
";

%feature("docstring")  TEST_F "TEST_F(ParameterTest, defaultStep)
";

%feature("docstring")  TEST_F "TEST_F(ParameterTest, setters)
";


// File: RealLimitsTest_8cpp.xml
%feature("docstring")  TEST_F "TEST_F(RealLimitsTest, LimitsInitial)
";

%feature("docstring")  TEST_F "TEST_F(RealLimitsTest, LimitsSetLimit)
";

%feature("docstring")  TEST_F "TEST_F(RealLimitsTest, LimitsLowerLimited)
";

%feature("docstring")  TEST_F "TEST_F(RealLimitsTest, LimitsUpperLimited)
";

%feature("docstring")  TEST_F "TEST_F(RealLimitsTest, LimitsLimited)
";

%feature("docstring")  TEST_F "TEST_F(RealLimitsTest, LimitsLimitless)
";

%feature("docstring")  TEST_F "TEST_F(RealLimitsTest, ComparisonOperators)
";

%feature("docstring")  TEST_F "TEST_F(RealLimitsTest, CopyConstructor)
";


// File: IFactory_8h.xml


// File: MinimizerTestPlan_8cpp.xml


// File: MinimizerTestPlan_8h.xml


// File: MinimizerUtils_8cpp.xml


// File: MinimizerUtils_8h.xml


// File: MultiOption_8cpp.xml


// File: MultiOption_8h.xml


// File: OptionContainer_8cpp.xml


// File: OptionContainer_8h.xml


// File: StringUtils_8cpp.xml


// File: StringUtils_8h.xml


// File: WallclockTimer_8cpp.xml


// File: WallclockTimer_8h.xml


// File: group__FitMethodFunc.xml


// File: group__Fit.xml


// File: group__FitMain.xml


// File: group__Functor__int.xml


// File: group__Deriv.xml


// File: group__CppFunctions.xml


// File: group__GenFunc.xml


// File: group__Min1D.xml


// File: group__ParamFunc.xml


// File: group__MultiMin.xml


// File: group__StatFunc.xml


// File: group__PdfFunc.xml


// File: group__ProbFunc.xml


// File: group__TruncFunc.xml


// File: group__SpecFunc.xml


// File: group__Minuit.xml


// File: todo.xml


// File: dir_8ae0efe7456791dfeac894a528609b12.xml


// File: dir_d6063ef14e63c037d0d36c201f22d500.xml


// File: dir_ead683f11b26d141553bc0f1c348dc86.xml


// File: dir_892d84e8d1420bf45a9053cf0eede900.xml


// File: dir_05e24f99ab216f03e9d0cf366ad39939.xml


// File: dir_ddbc8017d498762c6500a9e593e25277.xml


// File: dir_1e78b92bbf434f7a48ae41e2e34e54a5.xml


// File: dir_346bee264126587e5b77542d134e4add.xml


// File: dir_5432497378cfbce702dc5799f292905b.xml


// File: dir_7c95011753c2f8fb6f2a9c22c1fbdc50.xml


// File: dir_60772aca5f018fa4d428540699d2a67c.xml


// File: dir_38d3fa544be6e05025bba6e85a25baf3.xml


// File: dir_12a615ebc0dd823b442810a88f796ca8.xml


// File: dir_161f9d4f12f98df16f019e01b3594bb8.xml


// File: dir_03da15e295bc2986014d40bf58034da8.xml


// File: dir_1b9c80e0f855929b0ed66bb33423a8ec.xml


// File: dir_e87cef4d6f8e4c4c298cf0a4783d30f5.xml


// File: dir_0b8fa0618b80f8e0f53043618afef9ab.xml

