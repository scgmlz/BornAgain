# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

import _libBornAgainDevice

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainDevice.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainDevice.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _libBornAgainDevice.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _libBornAgainDevice.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _libBornAgainDevice.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainDevice.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _libBornAgainDevice.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainDevice.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainDevice.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainDevice.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainDevice.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainDevice.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainDevice.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainDevice.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainDevice.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainDevice.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _libBornAgainDevice.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _libBornAgainDevice:
_libBornAgainDevice.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _libBornAgainDevice.SHARED_PTR_DISOWN


import warnings
def deprecated(message):
  def deprecated_decorator(func):
      def deprecated_func(*args, **kwargs):
          warnings.simplefilter('always', DeprecationWarning)  # turn off filter
          warnings.warn("{} is a deprecated function. {}".format(func.__name__, message),
                        category=DeprecationWarning,
                        stacklevel=2)
          warnings.simplefilter('default', DeprecationWarning)  # reset filter
          return func(*args, **kwargs)
      return deprecated_func
  return deprecated_decorator

class vdouble1d_t(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vdouble1d_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.vdouble1d_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vdouble1d_t self) -> bool"""
        return _libBornAgainDevice.vdouble1d_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vdouble1d_t self) -> bool"""
        return _libBornAgainDevice.vdouble1d_t___bool__(self)

    def __len__(self):
        r"""__len__(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainDevice.vdouble1d_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> vdouble1d_t"""
        return _libBornAgainDevice.vdouble1d_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, vdouble1d_t v)
        """
        return _libBornAgainDevice.vdouble1d_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _libBornAgainDevice.vdouble1d_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vdouble1d_t self, std::vector< double >::difference_type i)
        __delitem__(vdouble1d_t self, PySliceObject * slice)
        """
        return _libBornAgainDevice.vdouble1d_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vdouble1d_t self, PySliceObject * slice) -> vdouble1d_t
        __getitem__(vdouble1d_t self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _libBornAgainDevice.vdouble1d_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vdouble1d_t self, PySliceObject * slice, vdouble1d_t v)
        __setitem__(vdouble1d_t self, PySliceObject * slice)
        __setitem__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _libBornAgainDevice.vdouble1d_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vdouble1d_t self) -> std::vector< double >::value_type"""
        return _libBornAgainDevice.vdouble1d_t_pop(self)

    def append(self, x):
        r"""append(vdouble1d_t self, std::vector< double >::value_type const & x)"""
        return _libBornAgainDevice.vdouble1d_t_append(self, x)

    def empty(self):
        r"""empty(vdouble1d_t self) -> bool"""
        return _libBornAgainDevice.vdouble1d_t_empty(self)

    def size(self):
        r"""size(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainDevice.vdouble1d_t_size(self)

    def swap(self, v):
        r"""swap(vdouble1d_t self, vdouble1d_t v)"""
        return _libBornAgainDevice.vdouble1d_t_swap(self, v)

    def begin(self):
        r"""begin(vdouble1d_t self) -> std::vector< double >::iterator"""
        return _libBornAgainDevice.vdouble1d_t_begin(self)

    def end(self):
        r"""end(vdouble1d_t self) -> std::vector< double >::iterator"""
        return _libBornAgainDevice.vdouble1d_t_end(self)

    def rbegin(self):
        r"""rbegin(vdouble1d_t self) -> std::vector< double >::reverse_iterator"""
        return _libBornAgainDevice.vdouble1d_t_rbegin(self)

    def rend(self):
        r"""rend(vdouble1d_t self) -> std::vector< double >::reverse_iterator"""
        return _libBornAgainDevice.vdouble1d_t_rend(self)

    def clear(self):
        r"""clear(vdouble1d_t self)"""
        return _libBornAgainDevice.vdouble1d_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vdouble1d_t self) -> std::vector< double >::allocator_type"""
        return _libBornAgainDevice.vdouble1d_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vdouble1d_t self)"""
        return _libBornAgainDevice.vdouble1d_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vdouble1d_t self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(vdouble1d_t self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _libBornAgainDevice.vdouble1d_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vdouble1d_t self) -> vdouble1d_t
        __init__(vdouble1d_t self, vdouble1d_t other) -> vdouble1d_t
        __init__(vdouble1d_t self, std::vector< double >::size_type size) -> vdouble1d_t
        __init__(vdouble1d_t self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> vdouble1d_t
        """
        _libBornAgainDevice.vdouble1d_t_swiginit(self, _libBornAgainDevice.new_vdouble1d_t(*args))

    def push_back(self, x):
        r"""push_back(vdouble1d_t self, std::vector< double >::value_type const & x)"""
        return _libBornAgainDevice.vdouble1d_t_push_back(self, x)

    def front(self):
        r"""front(vdouble1d_t self) -> std::vector< double >::value_type const &"""
        return _libBornAgainDevice.vdouble1d_t_front(self)

    def back(self):
        r"""back(vdouble1d_t self) -> std::vector< double >::value_type const &"""
        return _libBornAgainDevice.vdouble1d_t_back(self)

    def assign(self, n, x):
        r"""assign(vdouble1d_t self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _libBornAgainDevice.vdouble1d_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vdouble1d_t self, std::vector< double >::size_type new_size)
        resize(vdouble1d_t self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _libBornAgainDevice.vdouble1d_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vdouble1d_t self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(vdouble1d_t self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _libBornAgainDevice.vdouble1d_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vdouble1d_t self, std::vector< double >::size_type n)"""
        return _libBornAgainDevice.vdouble1d_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainDevice.vdouble1d_t_capacity(self)
    __swig_destroy__ = _libBornAgainDevice.delete_vdouble1d_t

# Register vdouble1d_t in _libBornAgainDevice:
_libBornAgainDevice.vdouble1d_t_swigregister(vdouble1d_t)

class vdouble2d_t(object):
    r"""Proxy of C++ std::vector< std::vector< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vdouble2d_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.vdouble2d_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vdouble2d_t self) -> bool"""
        return _libBornAgainDevice.vdouble2d_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vdouble2d_t self) -> bool"""
        return _libBornAgainDevice.vdouble2d_t___bool__(self)

    def __len__(self):
        r"""__len__(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainDevice.vdouble2d_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> vdouble2d_t"""
        return _libBornAgainDevice.vdouble2d_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        __setslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, vdouble2d_t v)
        """
        return _libBornAgainDevice.vdouble2d_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _libBornAgainDevice.vdouble2d_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(vdouble2d_t self, PySliceObject * slice)
        """
        return _libBornAgainDevice.vdouble2d_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vdouble2d_t self, PySliceObject * slice) -> vdouble2d_t
        __getitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i) -> vdouble1d_t
        """
        return _libBornAgainDevice.vdouble2d_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vdouble2d_t self, PySliceObject * slice, vdouble2d_t v)
        __setitem__(vdouble2d_t self, PySliceObject * slice)
        __setitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, vdouble1d_t x)
        """
        return _libBornAgainDevice.vdouble2d_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainDevice.vdouble2d_t_pop(self)

    def append(self, x):
        r"""append(vdouble2d_t self, vdouble1d_t x)"""
        return _libBornAgainDevice.vdouble2d_t_append(self, x)

    def empty(self):
        r"""empty(vdouble2d_t self) -> bool"""
        return _libBornAgainDevice.vdouble2d_t_empty(self)

    def size(self):
        r"""size(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainDevice.vdouble2d_t_size(self)

    def swap(self, v):
        r"""swap(vdouble2d_t self, vdouble2d_t v)"""
        return _libBornAgainDevice.vdouble2d_t_swap(self, v)

    def begin(self):
        r"""begin(vdouble2d_t self) -> std::vector< std::vector< double > >::iterator"""
        return _libBornAgainDevice.vdouble2d_t_begin(self)

    def end(self):
        r"""end(vdouble2d_t self) -> std::vector< std::vector< double > >::iterator"""
        return _libBornAgainDevice.vdouble2d_t_end(self)

    def rbegin(self):
        r"""rbegin(vdouble2d_t self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _libBornAgainDevice.vdouble2d_t_rbegin(self)

    def rend(self):
        r"""rend(vdouble2d_t self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _libBornAgainDevice.vdouble2d_t_rend(self)

    def clear(self):
        r"""clear(vdouble2d_t self)"""
        return _libBornAgainDevice.vdouble2d_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vdouble2d_t self) -> std::vector< std::vector< double > >::allocator_type"""
        return _libBornAgainDevice.vdouble2d_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vdouble2d_t self)"""
        return _libBornAgainDevice.vdouble2d_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos) -> std::vector< std::vector< double > >::iterator
        erase(vdouble2d_t self, std::vector< std::vector< double > >::iterator first, std::vector< std::vector< double > >::iterator last) -> std::vector< std::vector< double > >::iterator
        """
        return _libBornAgainDevice.vdouble2d_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vdouble2d_t self) -> vdouble2d_t
        __init__(vdouble2d_t self, vdouble2d_t other) -> vdouble2d_t
        __init__(vdouble2d_t self, std::vector< std::vector< double > >::size_type size) -> vdouble2d_t
        __init__(vdouble2d_t self, std::vector< std::vector< double > >::size_type size, vdouble1d_t value) -> vdouble2d_t
        """
        _libBornAgainDevice.vdouble2d_t_swiginit(self, _libBornAgainDevice.new_vdouble2d_t(*args))

    def push_back(self, x):
        r"""push_back(vdouble2d_t self, vdouble1d_t x)"""
        return _libBornAgainDevice.vdouble2d_t_push_back(self, x)

    def front(self):
        r"""front(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainDevice.vdouble2d_t_front(self)

    def back(self):
        r"""back(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainDevice.vdouble2d_t_back(self)

    def assign(self, n, x):
        r"""assign(vdouble2d_t self, std::vector< std::vector< double > >::size_type n, vdouble1d_t x)"""
        return _libBornAgainDevice.vdouble2d_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vdouble2d_t self, std::vector< std::vector< double > >::size_type new_size)
        resize(vdouble2d_t self, std::vector< std::vector< double > >::size_type new_size, vdouble1d_t x)
        """
        return _libBornAgainDevice.vdouble2d_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos, vdouble1d_t x) -> std::vector< std::vector< double > >::iterator
        insert(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos, std::vector< std::vector< double > >::size_type n, vdouble1d_t x)
        """
        return _libBornAgainDevice.vdouble2d_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vdouble2d_t self, std::vector< std::vector< double > >::size_type n)"""
        return _libBornAgainDevice.vdouble2d_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainDevice.vdouble2d_t_capacity(self)
    __swig_destroy__ = _libBornAgainDevice.delete_vdouble2d_t

# Register vdouble2d_t in _libBornAgainDevice:
_libBornAgainDevice.vdouble2d_t_swigregister(vdouble2d_t)

class vector_integer_t(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_integer_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.vector_integer_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_integer_t self) -> bool"""
        return _libBornAgainDevice.vector_integer_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_integer_t self) -> bool"""
        return _libBornAgainDevice.vector_integer_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainDevice.vector_integer_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> vector_integer_t"""
        return _libBornAgainDevice.vector_integer_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, vector_integer_t v)
        """
        return _libBornAgainDevice.vector_integer_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _libBornAgainDevice.vector_integer_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_integer_t self, std::vector< int >::difference_type i)
        __delitem__(vector_integer_t self, PySliceObject * slice)
        """
        return _libBornAgainDevice.vector_integer_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_integer_t self, PySliceObject * slice) -> vector_integer_t
        __getitem__(vector_integer_t self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _libBornAgainDevice.vector_integer_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_integer_t self, PySliceObject * slice, vector_integer_t v)
        __setitem__(vector_integer_t self, PySliceObject * slice)
        __setitem__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _libBornAgainDevice.vector_integer_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_integer_t self) -> std::vector< int >::value_type"""
        return _libBornAgainDevice.vector_integer_t_pop(self)

    def append(self, x):
        r"""append(vector_integer_t self, std::vector< int >::value_type const & x)"""
        return _libBornAgainDevice.vector_integer_t_append(self, x)

    def empty(self):
        r"""empty(vector_integer_t self) -> bool"""
        return _libBornAgainDevice.vector_integer_t_empty(self)

    def size(self):
        r"""size(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainDevice.vector_integer_t_size(self)

    def swap(self, v):
        r"""swap(vector_integer_t self, vector_integer_t v)"""
        return _libBornAgainDevice.vector_integer_t_swap(self, v)

    def begin(self):
        r"""begin(vector_integer_t self) -> std::vector< int >::iterator"""
        return _libBornAgainDevice.vector_integer_t_begin(self)

    def end(self):
        r"""end(vector_integer_t self) -> std::vector< int >::iterator"""
        return _libBornAgainDevice.vector_integer_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_integer_t self) -> std::vector< int >::reverse_iterator"""
        return _libBornAgainDevice.vector_integer_t_rbegin(self)

    def rend(self):
        r"""rend(vector_integer_t self) -> std::vector< int >::reverse_iterator"""
        return _libBornAgainDevice.vector_integer_t_rend(self)

    def clear(self):
        r"""clear(vector_integer_t self)"""
        return _libBornAgainDevice.vector_integer_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_integer_t self) -> std::vector< int >::allocator_type"""
        return _libBornAgainDevice.vector_integer_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_integer_t self)"""
        return _libBornAgainDevice.vector_integer_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_integer_t self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(vector_integer_t self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _libBornAgainDevice.vector_integer_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_integer_t self) -> vector_integer_t
        __init__(vector_integer_t self, vector_integer_t other) -> vector_integer_t
        __init__(vector_integer_t self, std::vector< int >::size_type size) -> vector_integer_t
        __init__(vector_integer_t self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> vector_integer_t
        """
        _libBornAgainDevice.vector_integer_t_swiginit(self, _libBornAgainDevice.new_vector_integer_t(*args))

    def push_back(self, x):
        r"""push_back(vector_integer_t self, std::vector< int >::value_type const & x)"""
        return _libBornAgainDevice.vector_integer_t_push_back(self, x)

    def front(self):
        r"""front(vector_integer_t self) -> std::vector< int >::value_type const &"""
        return _libBornAgainDevice.vector_integer_t_front(self)

    def back(self):
        r"""back(vector_integer_t self) -> std::vector< int >::value_type const &"""
        return _libBornAgainDevice.vector_integer_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_integer_t self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _libBornAgainDevice.vector_integer_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_integer_t self, std::vector< int >::size_type new_size)
        resize(vector_integer_t self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _libBornAgainDevice.vector_integer_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_integer_t self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(vector_integer_t self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _libBornAgainDevice.vector_integer_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_integer_t self, std::vector< int >::size_type n)"""
        return _libBornAgainDevice.vector_integer_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainDevice.vector_integer_t_capacity(self)
    __swig_destroy__ = _libBornAgainDevice.delete_vector_integer_t

# Register vector_integer_t in _libBornAgainDevice:
_libBornAgainDevice.vector_integer_t_swigregister(vector_integer_t)

class vinteger2d_t(object):
    r"""Proxy of C++ std::vector< std::vector< int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vinteger2d_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.vinteger2d_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vinteger2d_t self) -> bool"""
        return _libBornAgainDevice.vinteger2d_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vinteger2d_t self) -> bool"""
        return _libBornAgainDevice.vinteger2d_t___bool__(self)

    def __len__(self):
        r"""__len__(vinteger2d_t self) -> std::vector< std::vector< int > >::size_type"""
        return _libBornAgainDevice.vinteger2d_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j) -> vinteger2d_t"""
        return _libBornAgainDevice.vinteger2d_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j)
        __setslice__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j, vinteger2d_t v)
        """
        return _libBornAgainDevice.vinteger2d_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j)"""
        return _libBornAgainDevice.vinteger2d_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i)
        __delitem__(vinteger2d_t self, PySliceObject * slice)
        """
        return _libBornAgainDevice.vinteger2d_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vinteger2d_t self, PySliceObject * slice) -> vinteger2d_t
        __getitem__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i) -> vector_integer_t
        """
        return _libBornAgainDevice.vinteger2d_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vinteger2d_t self, PySliceObject * slice, vinteger2d_t v)
        __setitem__(vinteger2d_t self, PySliceObject * slice)
        __setitem__(vinteger2d_t self, std::vector< std::vector< int > >::difference_type i, vector_integer_t x)
        """
        return _libBornAgainDevice.vinteger2d_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vinteger2d_t self) -> vector_integer_t"""
        return _libBornAgainDevice.vinteger2d_t_pop(self)

    def append(self, x):
        r"""append(vinteger2d_t self, vector_integer_t x)"""
        return _libBornAgainDevice.vinteger2d_t_append(self, x)

    def empty(self):
        r"""empty(vinteger2d_t self) -> bool"""
        return _libBornAgainDevice.vinteger2d_t_empty(self)

    def size(self):
        r"""size(vinteger2d_t self) -> std::vector< std::vector< int > >::size_type"""
        return _libBornAgainDevice.vinteger2d_t_size(self)

    def swap(self, v):
        r"""swap(vinteger2d_t self, vinteger2d_t v)"""
        return _libBornAgainDevice.vinteger2d_t_swap(self, v)

    def begin(self):
        r"""begin(vinteger2d_t self) -> std::vector< std::vector< int > >::iterator"""
        return _libBornAgainDevice.vinteger2d_t_begin(self)

    def end(self):
        r"""end(vinteger2d_t self) -> std::vector< std::vector< int > >::iterator"""
        return _libBornAgainDevice.vinteger2d_t_end(self)

    def rbegin(self):
        r"""rbegin(vinteger2d_t self) -> std::vector< std::vector< int > >::reverse_iterator"""
        return _libBornAgainDevice.vinteger2d_t_rbegin(self)

    def rend(self):
        r"""rend(vinteger2d_t self) -> std::vector< std::vector< int > >::reverse_iterator"""
        return _libBornAgainDevice.vinteger2d_t_rend(self)

    def clear(self):
        r"""clear(vinteger2d_t self)"""
        return _libBornAgainDevice.vinteger2d_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vinteger2d_t self) -> std::vector< std::vector< int > >::allocator_type"""
        return _libBornAgainDevice.vinteger2d_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vinteger2d_t self)"""
        return _libBornAgainDevice.vinteger2d_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vinteger2d_t self, std::vector< std::vector< int > >::iterator pos) -> std::vector< std::vector< int > >::iterator
        erase(vinteger2d_t self, std::vector< std::vector< int > >::iterator first, std::vector< std::vector< int > >::iterator last) -> std::vector< std::vector< int > >::iterator
        """
        return _libBornAgainDevice.vinteger2d_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vinteger2d_t self) -> vinteger2d_t
        __init__(vinteger2d_t self, vinteger2d_t other) -> vinteger2d_t
        __init__(vinteger2d_t self, std::vector< std::vector< int > >::size_type size) -> vinteger2d_t
        __init__(vinteger2d_t self, std::vector< std::vector< int > >::size_type size, vector_integer_t value) -> vinteger2d_t
        """
        _libBornAgainDevice.vinteger2d_t_swiginit(self, _libBornAgainDevice.new_vinteger2d_t(*args))

    def push_back(self, x):
        r"""push_back(vinteger2d_t self, vector_integer_t x)"""
        return _libBornAgainDevice.vinteger2d_t_push_back(self, x)

    def front(self):
        r"""front(vinteger2d_t self) -> vector_integer_t"""
        return _libBornAgainDevice.vinteger2d_t_front(self)

    def back(self):
        r"""back(vinteger2d_t self) -> vector_integer_t"""
        return _libBornAgainDevice.vinteger2d_t_back(self)

    def assign(self, n, x):
        r"""assign(vinteger2d_t self, std::vector< std::vector< int > >::size_type n, vector_integer_t x)"""
        return _libBornAgainDevice.vinteger2d_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vinteger2d_t self, std::vector< std::vector< int > >::size_type new_size)
        resize(vinteger2d_t self, std::vector< std::vector< int > >::size_type new_size, vector_integer_t x)
        """
        return _libBornAgainDevice.vinteger2d_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vinteger2d_t self, std::vector< std::vector< int > >::iterator pos, vector_integer_t x) -> std::vector< std::vector< int > >::iterator
        insert(vinteger2d_t self, std::vector< std::vector< int > >::iterator pos, std::vector< std::vector< int > >::size_type n, vector_integer_t x)
        """
        return _libBornAgainDevice.vinteger2d_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vinteger2d_t self, std::vector< std::vector< int > >::size_type n)"""
        return _libBornAgainDevice.vinteger2d_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vinteger2d_t self) -> std::vector< std::vector< int > >::size_type"""
        return _libBornAgainDevice.vinteger2d_t_capacity(self)
    __swig_destroy__ = _libBornAgainDevice.delete_vinteger2d_t

# Register vinteger2d_t in _libBornAgainDevice:
_libBornAgainDevice.vinteger2d_t_swigregister(vinteger2d_t)

class vector_longinteger_t(object):
    r"""Proxy of C++ std::vector< unsigned long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_longinteger_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.vector_longinteger_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_longinteger_t self) -> bool"""
        return _libBornAgainDevice.vector_longinteger_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_longinteger_t self) -> bool"""
        return _libBornAgainDevice.vector_longinteger_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainDevice.vector_longinteger_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> vector_longinteger_t"""
        return _libBornAgainDevice.vector_longinteger_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)
        __setslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, vector_longinteger_t v)
        """
        return _libBornAgainDevice.vector_longinteger_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)"""
        return _libBornAgainDevice.vector_longinteger_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i)
        __delitem__(vector_longinteger_t self, PySliceObject * slice)
        """
        return _libBornAgainDevice.vector_longinteger_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_longinteger_t self, PySliceObject * slice) -> vector_longinteger_t
        __getitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &
        """
        return _libBornAgainDevice.vector_longinteger_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_longinteger_t self, PySliceObject * slice, vector_longinteger_t v)
        __setitem__(vector_longinteger_t self, PySliceObject * slice)
        __setitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainDevice.vector_longinteger_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_longinteger_t self) -> std::vector< unsigned long >::value_type"""
        return _libBornAgainDevice.vector_longinteger_t_pop(self)

    def append(self, x):
        r"""append(vector_longinteger_t self, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainDevice.vector_longinteger_t_append(self, x)

    def empty(self):
        r"""empty(vector_longinteger_t self) -> bool"""
        return _libBornAgainDevice.vector_longinteger_t_empty(self)

    def size(self):
        r"""size(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainDevice.vector_longinteger_t_size(self)

    def swap(self, v):
        r"""swap(vector_longinteger_t self, vector_longinteger_t v)"""
        return _libBornAgainDevice.vector_longinteger_t_swap(self, v)

    def begin(self):
        r"""begin(vector_longinteger_t self) -> std::vector< unsigned long >::iterator"""
        return _libBornAgainDevice.vector_longinteger_t_begin(self)

    def end(self):
        r"""end(vector_longinteger_t self) -> std::vector< unsigned long >::iterator"""
        return _libBornAgainDevice.vector_longinteger_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_longinteger_t self) -> std::vector< unsigned long >::reverse_iterator"""
        return _libBornAgainDevice.vector_longinteger_t_rbegin(self)

    def rend(self):
        r"""rend(vector_longinteger_t self) -> std::vector< unsigned long >::reverse_iterator"""
        return _libBornAgainDevice.vector_longinteger_t_rend(self)

    def clear(self):
        r"""clear(vector_longinteger_t self)"""
        return _libBornAgainDevice.vector_longinteger_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_longinteger_t self) -> std::vector< unsigned long >::allocator_type"""
        return _libBornAgainDevice.vector_longinteger_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_longinteger_t self)"""
        return _libBornAgainDevice.vector_longinteger_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_longinteger_t self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(vector_longinteger_t self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator
        """
        return _libBornAgainDevice.vector_longinteger_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_longinteger_t self) -> vector_longinteger_t
        __init__(vector_longinteger_t self, vector_longinteger_t other) -> vector_longinteger_t
        __init__(vector_longinteger_t self, std::vector< unsigned long >::size_type size) -> vector_longinteger_t
        __init__(vector_longinteger_t self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> vector_longinteger_t
        """
        _libBornAgainDevice.vector_longinteger_t_swiginit(self, _libBornAgainDevice.new_vector_longinteger_t(*args))

    def push_back(self, x):
        r"""push_back(vector_longinteger_t self, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainDevice.vector_longinteger_t_push_back(self, x)

    def front(self):
        r"""front(vector_longinteger_t self) -> std::vector< unsigned long >::value_type const &"""
        return _libBornAgainDevice.vector_longinteger_t_front(self)

    def back(self):
        r"""back(vector_longinteger_t self) -> std::vector< unsigned long >::value_type const &"""
        return _libBornAgainDevice.vector_longinteger_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_longinteger_t self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainDevice.vector_longinteger_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_longinteger_t self, std::vector< unsigned long >::size_type new_size)
        resize(vector_longinteger_t self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainDevice.vector_longinteger_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_longinteger_t self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(vector_longinteger_t self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainDevice.vector_longinteger_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_longinteger_t self, std::vector< unsigned long >::size_type n)"""
        return _libBornAgainDevice.vector_longinteger_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainDevice.vector_longinteger_t_capacity(self)
    __swig_destroy__ = _libBornAgainDevice.delete_vector_longinteger_t

# Register vector_longinteger_t in _libBornAgainDevice:
_libBornAgainDevice.vector_longinteger_t_swigregister(vector_longinteger_t)

class vector_complex_t(object):
    r"""Proxy of C++ std::vector< std::complex< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_complex_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.vector_complex_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_complex_t self) -> bool"""
        return _libBornAgainDevice.vector_complex_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_complex_t self) -> bool"""
        return _libBornAgainDevice.vector_complex_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainDevice.vector_complex_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j) -> vector_complex_t"""
        return _libBornAgainDevice.vector_complex_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)
        __setslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j, vector_complex_t v)
        """
        return _libBornAgainDevice.vector_complex_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)"""
        return _libBornAgainDevice.vector_complex_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i)
        __delitem__(vector_complex_t self, PySliceObject * slice)
        """
        return _libBornAgainDevice.vector_complex_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_complex_t self, PySliceObject * slice) -> vector_complex_t
        __getitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i) -> std::vector< std::complex< double > >::value_type const &
        """
        return _libBornAgainDevice.vector_complex_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_complex_t self, PySliceObject * slice, vector_complex_t v)
        __setitem__(vector_complex_t self, PySliceObject * slice)
        __setitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainDevice.vector_complex_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_complex_t self) -> std::vector< std::complex< double > >::value_type"""
        return _libBornAgainDevice.vector_complex_t_pop(self)

    def append(self, x):
        r"""append(vector_complex_t self, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainDevice.vector_complex_t_append(self, x)

    def empty(self):
        r"""empty(vector_complex_t self) -> bool"""
        return _libBornAgainDevice.vector_complex_t_empty(self)

    def size(self):
        r"""size(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainDevice.vector_complex_t_size(self)

    def swap(self, v):
        r"""swap(vector_complex_t self, vector_complex_t v)"""
        return _libBornAgainDevice.vector_complex_t_swap(self, v)

    def begin(self):
        r"""begin(vector_complex_t self) -> std::vector< std::complex< double > >::iterator"""
        return _libBornAgainDevice.vector_complex_t_begin(self)

    def end(self):
        r"""end(vector_complex_t self) -> std::vector< std::complex< double > >::iterator"""
        return _libBornAgainDevice.vector_complex_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_complex_t self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _libBornAgainDevice.vector_complex_t_rbegin(self)

    def rend(self):
        r"""rend(vector_complex_t self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _libBornAgainDevice.vector_complex_t_rend(self)

    def clear(self):
        r"""clear(vector_complex_t self)"""
        return _libBornAgainDevice.vector_complex_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_complex_t self) -> std::vector< std::complex< double > >::allocator_type"""
        return _libBornAgainDevice.vector_complex_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_complex_t self)"""
        return _libBornAgainDevice.vector_complex_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_complex_t self, std::vector< std::complex< double > >::iterator pos) -> std::vector< std::complex< double > >::iterator
        erase(vector_complex_t self, std::vector< std::complex< double > >::iterator first, std::vector< std::complex< double > >::iterator last) -> std::vector< std::complex< double > >::iterator
        """
        return _libBornAgainDevice.vector_complex_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_complex_t self) -> vector_complex_t
        __init__(vector_complex_t self, vector_complex_t other) -> vector_complex_t
        __init__(vector_complex_t self, std::vector< std::complex< double > >::size_type size) -> vector_complex_t
        __init__(vector_complex_t self, std::vector< std::complex< double > >::size_type size, std::vector< std::complex< double > >::value_type const & value) -> vector_complex_t
        """
        _libBornAgainDevice.vector_complex_t_swiginit(self, _libBornAgainDevice.new_vector_complex_t(*args))

    def push_back(self, x):
        r"""push_back(vector_complex_t self, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainDevice.vector_complex_t_push_back(self, x)

    def front(self):
        r"""front(vector_complex_t self) -> std::vector< std::complex< double > >::value_type const &"""
        return _libBornAgainDevice.vector_complex_t_front(self)

    def back(self):
        r"""back(vector_complex_t self) -> std::vector< std::complex< double > >::value_type const &"""
        return _libBornAgainDevice.vector_complex_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_complex_t self, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainDevice.vector_complex_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_complex_t self, std::vector< std::complex< double > >::size_type new_size)
        resize(vector_complex_t self, std::vector< std::complex< double > >::size_type new_size, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainDevice.vector_complex_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_complex_t self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::value_type const & x) -> std::vector< std::complex< double > >::iterator
        insert(vector_complex_t self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainDevice.vector_complex_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_complex_t self, std::vector< std::complex< double > >::size_type n)"""
        return _libBornAgainDevice.vector_complex_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainDevice.vector_complex_t_capacity(self)
    __swig_destroy__ = _libBornAgainDevice.delete_vector_complex_t

# Register vector_complex_t in _libBornAgainDevice:
_libBornAgainDevice.vector_complex_t_swigregister(vector_complex_t)

class vector_string_t(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_string_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.vector_string_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_string_t self) -> bool"""
        return _libBornAgainDevice.vector_string_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_string_t self) -> bool"""
        return _libBornAgainDevice.vector_string_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainDevice.vector_string_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> vector_string_t"""
        return _libBornAgainDevice.vector_string_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, vector_string_t v)
        """
        return _libBornAgainDevice.vector_string_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _libBornAgainDevice.vector_string_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_string_t self, std::vector< std::string >::difference_type i)
        __delitem__(vector_string_t self, PySliceObject * slice)
        """
        return _libBornAgainDevice.vector_string_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_string_t self, PySliceObject * slice) -> vector_string_t
        __getitem__(vector_string_t self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _libBornAgainDevice.vector_string_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_string_t self, PySliceObject * slice, vector_string_t v)
        __setitem__(vector_string_t self, PySliceObject * slice)
        __setitem__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainDevice.vector_string_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_string_t self) -> std::vector< std::string >::value_type"""
        return _libBornAgainDevice.vector_string_t_pop(self)

    def append(self, x):
        r"""append(vector_string_t self, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainDevice.vector_string_t_append(self, x)

    def empty(self):
        r"""empty(vector_string_t self) -> bool"""
        return _libBornAgainDevice.vector_string_t_empty(self)

    def size(self):
        r"""size(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainDevice.vector_string_t_size(self)

    def swap(self, v):
        r"""swap(vector_string_t self, vector_string_t v)"""
        return _libBornAgainDevice.vector_string_t_swap(self, v)

    def begin(self):
        r"""begin(vector_string_t self) -> std::vector< std::string >::iterator"""
        return _libBornAgainDevice.vector_string_t_begin(self)

    def end(self):
        r"""end(vector_string_t self) -> std::vector< std::string >::iterator"""
        return _libBornAgainDevice.vector_string_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_string_t self) -> std::vector< std::string >::reverse_iterator"""
        return _libBornAgainDevice.vector_string_t_rbegin(self)

    def rend(self):
        r"""rend(vector_string_t self) -> std::vector< std::string >::reverse_iterator"""
        return _libBornAgainDevice.vector_string_t_rend(self)

    def clear(self):
        r"""clear(vector_string_t self)"""
        return _libBornAgainDevice.vector_string_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_string_t self) -> std::vector< std::string >::allocator_type"""
        return _libBornAgainDevice.vector_string_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_string_t self)"""
        return _libBornAgainDevice.vector_string_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_string_t self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(vector_string_t self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _libBornAgainDevice.vector_string_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_string_t self) -> vector_string_t
        __init__(vector_string_t self, vector_string_t other) -> vector_string_t
        __init__(vector_string_t self, std::vector< std::string >::size_type size) -> vector_string_t
        __init__(vector_string_t self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vector_string_t
        """
        _libBornAgainDevice.vector_string_t_swiginit(self, _libBornAgainDevice.new_vector_string_t(*args))

    def push_back(self, x):
        r"""push_back(vector_string_t self, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainDevice.vector_string_t_push_back(self, x)

    def front(self):
        r"""front(vector_string_t self) -> std::vector< std::string >::value_type const &"""
        return _libBornAgainDevice.vector_string_t_front(self)

    def back(self):
        r"""back(vector_string_t self) -> std::vector< std::string >::value_type const &"""
        return _libBornAgainDevice.vector_string_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_string_t self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainDevice.vector_string_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_string_t self, std::vector< std::string >::size_type new_size)
        resize(vector_string_t self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainDevice.vector_string_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_string_t self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(vector_string_t self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainDevice.vector_string_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_string_t self, std::vector< std::string >::size_type n)"""
        return _libBornAgainDevice.vector_string_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainDevice.vector_string_t_capacity(self)
    __swig_destroy__ = _libBornAgainDevice.delete_vector_string_t

# Register vector_string_t in _libBornAgainDevice:
_libBornAgainDevice.vector_string_t_swigregister(vector_string_t)

class map_string_double_t(object):
    r"""Proxy of C++ std::map< std::string,double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(map_string_double_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.map_string_double_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(map_string_double_t self) -> bool"""
        return _libBornAgainDevice.map_string_double_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(map_string_double_t self) -> bool"""
        return _libBornAgainDevice.map_string_double_t___bool__(self)

    def __len__(self):
        r"""__len__(map_string_double_t self) -> std::map< std::string,double >::size_type"""
        return _libBornAgainDevice.map_string_double_t___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""__getitem__(map_string_double_t self, std::map< std::string,double >::key_type const & key) -> std::map< std::string,double >::mapped_type const &"""
        return _libBornAgainDevice.map_string_double_t___getitem__(self, key)

    def __delitem__(self, key):
        r"""__delitem__(map_string_double_t self, std::map< std::string,double >::key_type const & key)"""
        return _libBornAgainDevice.map_string_double_t___delitem__(self, key)

    def has_key(self, key):
        r"""has_key(map_string_double_t self, std::map< std::string,double >::key_type const & key) -> bool"""
        return _libBornAgainDevice.map_string_double_t_has_key(self, key)

    def keys(self):
        r"""keys(map_string_double_t self) -> PyObject *"""
        return _libBornAgainDevice.map_string_double_t_keys(self)

    def values(self):
        r"""values(map_string_double_t self) -> PyObject *"""
        return _libBornAgainDevice.map_string_double_t_values(self)

    def items(self):
        r"""items(map_string_double_t self) -> PyObject *"""
        return _libBornAgainDevice.map_string_double_t_items(self)

    def __contains__(self, key):
        r"""__contains__(map_string_double_t self, std::map< std::string,double >::key_type const & key) -> bool"""
        return _libBornAgainDevice.map_string_double_t___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(map_string_double_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.map_string_double_t_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(map_string_double_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.map_string_double_t_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(map_string_double_t self, std::map< std::string,double >::key_type const & key)
        __setitem__(map_string_double_t self, std::map< std::string,double >::key_type const & key, std::map< std::string,double >::mapped_type const & x)
        """
        return _libBornAgainDevice.map_string_double_t___setitem__(self, *args)

    def asdict(self):
        r"""asdict(map_string_double_t self) -> PyObject *"""
        return _libBornAgainDevice.map_string_double_t_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(map_string_double_t self, std::less< std::string > const & other) -> map_string_double_t
        __init__(map_string_double_t self) -> map_string_double_t
        __init__(map_string_double_t self, map_string_double_t other) -> map_string_double_t
        """
        _libBornAgainDevice.map_string_double_t_swiginit(self, _libBornAgainDevice.new_map_string_double_t(*args))

    def empty(self):
        r"""empty(map_string_double_t self) -> bool"""
        return _libBornAgainDevice.map_string_double_t_empty(self)

    def size(self):
        r"""size(map_string_double_t self) -> std::map< std::string,double >::size_type"""
        return _libBornAgainDevice.map_string_double_t_size(self)

    def swap(self, v):
        r"""swap(map_string_double_t self, map_string_double_t v)"""
        return _libBornAgainDevice.map_string_double_t_swap(self, v)

    def begin(self):
        r"""begin(map_string_double_t self) -> std::map< std::string,double >::iterator"""
        return _libBornAgainDevice.map_string_double_t_begin(self)

    def end(self):
        r"""end(map_string_double_t self) -> std::map< std::string,double >::iterator"""
        return _libBornAgainDevice.map_string_double_t_end(self)

    def rbegin(self):
        r"""rbegin(map_string_double_t self) -> std::map< std::string,double >::reverse_iterator"""
        return _libBornAgainDevice.map_string_double_t_rbegin(self)

    def rend(self):
        r"""rend(map_string_double_t self) -> std::map< std::string,double >::reverse_iterator"""
        return _libBornAgainDevice.map_string_double_t_rend(self)

    def clear(self):
        r"""clear(map_string_double_t self)"""
        return _libBornAgainDevice.map_string_double_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(map_string_double_t self) -> std::map< std::string,double >::allocator_type"""
        return _libBornAgainDevice.map_string_double_t_get_allocator(self)

    def count(self, x):
        r"""count(map_string_double_t self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::size_type"""
        return _libBornAgainDevice.map_string_double_t_count(self, x)

    def erase(self, *args):
        r"""
        erase(map_string_double_t self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::size_type
        erase(map_string_double_t self, std::map< std::string,double >::iterator position)
        erase(map_string_double_t self, std::map< std::string,double >::iterator first, std::map< std::string,double >::iterator last)
        """
        return _libBornAgainDevice.map_string_double_t_erase(self, *args)

    def find(self, x):
        r"""find(map_string_double_t self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _libBornAgainDevice.map_string_double_t_find(self, x)

    def lower_bound(self, x):
        r"""lower_bound(map_string_double_t self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _libBornAgainDevice.map_string_double_t_lower_bound(self, x)

    def upper_bound(self, x):
        r"""upper_bound(map_string_double_t self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _libBornAgainDevice.map_string_double_t_upper_bound(self, x)
    __swig_destroy__ = _libBornAgainDevice.delete_map_string_double_t

# Register map_string_double_t in _libBornAgainDevice:
_libBornAgainDevice.map_string_double_t_swigregister(map_string_double_t)

class pvacuum_double_t(object):
    r"""Proxy of C++ std::pair< double,double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(pvacuum_double_t self) -> pvacuum_double_t
        __init__(pvacuum_double_t self, double first, double second) -> pvacuum_double_t
        __init__(pvacuum_double_t self, pvacuum_double_t other) -> pvacuum_double_t
        """
        _libBornAgainDevice.pvacuum_double_t_swiginit(self, _libBornAgainDevice.new_pvacuum_double_t(*args))
    first = property(_libBornAgainDevice.pvacuum_double_t_first_get, _libBornAgainDevice.pvacuum_double_t_first_set, doc=r"""first : double""")
    second = property(_libBornAgainDevice.pvacuum_double_t_second_get, _libBornAgainDevice.pvacuum_double_t_second_set, doc=r"""second : double""")
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libBornAgainDevice.delete_pvacuum_double_t

# Register pvacuum_double_t in _libBornAgainDevice:
_libBornAgainDevice.pvacuum_double_t_swigregister(pvacuum_double_t)

class vector_pvacuum_double_t(object):
    r"""Proxy of C++ std::vector< std::pair< double,double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_pvacuum_double_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.vector_pvacuum_double_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_pvacuum_double_t self) -> bool"""
        return _libBornAgainDevice.vector_pvacuum_double_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_pvacuum_double_t self) -> bool"""
        return _libBornAgainDevice.vector_pvacuum_double_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::size_type"""
        return _libBornAgainDevice.vector_pvacuum_double_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i, std::vector< std::pair< double,double > >::difference_type j) -> vector_pvacuum_double_t"""
        return _libBornAgainDevice.vector_pvacuum_double_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i, std::vector< std::pair< double,double > >::difference_type j)
        __setslice__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i, std::vector< std::pair< double,double > >::difference_type j, vector_pvacuum_double_t v)
        """
        return _libBornAgainDevice.vector_pvacuum_double_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i, std::vector< std::pair< double,double > >::difference_type j)"""
        return _libBornAgainDevice.vector_pvacuum_double_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i)
        __delitem__(vector_pvacuum_double_t self, PySliceObject * slice)
        """
        return _libBornAgainDevice.vector_pvacuum_double_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_pvacuum_double_t self, PySliceObject * slice) -> vector_pvacuum_double_t
        __getitem__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i) -> pvacuum_double_t
        """
        return _libBornAgainDevice.vector_pvacuum_double_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_pvacuum_double_t self, PySliceObject * slice, vector_pvacuum_double_t v)
        __setitem__(vector_pvacuum_double_t self, PySliceObject * slice)
        __setitem__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::difference_type i, pvacuum_double_t x)
        """
        return _libBornAgainDevice.vector_pvacuum_double_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_pvacuum_double_t self) -> pvacuum_double_t"""
        return _libBornAgainDevice.vector_pvacuum_double_t_pop(self)

    def append(self, x):
        r"""append(vector_pvacuum_double_t self, pvacuum_double_t x)"""
        return _libBornAgainDevice.vector_pvacuum_double_t_append(self, x)

    def empty(self):
        r"""empty(vector_pvacuum_double_t self) -> bool"""
        return _libBornAgainDevice.vector_pvacuum_double_t_empty(self)

    def size(self):
        r"""size(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::size_type"""
        return _libBornAgainDevice.vector_pvacuum_double_t_size(self)

    def swap(self, v):
        r"""swap(vector_pvacuum_double_t self, vector_pvacuum_double_t v)"""
        return _libBornAgainDevice.vector_pvacuum_double_t_swap(self, v)

    def begin(self):
        r"""begin(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::iterator"""
        return _libBornAgainDevice.vector_pvacuum_double_t_begin(self)

    def end(self):
        r"""end(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::iterator"""
        return _libBornAgainDevice.vector_pvacuum_double_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::reverse_iterator"""
        return _libBornAgainDevice.vector_pvacuum_double_t_rbegin(self)

    def rend(self):
        r"""rend(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::reverse_iterator"""
        return _libBornAgainDevice.vector_pvacuum_double_t_rend(self)

    def clear(self):
        r"""clear(vector_pvacuum_double_t self)"""
        return _libBornAgainDevice.vector_pvacuum_double_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::allocator_type"""
        return _libBornAgainDevice.vector_pvacuum_double_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_pvacuum_double_t self)"""
        return _libBornAgainDevice.vector_pvacuum_double_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::iterator pos) -> std::vector< std::pair< double,double > >::iterator
        erase(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::iterator first, std::vector< std::pair< double,double > >::iterator last) -> std::vector< std::pair< double,double > >::iterator
        """
        return _libBornAgainDevice.vector_pvacuum_double_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_pvacuum_double_t self) -> vector_pvacuum_double_t
        __init__(vector_pvacuum_double_t self, vector_pvacuum_double_t other) -> vector_pvacuum_double_t
        __init__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type size) -> vector_pvacuum_double_t
        __init__(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type size, pvacuum_double_t value) -> vector_pvacuum_double_t
        """
        _libBornAgainDevice.vector_pvacuum_double_t_swiginit(self, _libBornAgainDevice.new_vector_pvacuum_double_t(*args))

    def push_back(self, x):
        r"""push_back(vector_pvacuum_double_t self, pvacuum_double_t x)"""
        return _libBornAgainDevice.vector_pvacuum_double_t_push_back(self, x)

    def front(self):
        r"""front(vector_pvacuum_double_t self) -> pvacuum_double_t"""
        return _libBornAgainDevice.vector_pvacuum_double_t_front(self)

    def back(self):
        r"""back(vector_pvacuum_double_t self) -> pvacuum_double_t"""
        return _libBornAgainDevice.vector_pvacuum_double_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type n, pvacuum_double_t x)"""
        return _libBornAgainDevice.vector_pvacuum_double_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type new_size)
        resize(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type new_size, pvacuum_double_t x)
        """
        return _libBornAgainDevice.vector_pvacuum_double_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::iterator pos, pvacuum_double_t x) -> std::vector< std::pair< double,double > >::iterator
        insert(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::iterator pos, std::vector< std::pair< double,double > >::size_type n, pvacuum_double_t x)
        """
        return _libBornAgainDevice.vector_pvacuum_double_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_pvacuum_double_t self, std::vector< std::pair< double,double > >::size_type n)"""
        return _libBornAgainDevice.vector_pvacuum_double_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_pvacuum_double_t self) -> std::vector< std::pair< double,double > >::size_type"""
        return _libBornAgainDevice.vector_pvacuum_double_t_capacity(self)
    __swig_destroy__ = _libBornAgainDevice.delete_vector_pvacuum_double_t

# Register vector_pvacuum_double_t in _libBornAgainDevice:
_libBornAgainDevice.vector_pvacuum_double_t_swigregister(vector_pvacuum_double_t)

import libBornAgainFit
import libBornAgainBase
class kvector_t(object):
    r"""Proxy of C++ BasicVector3D< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(kvector_t self) -> kvector_t
        __init__(kvector_t self, double const x1, double const y1, double const z1) -> kvector_t
        """
        _libBornAgainDevice.kvector_t_swiginit(self, _libBornAgainDevice.new_kvector_t(*args))

    def x(self):
        r"""x(kvector_t self) -> double"""
        return _libBornAgainDevice.kvector_t_x(self)

    def y(self):
        r"""y(kvector_t self) -> double"""
        return _libBornAgainDevice.kvector_t_y(self)

    def z(self):
        r"""z(kvector_t self) -> double"""
        return _libBornAgainDevice.kvector_t_z(self)

    def setX(self, a):
        r"""setX(kvector_t self, double const & a)"""
        return _libBornAgainDevice.kvector_t_setX(self, a)

    def setY(self, a):
        r"""setY(kvector_t self, double const & a)"""
        return _libBornAgainDevice.kvector_t_setY(self, a)

    def setZ(self, a):
        r"""setZ(kvector_t self, double const & a)"""
        return _libBornAgainDevice.kvector_t_setZ(self, a)

    def __iadd__(self, v):
        r"""__iadd__(kvector_t self, kvector_t v) -> kvector_t"""
        return _libBornAgainDevice.kvector_t___iadd__(self, v)

    def __isub__(self, v):
        r"""__isub__(kvector_t self, kvector_t v) -> kvector_t"""
        return _libBornAgainDevice.kvector_t___isub__(self, v)

    def conj(self):
        r"""conj(kvector_t self) -> kvector_t"""
        return _libBornAgainDevice.kvector_t_conj(self)

    def mag2(self):
        r"""mag2(kvector_t self) -> double"""
        return _libBornAgainDevice.kvector_t_mag2(self)

    def mag(self):
        r"""mag(kvector_t self) -> double"""
        return _libBornAgainDevice.kvector_t_mag(self)

    def magxy2(self):
        r"""magxy2(kvector_t self) -> double"""
        return _libBornAgainDevice.kvector_t_magxy2(self)

    def magxy(self):
        r"""magxy(kvector_t self) -> double"""
        return _libBornAgainDevice.kvector_t_magxy(self)

    def phi(self):
        r"""phi(kvector_t self) -> double"""
        return _libBornAgainDevice.kvector_t_phi(self)

    def theta(self):
        r"""theta(kvector_t self) -> double"""
        return _libBornAgainDevice.kvector_t_theta(self)

    def cosTheta(self):
        r"""cosTheta(kvector_t self) -> double"""
        return _libBornAgainDevice.kvector_t_cosTheta(self)

    def sin2Theta(self):
        r"""sin2Theta(kvector_t self) -> double"""
        return _libBornAgainDevice.kvector_t_sin2Theta(self)

    def unit(self):
        r"""unit(kvector_t self) -> kvector_t"""
        return _libBornAgainDevice.kvector_t_unit(self)

    def complex(self):
        r"""complex(kvector_t self) -> cvector_t"""
        return _libBornAgainDevice.kvector_t_complex(self)

    def real(self):
        r"""real(kvector_t self) -> kvector_t"""
        return _libBornAgainDevice.kvector_t_real(self)

    def angle(self, v):
        r"""angle(kvector_t self, kvector_t v) -> double"""
        return _libBornAgainDevice.kvector_t_angle(self, v)

    def project(self, v):
        r"""project(kvector_t self, kvector_t v) -> kvector_t"""
        return _libBornAgainDevice.kvector_t_project(self, v)
    __swig_destroy__ = _libBornAgainDevice.delete_kvector_t

# Register kvector_t in _libBornAgainDevice:
_libBornAgainDevice.kvector_t_swigregister(kvector_t)

class vector_kvector_t(object):
    r"""Proxy of C++ std::vector< BasicVector3D< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_kvector_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.vector_kvector_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_kvector_t self) -> bool"""
        return _libBornAgainDevice.vector_kvector_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_kvector_t self) -> bool"""
        return _libBornAgainDevice.vector_kvector_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::size_type"""
        return _libBornAgainDevice.vector_kvector_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j) -> vector_kvector_t"""
        return _libBornAgainDevice.vector_kvector_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j)
        __setslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j, vector_kvector_t v)
        """
        return _libBornAgainDevice.vector_kvector_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j)"""
        return _libBornAgainDevice.vector_kvector_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i)
        __delitem__(vector_kvector_t self, PySliceObject * slice)
        """
        return _libBornAgainDevice.vector_kvector_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_kvector_t self, PySliceObject * slice) -> vector_kvector_t
        __getitem__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i) -> kvector_t
        """
        return _libBornAgainDevice.vector_kvector_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_kvector_t self, PySliceObject * slice, vector_kvector_t v)
        __setitem__(vector_kvector_t self, PySliceObject * slice)
        __setitem__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, kvector_t x)
        """
        return _libBornAgainDevice.vector_kvector_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_kvector_t self) -> kvector_t"""
        return _libBornAgainDevice.vector_kvector_t_pop(self)

    def append(self, x):
        r"""append(vector_kvector_t self, kvector_t x)"""
        return _libBornAgainDevice.vector_kvector_t_append(self, x)

    def empty(self):
        r"""empty(vector_kvector_t self) -> bool"""
        return _libBornAgainDevice.vector_kvector_t_empty(self)

    def size(self):
        r"""size(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::size_type"""
        return _libBornAgainDevice.vector_kvector_t_size(self)

    def swap(self, v):
        r"""
        swap(vector_kvector_t self, vector_kvector_t v)
        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainDevice.vector_kvector_t_swap(self, v)

    def begin(self):
        r"""begin(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::iterator"""
        return _libBornAgainDevice.vector_kvector_t_begin(self)

    def end(self):
        r"""end(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::iterator"""
        return _libBornAgainDevice.vector_kvector_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::reverse_iterator"""
        return _libBornAgainDevice.vector_kvector_t_rbegin(self)

    def rend(self):
        r"""rend(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::reverse_iterator"""
        return _libBornAgainDevice.vector_kvector_t_rend(self)

    def clear(self):
        r"""clear(vector_kvector_t self)"""
        return _libBornAgainDevice.vector_kvector_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::allocator_type"""
        return _libBornAgainDevice.vector_kvector_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_kvector_t self)"""
        return _libBornAgainDevice.vector_kvector_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator pos) -> std::vector< BasicVector3D< double > >::iterator
        erase(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator first, std::vector< BasicVector3D< double > >::iterator last) -> std::vector< BasicVector3D< double > >::iterator
        """
        return _libBornAgainDevice.vector_kvector_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_kvector_t self) -> vector_kvector_t
        __init__(vector_kvector_t self, vector_kvector_t other) -> vector_kvector_t
        __init__(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type size) -> vector_kvector_t
        __init__(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type size, kvector_t value) -> vector_kvector_t
        """
        _libBornAgainDevice.vector_kvector_t_swiginit(self, _libBornAgainDevice.new_vector_kvector_t(*args))

    def push_back(self, x):
        r"""push_back(vector_kvector_t self, kvector_t x)"""
        return _libBornAgainDevice.vector_kvector_t_push_back(self, x)

    def front(self):
        r"""front(vector_kvector_t self) -> kvector_t"""
        return _libBornAgainDevice.vector_kvector_t_front(self)

    def back(self):
        r"""back(vector_kvector_t self) -> kvector_t"""
        return _libBornAgainDevice.vector_kvector_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type n, kvector_t x)"""
        return _libBornAgainDevice.vector_kvector_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type new_size)
        resize(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type new_size, kvector_t x)
        """
        return _libBornAgainDevice.vector_kvector_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator pos, kvector_t x) -> std::vector< BasicVector3D< double > >::iterator
        insert(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator pos, std::vector< BasicVector3D< double > >::size_type n, kvector_t x)
        """
        return _libBornAgainDevice.vector_kvector_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type n)"""
        return _libBornAgainDevice.vector_kvector_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::size_type"""
        return _libBornAgainDevice.vector_kvector_t_capacity(self)
    __swig_destroy__ = _libBornAgainDevice.delete_vector_kvector_t

# Register vector_kvector_t in _libBornAgainDevice:
_libBornAgainDevice.vector_kvector_t_swigregister(vector_kvector_t)

class cvector_t(object):
    r"""Proxy of C++ BasicVector3D< std::complex< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(cvector_t self) -> cvector_t
        __init__(cvector_t self, std::complex< double > const x1, std::complex< double > const y1, std::complex< double > const z1) -> cvector_t
        """
        _libBornAgainDevice.cvector_t_swiginit(self, _libBornAgainDevice.new_cvector_t(*args))

    def x(self):
        r"""x(cvector_t self) -> std::complex< double >"""
        return _libBornAgainDevice.cvector_t_x(self)

    def y(self):
        r"""y(cvector_t self) -> std::complex< double >"""
        return _libBornAgainDevice.cvector_t_y(self)

    def z(self):
        r"""z(cvector_t self) -> std::complex< double >"""
        return _libBornAgainDevice.cvector_t_z(self)

    def setX(self, a):
        r"""setX(cvector_t self, std::complex< double > const & a)"""
        return _libBornAgainDevice.cvector_t_setX(self, a)

    def setY(self, a):
        r"""setY(cvector_t self, std::complex< double > const & a)"""
        return _libBornAgainDevice.cvector_t_setY(self, a)

    def setZ(self, a):
        r"""setZ(cvector_t self, std::complex< double > const & a)"""
        return _libBornAgainDevice.cvector_t_setZ(self, a)

    def __iadd__(self, v):
        r"""__iadd__(cvector_t self, cvector_t v) -> cvector_t"""
        return _libBornAgainDevice.cvector_t___iadd__(self, v)

    def __isub__(self, v):
        r"""__isub__(cvector_t self, cvector_t v) -> cvector_t"""
        return _libBornAgainDevice.cvector_t___isub__(self, v)

    def conj(self):
        r"""conj(cvector_t self) -> cvector_t"""
        return _libBornAgainDevice.cvector_t_conj(self)

    def mag2(self):
        r"""mag2(cvector_t self) -> double"""
        return _libBornAgainDevice.cvector_t_mag2(self)

    def mag(self):
        r"""mag(cvector_t self) -> double"""
        return _libBornAgainDevice.cvector_t_mag(self)

    def magxy2(self):
        r"""magxy2(cvector_t self) -> double"""
        return _libBornAgainDevice.cvector_t_magxy2(self)

    def magxy(self):
        r"""magxy(cvector_t self) -> double"""
        return _libBornAgainDevice.cvector_t_magxy(self)

    def unit(self):
        r"""unit(cvector_t self) -> cvector_t"""
        return _libBornAgainDevice.cvector_t_unit(self)

    def real(self):
        r"""real(cvector_t self) -> kvector_t"""
        return _libBornAgainDevice.cvector_t_real(self)

    def project(self, v):
        r"""project(cvector_t self, cvector_t v) -> cvector_t"""
        return _libBornAgainDevice.cvector_t_project(self, v)
    __swig_destroy__ = _libBornAgainDevice.delete_cvector_t

# Register cvector_t in _libBornAgainDevice:
_libBornAgainDevice.cvector_t_swigregister(cvector_t)

class vector_cvector_t(object):
    r"""Proxy of C++ std::vector< BasicVector3D< std::complex< double > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_cvector_t self) -> SwigPyIterator"""
        return _libBornAgainDevice.vector_cvector_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_cvector_t self) -> bool"""
        return _libBornAgainDevice.vector_cvector_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_cvector_t self) -> bool"""
        return _libBornAgainDevice.vector_cvector_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::size_type"""
        return _libBornAgainDevice.vector_cvector_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j) -> vector_cvector_t"""
        return _libBornAgainDevice.vector_cvector_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j)
        __setslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j, vector_cvector_t v)
        """
        return _libBornAgainDevice.vector_cvector_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j)"""
        return _libBornAgainDevice.vector_cvector_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i)
        __delitem__(vector_cvector_t self, PySliceObject * slice)
        """
        return _libBornAgainDevice.vector_cvector_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_cvector_t self, PySliceObject * slice) -> vector_cvector_t
        __getitem__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i) -> cvector_t
        """
        return _libBornAgainDevice.vector_cvector_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_cvector_t self, PySliceObject * slice, vector_cvector_t v)
        __setitem__(vector_cvector_t self, PySliceObject * slice)
        __setitem__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, cvector_t x)
        """
        return _libBornAgainDevice.vector_cvector_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_cvector_t self) -> cvector_t"""
        return _libBornAgainDevice.vector_cvector_t_pop(self)

    def append(self, x):
        r"""append(vector_cvector_t self, cvector_t x)"""
        return _libBornAgainDevice.vector_cvector_t_append(self, x)

    def empty(self):
        r"""empty(vector_cvector_t self) -> bool"""
        return _libBornAgainDevice.vector_cvector_t_empty(self)

    def size(self):
        r"""size(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::size_type"""
        return _libBornAgainDevice.vector_cvector_t_size(self)

    def swap(self, v):
        r"""
        swap(vector_cvector_t self, vector_cvector_t v)
        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainDevice.vector_cvector_t_swap(self, v)

    def begin(self):
        r"""begin(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::iterator"""
        return _libBornAgainDevice.vector_cvector_t_begin(self)

    def end(self):
        r"""end(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::iterator"""
        return _libBornAgainDevice.vector_cvector_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::reverse_iterator"""
        return _libBornAgainDevice.vector_cvector_t_rbegin(self)

    def rend(self):
        r"""rend(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::reverse_iterator"""
        return _libBornAgainDevice.vector_cvector_t_rend(self)

    def clear(self):
        r"""clear(vector_cvector_t self)"""
        return _libBornAgainDevice.vector_cvector_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::allocator_type"""
        return _libBornAgainDevice.vector_cvector_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_cvector_t self)"""
        return _libBornAgainDevice.vector_cvector_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator pos) -> std::vector< BasicVector3D< std::complex< double > > >::iterator
        erase(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator first, std::vector< BasicVector3D< std::complex< double > > >::iterator last) -> std::vector< BasicVector3D< std::complex< double > > >::iterator
        """
        return _libBornAgainDevice.vector_cvector_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_cvector_t self) -> vector_cvector_t
        __init__(vector_cvector_t self, vector_cvector_t other) -> vector_cvector_t
        __init__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type size) -> vector_cvector_t
        __init__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type size, cvector_t value) -> vector_cvector_t
        """
        _libBornAgainDevice.vector_cvector_t_swiginit(self, _libBornAgainDevice.new_vector_cvector_t(*args))

    def push_back(self, x):
        r"""push_back(vector_cvector_t self, cvector_t x)"""
        return _libBornAgainDevice.vector_cvector_t_push_back(self, x)

    def front(self):
        r"""front(vector_cvector_t self) -> cvector_t"""
        return _libBornAgainDevice.vector_cvector_t_front(self)

    def back(self):
        r"""back(vector_cvector_t self) -> cvector_t"""
        return _libBornAgainDevice.vector_cvector_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type n, cvector_t x)"""
        return _libBornAgainDevice.vector_cvector_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type new_size)
        resize(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type new_size, cvector_t x)
        """
        return _libBornAgainDevice.vector_cvector_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator pos, cvector_t x) -> std::vector< BasicVector3D< std::complex< double > > >::iterator
        insert(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator pos, std::vector< BasicVector3D< std::complex< double > > >::size_type n, cvector_t x)
        """
        return _libBornAgainDevice.vector_cvector_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type n)"""
        return _libBornAgainDevice.vector_cvector_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::size_type"""
        return _libBornAgainDevice.vector_cvector_t_capacity(self)
    __swig_destroy__ = _libBornAgainDevice.delete_vector_cvector_t

# Register vector_cvector_t in _libBornAgainDevice:
_libBornAgainDevice.vector_cvector_t_swigregister(vector_cvector_t)

import libBornAgainParam
class IntensityData(object):
    r"""


    Templated class to store data of type double or  CumulativeValue in multi-dimensional space.

    C++ includes: OutputData.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(IntensityData self) -> IntensityData
        OutputData< T >::OutputData(const OutputData &)=delete

        """
        _libBornAgainDevice.IntensityData_swiginit(self, _libBornAgainDevice.new_IntensityData())
    __swig_destroy__ = _libBornAgainDevice.delete_IntensityData

    def clone(self):
        r"""
        clone(IntensityData self) -> IntensityData
        OutputData< T > * OutputData< T >::clone() const

        """
        return _libBornAgainDevice.IntensityData_clone(self)

    def copyFrom(self, x):
        r"""
        copyFrom(IntensityData self, IntensityData x)
        void OutputData< T >::copyFrom(const OutputData< T > &x)

        """
        return _libBornAgainDevice.IntensityData_copyFrom(self, x)

    def meanValues(self):
        r"""
        meanValues(IntensityData self) -> IntensityData
        OutputData< double > * OutputData< T >::meanValues() const

        """
        return _libBornAgainDevice.IntensityData_meanValues(self)

    def addAxis(self, *args):
        r"""
        addAxis(IntensityData self, IAxis new_axis)
        addAxis(IntensityData self, std::string const & name, size_t size, double start, double end)
        void OutputData< T >::addAxis(const std::string &name, size_t size, double start, double end)

        """
        return _libBornAgainDevice.IntensityData_addAxis(self, *args)

    def axis(self, serial_number):
        r"""
        axis(IntensityData self, size_t serial_number) -> IAxis
        const IAxis & OutputData< T >::axis(size_t serial_number) const

        returns axis with given serial number 

        """
        return _libBornAgainDevice.IntensityData_axis(self, serial_number)

    def rank(self):
        r"""
        rank(IntensityData self) -> size_t
        size_t OutputData< T >::rank() const

        Returns number of dimensions. 

        """
        return _libBornAgainDevice.IntensityData_rank(self)

    def getAllocatedSize(self):
        r"""
        getAllocatedSize(IntensityData self) -> size_t
        size_t OutputData< T >::getAllocatedSize() const

        Returns total size of data buffer (product of bin number in every dimension). 

        """
        return _libBornAgainDevice.IntensityData_getAllocatedSize(self)

    def getAllSizes(self):
        r"""
        getAllSizes(IntensityData self) -> std::vector< size_t,std::allocator< size_t > >
        std::vector< size_t > OutputData< T >::getAllSizes() const

        Returns all sizes of its axes. 

        """
        return _libBornAgainDevice.IntensityData_getAllSizes(self)

    def getRawDataVector(self):
        r"""
        getRawDataVector(IntensityData self) -> vdouble1d_t
        std::vector< T > OutputData< T >::getRawDataVector() const

        Returns copy of raw data vector. 

        """
        return _libBornAgainDevice.IntensityData_getRawDataVector(self)

    def totalSum(self):
        r"""
        totalSum(IntensityData self) -> double
        T OutputData< T >::totalSum() const

        Returns sum of all values in the data structure. 

        """
        return _libBornAgainDevice.IntensityData_totalSum(self)

    def begin(self, *args):
        r"""
        begin(IntensityData self) -> OutputData< double >::iterator
        begin(IntensityData self) -> OutputData< double >::const_iterator
        OutputData< T >::const_iterator OutputData< T >::begin() const

        Returns read-only iterator that points to the first element. 

        """
        return _libBornAgainDevice.IntensityData_begin(self, *args)

    def end(self, *args):
        r"""
        end(IntensityData self) -> OutputData< double >::iterator
        end(IntensityData self) -> OutputData< double >::const_iterator
        const_iterator OutputData< T >::end() const

        Returns read-only iterator that points to the one past last element. 

        """
        return _libBornAgainDevice.IntensityData_end(self, *args)

    def getAxesBinIndices(self, global_index):
        r"""
        getAxesBinIndices(IntensityData self, size_t global_index) -> vector_integer_t
        std::vector< int > OutputData< T >::getAxesBinIndices(size_t global_index) const

        Returns vector of axes indices for given global index

        Parameters:
        -----------

        global_index: 
        The global index of this data structure.

        Vector of bin indices for all axes defined 

        """
        return _libBornAgainDevice.IntensityData_getAxesBinIndices(self, global_index)

    def getAxisBinIndex(self, *args):
        r"""
        getAxisBinIndex(IntensityData self, size_t global_index, size_t i_selected_axis) -> size_t
        getAxisBinIndex(IntensityData self, size_t global_index, std::string const & axis_name) -> size_t
        size_t OutputData< T >::getAxisBinIndex(size_t global_index, const std::string &axis_name) const

        Returns axis bin index for given global index

        Parameters:
        -----------

        global_index: 
        The global index of this data structure.

        axis_name: 
        The name of selected axis.

        Corresponding bin index for selected axis 

        """
        return _libBornAgainDevice.IntensityData_getAxisBinIndex(self, *args)

    def toGlobalIndex(self, axes_indices):
        r"""
        toGlobalIndex(IntensityData self, std::vector< unsigned int,std::allocator< unsigned int > > const & axes_indices) -> size_t
        size_t OutputData< T >::toGlobalIndex(const std::vector< unsigned > &axes_indices) const

        Returns global index for specified indices of axes

        Parameters:
        -----------

        axes_indices: 
        Vector of axes indices for all specified axes in this dataset

        Corresponding global index 

        """
        return _libBornAgainDevice.IntensityData_toGlobalIndex(self, axes_indices)

    def findGlobalIndex(self, coordinates):
        r"""
        findGlobalIndex(IntensityData self, vdouble1d_t coordinates) -> size_t
        size_t OutputData< T >::findGlobalIndex(const std::vector< double > &coordinates) const

        Returns global index for specified axes values

        Parameters:
        -----------

        coordinates: 
        Vector of axes coordinates for all specified axes in this dataset

        Closest global index 

        """
        return _libBornAgainDevice.IntensityData_findGlobalIndex(self, coordinates)

    def getAxisValue(self, *args):
        r"""
        getAxisValue(IntensityData self, size_t global_index, size_t i_selected_axis) -> double
        getAxisValue(IntensityData self, size_t global_index, std::string const & axis_name) -> double
        double OutputData< T >::getAxisValue(size_t global_index, const std::string &axis_name) const

        Returns the value of selected axis for given global_index.

        Parameters:
        -----------

        global_index: 
        The global index of this data structure.

        axis_name: 
        The name of selected axis.

        corresponding bin center of selected axis 

        """
        return _libBornAgainDevice.IntensityData_getAxisValue(self, *args)

    def getAxesValues(self, global_index):
        r"""
        getAxesValues(IntensityData self, size_t global_index) -> vdouble1d_t
        std::vector< double > OutputData< T >::getAxesValues(size_t global_index) const

        Returns values on all defined axes for given globalbin number

        Parameters:
        -----------

        global_index: 
        The global index of this data structure.

        Vector of corresponding bin centers 

        """
        return _libBornAgainDevice.IntensityData_getAxesValues(self, global_index)

    def getAxisBin(self, *args):
        r"""
        getAxisBin(IntensityData self, size_t global_index, size_t i_selected_axis) -> Bin1D
        getAxisBin(IntensityData self, size_t global_index, std::string const & axis_name) -> Bin1D
        Bin1D OutputData< T >::getAxisBin(size_t global_index, const std::string &axis_name) const

        Returns bin of selected axis for given global_index.

        Parameters:
        -----------

        global_index: 
        The global index of this data structure.

        axis_name: 
        The name of selected axis.

        Corresponding Bin1D object 

        """
        return _libBornAgainDevice.IntensityData_getAxisBin(self, *args)

    def clear(self):
        r"""
        clear(IntensityData self)
        void OutputData< T >::clear()

        Sets object into initial state (no dimensions, data) 

        """
        return _libBornAgainDevice.IntensityData_clear(self)

    def setAllTo(self, value):
        r"""
        setAllTo(IntensityData self, double const & value)
        void OutputData< T >::setAllTo(const T &value)

        Sets content of output data to specific value. 

        """
        return _libBornAgainDevice.IntensityData_setAllTo(self, value)

    def scaleAll(self, factor):
        r"""
        scaleAll(IntensityData self, double const & factor)
        void OutputData< T >::scaleAll(const T &factor)

        multiply every item of this output data by value 

        """
        return _libBornAgainDevice.IntensityData_scaleAll(self, factor)

    def setAxisSizes(self, rank, n_dims):
        r"""
        setAxisSizes(IntensityData self, size_t rank, int * n_dims)
        void OutputData< T >::setAxisSizes(size_t rank, int *n_dims)

        Adds 'rank' axes with indicated sizes. 

        """
        return _libBornAgainDevice.IntensityData_setAxisSizes(self, rank, n_dims)

    def setRawDataVector(self, data_vector):
        r"""
        setRawDataVector(IntensityData self, vdouble1d_t data_vector)
        void OutputData< T >::setRawDataVector(const std::vector< T > &data_vector)

        Sets new values to raw data vector. 

        """
        return _libBornAgainDevice.IntensityData_setRawDataVector(self, data_vector)

    def setRawDataArray(self, source):
        r"""
        setRawDataArray(IntensityData self, double const * source)
        void OutputData< T >::setRawDataArray(const T *source)

        Sets new values to raw data array. 

        """
        return _libBornAgainDevice.IntensityData_setRawDataArray(self, source)

    def __iadd__(self, right):
        r"""__iadd__(IntensityData self, IntensityData right) -> IntensityData"""
        return _libBornAgainDevice.IntensityData___iadd__(self, right)

    def __isub__(self, right):
        r"""__isub__(IntensityData self, IntensityData right) -> IntensityData"""
        return _libBornAgainDevice.IntensityData___isub__(self, right)

    def __itruediv__(self, *args):
        return _libBornAgainDevice.IntensityData___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __imul__(self, right):
        r"""__imul__(IntensityData self, IntensityData right) -> IntensityData"""
        return _libBornAgainDevice.IntensityData___imul__(self, right)

    def getValue(self, index):
        r"""
        getValue(IntensityData self, size_t index) -> double
        double OutputData< double >::getValue(size_t index) const

        """
        return _libBornAgainDevice.IntensityData_getValue(self, index)

    def getArray(self):
        r"""
        getArray(IntensityData self) -> PyObject *
        PyObject * OutputData< double >::getArray() const

        returns data as Python numpy array 

        """
        return _libBornAgainDevice.IntensityData_getArray(self)

    def isInitialized(self):
        r"""
        isInitialized(IntensityData self) -> bool
        bool OutputData< T >::isInitialized() const

        returns true if object is correctly initialized 

        """
        return _libBornAgainDevice.IntensityData_isInitialized(self)

    def allocate(self):
        r"""
        allocate(IntensityData self)
        void OutputData< T >::allocate()

        memory allocation for current dimensions configuration 

        """
        return _libBornAgainDevice.IntensityData_allocate(self)

    def __getitem__(self, i):
        r"""__getitem__(IntensityData self, unsigned int i) -> double"""
        return _libBornAgainDevice.IntensityData___getitem__(self, i)

    def __setitem__(self, i, value):
        r"""__setitem__(IntensityData self, unsigned int i, double value) -> double"""
        return _libBornAgainDevice.IntensityData___setitem__(self, i, value)

# Register IntensityData in _libBornAgainDevice:
_libBornAgainDevice.IntensityData_swigregister(IntensityData)


def relativeDataDifference(dat, ref):
    r"""
    relativeDataDifference(IntensityData dat, IntensityData ref) -> double
    double DataUtils::relativeDataDifference(const OutputData< double > &dat, const OutputData< double > &ref)

    Returns relative difference between two data sets sum(dat[i] - ref[i])/ref[i]). 

    """
    return _libBornAgainDevice.relativeDataDifference(dat, ref)

def checkRelativeDifference(dat, ref, threshold):
    r"""
    checkRelativeDifference(IntensityData dat, IntensityData ref, double const threshold) -> bool
    bool DataUtils::checkRelativeDifference(const OutputData< double > &dat, const OutputData< double > &ref, const double threshold)

    Returns true is relative difference is below threshold; prints informative output. 

    """
    return _libBornAgainDevice.checkRelativeDifference(dat, ref, threshold)

def coordinateToBinf(*args):
    r"""
    coordinateToBinf(double coordinate, IAxis axis) -> double
    coordinateToBinf(double & x, double & y, IntensityData data)
    void DataUtils::coordinateToBinf(double &x, double &y, const OutputData< double > &data)

    Transforms x,y coordinate from  OutputData axes coordinates to bin-fraction-coordinates. 

    """
    return _libBornAgainDevice.coordinateToBinf(*args)

def coordinateFromBinf(*args):
    r"""
    coordinateFromBinf(double value, IAxis axis) -> double
    coordinateFromBinf(double & x, double & y, IntensityData data)
    void DataUtils::coordinateFromBinf(double &x, double &y, const OutputData< double > &data)

    Transforms x,y coordinate from bin-fraction-coordinates to  OutputData's axes coordinates. 

    """
    return _libBornAgainDevice.coordinateFromBinf(*args)

def create2DArrayfromOutputData(data):
    r"""
    create2DArrayfromOutputData(IntensityData data) -> vdouble2d_t
    std::vector< std::vector< double > > DataUtils::create2DArrayfromOutputData(const OutputData< double > &data)

    Creates a vector of vectors of double (2D Array) from  OutputData. 

    """
    return _libBornAgainDevice.create2DArrayfromOutputData(data)

def importArrayToOutputData(*args):
    r"""
    importArrayToOutputData(vdouble1d_t vec) -> IntensityData
    importArrayToOutputData(vdouble2d_t vec) -> IntensityData
    OutputData< double > * DataUtils::importArrayToOutputData(const std::vector< std::vector< double >> &vec)

    Reads 2D array of doubles to Python, for use in persistence test. 

    """
    return _libBornAgainDevice.importArrayToOutputData(*args)
class Beam(libBornAgainParam.INode):
    r"""


    Beam defined by wavelength, direction and intensity.

    C++ includes: Beam.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Beam self, double intensity, double wavelength, Direction const & direction) -> Beam
        __init__(Beam self, Beam other) -> Beam
        Beam::Beam(const Beam &other)

        """
        _libBornAgainDevice.Beam_swiginit(self, _libBornAgainDevice.new_Beam(*args))
    __swig_destroy__ = _libBornAgainDevice.delete_Beam

    @staticmethod
    def horizontalBeam():
        r"""horizontalBeam() -> Beam"""
        return _libBornAgainDevice.Beam_horizontalBeam()

    def accept(self, visitor):
        r"""
        accept(Beam self, INodeVisitor * visitor)
        void Beam::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainDevice.Beam_accept(self, visitor)

    def getChildren(self):
        r"""
        getChildren(Beam self) -> std::vector< INode const *,std::allocator< INode const * > >
        std::vector< const INode * > Beam::getChildren() const override

        """
        return _libBornAgainDevice.Beam_getChildren(self)

    def intensity(self):
        r"""
        intensity(Beam self) -> double
        double Beam::intensity() const

        Returns the beam intensity in neutrons/sec. 

        """
        return _libBornAgainDevice.Beam_intensity(self)

    def wavelength(self):
        r"""
        wavelength(Beam self) -> double
        double Beam::wavelength() const

        """
        return _libBornAgainDevice.Beam_wavelength(self)

    def direction(self):
        r"""
        direction(Beam self) -> Direction
        Direction Beam::direction() const

        """
        return _libBornAgainDevice.Beam_direction(self)

    def getCentralK(self):
        r"""
        getCentralK(Beam self) -> kvector_t
        kvector_t Beam::getCentralK() const

        Returns the wavevector. 

        """
        return _libBornAgainDevice.Beam_getCentralK(self)

    def getBlochVector(self):
        r"""
        getBlochVector(Beam self) -> kvector_t
        kvector_t Beam::getBlochVector() const

        """
        return _libBornAgainDevice.Beam_getBlochVector(self)

    def footprintFactor(self):
        r"""
        footprintFactor(Beam self) -> IFootprintFactor
        const IFootprintFactor * Beam::footprintFactor() const

        Returns footprint factor. 

        """
        return _libBornAgainDevice.Beam_footprintFactor(self)

    def setWavelength(self, wavelength):
        r"""
        setWavelength(Beam self, double wavelength)
        void Beam::setWavelength(double wavelength)

        """
        return _libBornAgainDevice.Beam_setWavelength(self, wavelength)

    def setDirection(self, direction):
        r"""
        setDirection(Beam self, Direction const & direction)
        void Beam::setDirection(const Direction &direction)

        """
        return _libBornAgainDevice.Beam_setDirection(self, direction)

    def setInclination(self, alpha):
        r"""
        setInclination(Beam self, double const alpha)
        void Beam::setInclination(const double alpha)

        """
        return _libBornAgainDevice.Beam_setInclination(self, alpha)

    def setIntensity(self, intensity):
        r"""
        setIntensity(Beam self, double intensity)
        void Beam::setIntensity(double intensity)

        Sets the beam intensity in neutrons/sec. 

        """
        return _libBornAgainDevice.Beam_setIntensity(self, intensity)

    def setFootprintFactor(self, shape_factor):
        r"""
        setFootprintFactor(Beam self, IFootprintFactor shape_factor)
        void Beam::setFootprintFactor(const IFootprintFactor &shape_factor)

        Sets footprint factor to the beam. 

        """
        return _libBornAgainDevice.Beam_setFootprintFactor(self, shape_factor)

    def setWidthRatio(self, width_ratio):
        r"""
        setWidthRatio(Beam self, double width_ratio)
        void Beam::setWidthRatio(double width_ratio)

        Sets beam to sample width ratio in footprint factor. 

        """
        return _libBornAgainDevice.Beam_setWidthRatio(self, width_ratio)

    def setPolarization(self, bloch_vector):
        r"""
        setPolarization(Beam self, kvector_t bloch_vector)
        void Beam::setPolarization(const kvector_t bloch_vector)

        Sets the polarization density matrix according to the given Bloch vector. 

        """
        return _libBornAgainDevice.Beam_setPolarization(self, bloch_vector)

# Register Beam in _libBornAgainDevice:
_libBornAgainDevice.Beam_swigregister(Beam)

def Beam_horizontalBeam():
    r"""Beam_horizontalBeam() -> Beam"""
    return _libBornAgainDevice.Beam_horizontalBeam()

class IFootprintFactor(libBornAgainBase.ICloneable, libBornAgainParam.INode):
    r"""


    Abstract base for classes that calculate the beam footprint factor

    C++ includes: IFootprintFactor.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainDevice.delete_IFootprintFactor

    def clone(self):
        r"""
        clone(IFootprintFactor self) -> IFootprintFactor
        virtual IFootprintFactor* IFootprintFactor::clone() const =0

        """
        return _libBornAgainDevice.IFootprintFactor_clone(self)

    def setWidthRatio(self, width_ratio):
        r"""
        setWidthRatio(IFootprintFactor self, double width_ratio)
        void IFootprintFactor::setWidthRatio(double width_ratio)

        """
        return _libBornAgainDevice.IFootprintFactor_setWidthRatio(self, width_ratio)

    def widthRatio(self):
        r"""
        widthRatio(IFootprintFactor self) -> double
        double IFootprintFactor::widthRatio() const

        """
        return _libBornAgainDevice.IFootprintFactor_widthRatio(self)

    def calculate(self, alpha):
        r"""
        calculate(IFootprintFactor self, double alpha) -> double
        virtual double IFootprintFactor::calculate(double alpha) const =0

        Calculate footprint correction coefficient from the beam incident angle  alpha. 

        """
        return _libBornAgainDevice.IFootprintFactor_calculate(self, alpha)

    def name(self):
        r"""
        name(IFootprintFactor self) -> std::string
        virtual std::string IFootprintFactor::name() const =0

        """
        return _libBornAgainDevice.IFootprintFactor_name(self)

# Register IFootprintFactor in _libBornAgainDevice:
_libBornAgainDevice.IFootprintFactor_swigregister(IFootprintFactor)

class FootprintGauss(IFootprintFactor):
    r"""


    Calculates footprint coefficient for a gaussian beam  Beam width is interpreted as the full width on the level of  \\[ \\exp{-1/2} \\] from the peak intensity.

    C++ includes: FootprintGauss.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FootprintGauss self, vdouble1d_t P) -> FootprintGauss
        __init__(FootprintGauss self, double width_ratio) -> FootprintGauss
        FootprintGauss::FootprintGauss(double width_ratio)

        """
        _libBornAgainDevice.FootprintGauss_swiginit(self, _libBornAgainDevice.new_FootprintGauss(*args))

    def accept(self, visitor):
        r"""
        accept(FootprintGauss self, INodeVisitor * visitor)
        void FootprintGauss::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainDevice.FootprintGauss_accept(self, visitor)

    def clone(self):
        r"""
        clone(FootprintGauss self) -> FootprintGauss
        FootprintGauss * FootprintGauss::clone() const override

        """
        return _libBornAgainDevice.FootprintGauss_clone(self)

    def calculate(self, alpha):
        r"""
        calculate(FootprintGauss self, double alpha) -> double
        double FootprintGauss::calculate(double alpha) const override

        Calculate footprint correction coefficient from the beam incident angle  alpha. 

        """
        return _libBornAgainDevice.FootprintGauss_calculate(self, alpha)

    def name(self):
        r"""
        name(FootprintGauss self) -> std::string
        std::string FootprintGauss::name() const override

        """
        return _libBornAgainDevice.FootprintGauss_name(self)
    __swig_destroy__ = _libBornAgainDevice.delete_FootprintGauss

# Register FootprintGauss in _libBornAgainDevice:
_libBornAgainDevice.FootprintGauss_swigregister(FootprintGauss)

class FootprintSquare(IFootprintFactor):
    r"""


    Calculates footprint coefficient for a square beam

    C++ includes: FootprintSquare.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FootprintSquare self, vdouble1d_t P) -> FootprintSquare
        __init__(FootprintSquare self, double width_ratio) -> FootprintSquare
        FootprintSquare::FootprintSquare(double width_ratio)

        """
        _libBornAgainDevice.FootprintSquare_swiginit(self, _libBornAgainDevice.new_FootprintSquare(*args))

    def accept(self, visitor):
        r"""
        accept(FootprintSquare self, INodeVisitor * visitor)
        void FootprintSquare::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainDevice.FootprintSquare_accept(self, visitor)

    def clone(self):
        r"""
        clone(FootprintSquare self) -> FootprintSquare
        FootprintSquare * FootprintSquare::clone() const override

        """
        return _libBornAgainDevice.FootprintSquare_clone(self)

    def calculate(self, alpha):
        r"""
        calculate(FootprintSquare self, double alpha) -> double
        double FootprintSquare::calculate(double alpha) const override

        Calculate footprint correction coefficient from the beam incident angle  alpha. 

        """
        return _libBornAgainDevice.FootprintSquare_calculate(self, alpha)

    def name(self):
        r"""
        name(FootprintSquare self) -> std::string
        std::string FootprintSquare::name() const override

        """
        return _libBornAgainDevice.FootprintSquare_name(self)
    __swig_destroy__ = _libBornAgainDevice.delete_FootprintSquare

# Register FootprintSquare in _libBornAgainDevice:
_libBornAgainDevice.FootprintSquare_swigregister(FootprintSquare)

class IShape2D(libBornAgainBase.ICloneable):
    r"""


    Basic class for all shapes in 2D.

    C++ includes: IShape2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        r"""
        clone(IShape2D self) -> IShape2D
        virtual IShape2D* IShape2D::clone() const =0

        """
        return _libBornAgainDevice.IShape2D_clone(self)

    def contains(self, *args):
        r"""
        contains(IShape2D self, double x, double y) -> bool
        contains(IShape2D self, Bin1D const & binx, Bin1D const & biny) -> bool
        virtual bool IShape2D::contains(const Bin1D &binx, const Bin1D &biny) const =0

        Returns true if area defined by two bins is inside or on border of polygon (more precisely, if mid point of two bins satisfy this condition). 

        """
        return _libBornAgainDevice.IShape2D_contains(self, *args)
    __swig_destroy__ = _libBornAgainDevice.delete_IShape2D

# Register IShape2D in _libBornAgainDevice:
_libBornAgainDevice.IShape2D_swigregister(IShape2D)

class Ellipse(IShape2D):
    r"""


    Ellipse shape.

    C++ includes: Ellipse.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, xcenter, ycenter, xradius, yradius, theta=0.0):
        r"""
        __init__(Ellipse self, double xcenter, double ycenter, double xradius, double yradius, double theta=0.0) -> Ellipse
        Ellipse::Ellipse(double xcenter, double ycenter, double xradius, double yradius, double theta=0.0)

        Parameters:
        -----------

        xcenter: 
        x-coordinate of  Ellipse's center

        ycenter: 
        y-coordinate of  Ellipse's center

        xradius: 
        Radius along x-axis

        yradius: 
        Radius along y-axis

        theta: 
        Angle of  Ellipse rotation in radians 

        """
        _libBornAgainDevice.Ellipse_swiginit(self, _libBornAgainDevice.new_Ellipse(xcenter, ycenter, xradius, yradius, theta))

    def clone(self):
        r"""
        clone(Ellipse self) -> Ellipse
        Ellipse* Ellipse::clone() const

        """
        return _libBornAgainDevice.Ellipse_clone(self)

    def contains(self, *args):
        r"""
        contains(Ellipse self, double x, double y) -> bool
        contains(Ellipse self, Bin1D const & binx, Bin1D const & biny) -> bool
        bool Ellipse::contains(const Bin1D &binx, const Bin1D &biny) const

        Returns true if area defined by two bins is inside or on border of ellipse; more precisely, if mid point of two bins satisfy this condition. 

        """
        return _libBornAgainDevice.Ellipse_contains(self, *args)

    def getCenterX(self):
        r"""
        getCenterX(Ellipse self) -> double
        double Ellipse::getCenterX() const

        """
        return _libBornAgainDevice.Ellipse_getCenterX(self)

    def getCenterY(self):
        r"""
        getCenterY(Ellipse self) -> double
        double Ellipse::getCenterY() const

        """
        return _libBornAgainDevice.Ellipse_getCenterY(self)

    def getRadiusX(self):
        r"""
        getRadiusX(Ellipse self) -> double
        double Ellipse::getRadiusX() const

        """
        return _libBornAgainDevice.Ellipse_getRadiusX(self)

    def getRadiusY(self):
        r"""
        getRadiusY(Ellipse self) -> double
        double Ellipse::getRadiusY() const

        """
        return _libBornAgainDevice.Ellipse_getRadiusY(self)

    def getTheta(self):
        r"""
        getTheta(Ellipse self) -> double
        double Ellipse::getTheta() const

        """
        return _libBornAgainDevice.Ellipse_getTheta(self)
    __swig_destroy__ = _libBornAgainDevice.delete_Ellipse

# Register Ellipse in _libBornAgainDevice:
_libBornAgainDevice.Ellipse_swigregister(Ellipse)

class Line(IShape2D):
    r"""


    A line segment.

    C++ includes: Line.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, x1, y1, x2, y2):
        r"""
        __init__(Line self, double x1, double y1, double x2, double y2) -> Line
        Line::Line(double x1, double y1, double x2, double y2)

        """
        _libBornAgainDevice.Line_swiginit(self, _libBornAgainDevice.new_Line(x1, y1, x2, y2))

    def clone(self):
        r"""
        clone(Line self) -> Line
        Line* Line::clone() const

        """
        return _libBornAgainDevice.Line_clone(self)

    def contains(self, *args):
        r"""
        contains(Line self, double x, double y) -> bool
        contains(Line self, Bin1D const & binx, Bin1D const & biny) -> bool
        bool Line::contains(const Bin1D &binx, const Bin1D &biny) const

        Returns true if area defined by two bins is inside or on border of polygon (more precisely, if mid point of two bins satisfy this condition). 

        """
        return _libBornAgainDevice.Line_contains(self, *args)
    __swig_destroy__ = _libBornAgainDevice.delete_Line

# Register Line in _libBornAgainDevice:
_libBornAgainDevice.Line_swigregister(Line)

class VerticalLine(IShape2D):
    r"""


    An infinite vertical line.

    C++ includes: Line.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, x):
        r"""
        __init__(VerticalLine self, double x) -> VerticalLine
        VerticalLine::VerticalLine(double x)

        Parameters:
        -----------

        x: 
        The value at which it crosses x-axes 

        """
        _libBornAgainDevice.VerticalLine_swiginit(self, _libBornAgainDevice.new_VerticalLine(x))

    def clone(self):
        r"""
        clone(VerticalLine self) -> VerticalLine
        VerticalLine* VerticalLine::clone() const

        """
        return _libBornAgainDevice.VerticalLine_clone(self)

    def contains(self, *args):
        r"""
        contains(VerticalLine self, double x, double y) -> bool
        contains(VerticalLine self, Bin1D const & binx, Bin1D const & biny) -> bool
        bool VerticalLine::contains(const Bin1D &binx, const Bin1D &biny) const

        Returns true if area defined by two bins is inside or on border of polygon (more precisely, if mid point of two bins satisfy this condition). 

        """
        return _libBornAgainDevice.VerticalLine_contains(self, *args)

    def getXpos(self):
        r"""
        getXpos(VerticalLine self) -> double
        double VerticalLine::getXpos() const

        """
        return _libBornAgainDevice.VerticalLine_getXpos(self)
    __swig_destroy__ = _libBornAgainDevice.delete_VerticalLine

# Register VerticalLine in _libBornAgainDevice:
_libBornAgainDevice.VerticalLine_swigregister(VerticalLine)

class HorizontalLine(IShape2D):
    r"""


    An infinite horizontal line.

    C++ includes: Line.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, y):
        r"""
        __init__(HorizontalLine self, double y) -> HorizontalLine
        HorizontalLine::HorizontalLine(double y)

        Parameters:
        -----------

        y: 
        The value at which it crosses y-axes 

        """
        _libBornAgainDevice.HorizontalLine_swiginit(self, _libBornAgainDevice.new_HorizontalLine(y))

    def clone(self):
        r"""
        clone(HorizontalLine self) -> HorizontalLine
        HorizontalLine* HorizontalLine::clone() const

        """
        return _libBornAgainDevice.HorizontalLine_clone(self)

    def contains(self, *args):
        r"""
        contains(HorizontalLine self, double x, double y) -> bool
        contains(HorizontalLine self, Bin1D const & binx, Bin1D const & biny) -> bool
        bool HorizontalLine::contains(const Bin1D &binx, const Bin1D &biny) const

        Returns true if area defined by two bins is inside or on border of polygon (more precisely, if mid point of two bins satisfy this condition). 

        """
        return _libBornAgainDevice.HorizontalLine_contains(self, *args)

    def getYpos(self):
        r"""
        getYpos(HorizontalLine self) -> double
        double HorizontalLine::getYpos() const

        """
        return _libBornAgainDevice.HorizontalLine_getYpos(self)
    __swig_destroy__ = _libBornAgainDevice.delete_HorizontalLine

# Register HorizontalLine in _libBornAgainDevice:
_libBornAgainDevice.HorizontalLine_swigregister(HorizontalLine)

class Polygon(IShape2D):
    r"""


    A polygon in 2D space.  Polygon defined by two arrays with x and y coordinates of points. Sizes of arrays should coincide. If polygon is unclosed (the last point doesn't repeat the first one), it will be closed automatically.

    C++ includes: Polygon.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Polygon self, vdouble1d_t x, vdouble1d_t y) -> Polygon
        __init__(Polygon self, vdouble2d_t points) -> Polygon
        __init__(Polygon self, PolygonPrivate const * d) -> Polygon
        Polygon::Polygon(const PolygonPrivate *d)

        """
        _libBornAgainDevice.Polygon_swiginit(self, _libBornAgainDevice.new_Polygon(*args))
    __swig_destroy__ = _libBornAgainDevice.delete_Polygon

    def clone(self):
        r"""
        clone(Polygon self) -> Polygon
        virtual Polygon* Polygon::clone() const

        """
        return _libBornAgainDevice.Polygon_clone(self)

    def contains(self, *args):
        r"""
        contains(Polygon self, double x, double y) -> bool
        contains(Polygon self, Bin1D const & binx, Bin1D const & biny) -> bool
        bool Polygon::contains(const Bin1D &binx, const Bin1D &biny) const

        Returns true if area defined by two bins is inside or on border of polygon (more precisely, if mid point of two bins satisfy this condition). 

        """
        return _libBornAgainDevice.Polygon_contains(self, *args)

    def getArea(self):
        r"""
        getArea(Polygon self) -> double
        double Polygon::getArea() const

        """
        return _libBornAgainDevice.Polygon_getArea(self)

    def getPoints(self, xpos, ypos):
        r"""
        getPoints(Polygon self, vdouble1d_t xpos, vdouble1d_t ypos)
        void Polygon::getPoints(std::vector< double > &xpos, std::vector< double > &ypos) const

        """
        return _libBornAgainDevice.Polygon_getPoints(self, xpos, ypos)

# Register Polygon in _libBornAgainDevice:
_libBornAgainDevice.Polygon_swigregister(Polygon)

class Rectangle(IShape2D):
    r"""


    The rectangle shape having its axis aligned to the (non-rotated) coordinate system.

    C++ includes: Rectangle.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, xlow, ylow, xup, yup):
        r"""
        __init__(Rectangle self, double xlow, double ylow, double xup, double yup) -> Rectangle
        Rectangle::Rectangle(double xlow, double ylow, double xup, double yup)

        Parameters:
        -----------

        xlow: 
        x-coordinate of lower left corner

        ylow: 
        y-coordinate of lower left corner

        xup: 
        x-coordinate of upper right corner

        yup: 
        y-coordinate of upper right corner 

        """
        _libBornAgainDevice.Rectangle_swiginit(self, _libBornAgainDevice.new_Rectangle(xlow, ylow, xup, yup))

    def clone(self):
        r"""
        clone(Rectangle self) -> Rectangle
        Rectangle* Rectangle::clone() const

        """
        return _libBornAgainDevice.Rectangle_clone(self)

    def contains(self, *args):
        r"""
        contains(Rectangle self, double x, double y) -> bool
        contains(Rectangle self, Bin1D const & binx, Bin1D const & biny) -> bool
        bool Rectangle::contains(const Bin1D &binx, const Bin1D &biny) const

        Returns true if area defined by two bins is inside or on border of polygon (more precisely, if mid point of two bins satisfy this condition). 

        """
        return _libBornAgainDevice.Rectangle_contains(self, *args)

    def getArea(self):
        r"""
        getArea(Rectangle self) -> double
        double Rectangle::getArea() const

        """
        return _libBornAgainDevice.Rectangle_getArea(self)

    def getXlow(self):
        r"""
        getXlow(Rectangle self) -> double
        double Rectangle::getXlow() const

        """
        return _libBornAgainDevice.Rectangle_getXlow(self)

    def getYlow(self):
        r"""
        getYlow(Rectangle self) -> double
        double Rectangle::getYlow() const

        """
        return _libBornAgainDevice.Rectangle_getYlow(self)

    def getXup(self):
        r"""
        getXup(Rectangle self) -> double
        double Rectangle::getXup() const

        """
        return _libBornAgainDevice.Rectangle_getXup(self)

    def getYup(self):
        r"""
        getYup(Rectangle self) -> double
        double Rectangle::getYup() const

        """
        return _libBornAgainDevice.Rectangle_getYup(self)
    __swig_destroy__ = _libBornAgainDevice.delete_Rectangle

# Register Rectangle in _libBornAgainDevice:
_libBornAgainDevice.Rectangle_swigregister(Rectangle)

class IDetectorResolution(libBornAgainBase.ICloneable, libBornAgainParam.INode):
    r"""


    Interface for detector resolution algorithms

    C++ includes: IDetectorResolution.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainDevice.delete_IDetectorResolution

    def applyDetectorResolution(self, p_intensity_map):
        r"""
        applyDetectorResolution(IDetectorResolution self, IntensityData p_intensity_map)
        virtual void IDetectorResolution::applyDetectorResolution(OutputData< double > *p_intensity_map) const =0

        Apply the resolution function to the intensity data. 

        """
        return _libBornAgainDevice.IDetectorResolution_applyDetectorResolution(self, p_intensity_map)

    def clone(self):
        r"""
        clone(IDetectorResolution self) -> IDetectorResolution
        virtual IDetectorResolution* IDetectorResolution::clone() const =0

        """
        return _libBornAgainDevice.IDetectorResolution_clone(self)

# Register IDetectorResolution in _libBornAgainDevice:
_libBornAgainDevice.IDetectorResolution_swigregister(IDetectorResolution)

class IResolutionFunction2D(libBornAgainBase.ICloneable, libBornAgainParam.INode):
    r"""


    Interface providing two-dimensional resolution function.

    C++ includes: IResolutionFunction2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainDevice.delete_IResolutionFunction2D

    def evaluateCDF(self, x, y):
        r"""
        evaluateCDF(IResolutionFunction2D self, double x, double y) -> double
        virtual double IResolutionFunction2D::evaluateCDF(double x, double y) const =0

        """
        return _libBornAgainDevice.IResolutionFunction2D_evaluateCDF(self, x, y)

    def clone(self):
        r"""
        clone(IResolutionFunction2D self) -> IResolutionFunction2D
        virtual IResolutionFunction2D* IResolutionFunction2D::clone() const =0

        """
        return _libBornAgainDevice.IResolutionFunction2D_clone(self)

# Register IResolutionFunction2D in _libBornAgainDevice:
_libBornAgainDevice.IResolutionFunction2D_swigregister(IResolutionFunction2D)

class ResolutionFunction2DGaussian(IResolutionFunction2D):
    r"""


    Simple gaussian two-dimensional resolution function.

    C++ includes: ResolutionFunction2DGaussian.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, sigma_x, sigma_y):
        r"""
        __init__(ResolutionFunction2DGaussian self, double sigma_x, double sigma_y) -> ResolutionFunction2DGaussian
        ResolutionFunction2DGaussian::ResolutionFunction2DGaussian(double sigma_x, double sigma_y)

        """
        _libBornAgainDevice.ResolutionFunction2DGaussian_swiginit(self, _libBornAgainDevice.new_ResolutionFunction2DGaussian(sigma_x, sigma_y))

    def evaluateCDF(self, x, y):
        r"""
        evaluateCDF(ResolutionFunction2DGaussian self, double x, double y) -> double
        double ResolutionFunction2DGaussian::evaluateCDF(double x, double y) const

        """
        return _libBornAgainDevice.ResolutionFunction2DGaussian_evaluateCDF(self, x, y)

    def clone(self):
        r"""
        clone(ResolutionFunction2DGaussian self) -> ResolutionFunction2DGaussian
        ResolutionFunction2DGaussian* ResolutionFunction2DGaussian::clone() const

        """
        return _libBornAgainDevice.ResolutionFunction2DGaussian_clone(self)

    def accept(self, visitor):
        r"""
        accept(ResolutionFunction2DGaussian self, INodeVisitor * visitor)
        void ResolutionFunction2DGaussian::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainDevice.ResolutionFunction2DGaussian_accept(self, visitor)

    def getSigmaX(self):
        r"""
        getSigmaX(ResolutionFunction2DGaussian self) -> double
        double ResolutionFunction2DGaussian::getSigmaX() const

        """
        return _libBornAgainDevice.ResolutionFunction2DGaussian_getSigmaX(self)

    def getSigmaY(self):
        r"""
        getSigmaY(ResolutionFunction2DGaussian self) -> double
        double ResolutionFunction2DGaussian::getSigmaY() const

        """
        return _libBornAgainDevice.ResolutionFunction2DGaussian_getSigmaY(self)
    __swig_destroy__ = _libBornAgainDevice.delete_ResolutionFunction2DGaussian

# Register ResolutionFunction2DGaussian in _libBornAgainDevice:
_libBornAgainDevice.ResolutionFunction2DGaussian_swigregister(ResolutionFunction2DGaussian)

class ScanResolution(libBornAgainBase.ICloneable):
    r"""


    Container for reflectivity resolution data.

    C++ includes: ScanResolution.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainDevice.delete_ScanResolution

    @staticmethod
    def scanRelativeResolution(*args):
        r"""
        scanRelativeResolution(IRangedDistribution const & distr, double stddev) -> ScanResolution
        scanRelativeResolution(IRangedDistribution const & distr, vdouble1d_t stddevs) -> ScanResolution
        """
        return _libBornAgainDevice.ScanResolution_scanRelativeResolution(*args)

    @staticmethod
    def scanAbsoluteResolution(*args):
        r"""
        scanAbsoluteResolution(IRangedDistribution const & distr, double stddev) -> ScanResolution
        scanAbsoluteResolution(IRangedDistribution const & distr, vdouble1d_t stddevs) -> ScanResolution
        """
        return _libBornAgainDevice.ScanResolution_scanAbsoluteResolution(*args)

# Register ScanResolution in _libBornAgainDevice:
_libBornAgainDevice.ScanResolution_swigregister(ScanResolution)

def ScanResolution_scanRelativeResolution(*args):
    r"""
    ScanResolution_scanRelativeResolution(IRangedDistribution const & distr, double stddev) -> ScanResolution
    ScanResolution_scanRelativeResolution(IRangedDistribution const & distr, vdouble1d_t stddevs) -> ScanResolution
    """
    return _libBornAgainDevice.ScanResolution_scanRelativeResolution(*args)

def ScanResolution_scanAbsoluteResolution(*args):
    r"""
    ScanResolution_scanAbsoluteResolution(IRangedDistribution const & distr, double stddev) -> ScanResolution
    ScanResolution_scanAbsoluteResolution(IRangedDistribution const & distr, vdouble1d_t stddevs) -> ScanResolution
    """
    return _libBornAgainDevice.ScanResolution_scanAbsoluteResolution(*args)

class Axes(object):
    r"""


    Wrapper for detector axes units, required for a better representation of detector axes units in python

    C++ includes: IUnitConverter.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT = _libBornAgainDevice.Axes_DEFAULT
    
    NBINS = _libBornAgainDevice.Axes_NBINS
    
    RADIANS = _libBornAgainDevice.Axes_RADIANS
    
    DEGREES = _libBornAgainDevice.Axes_DEGREES
    
    MM = _libBornAgainDevice.Axes_MM
    
    QSPACE = _libBornAgainDevice.Axes_QSPACE
    
    QXQY = _libBornAgainDevice.Axes_QXQY
    
    RQ4 = _libBornAgainDevice.Axes_RQ4
    

    def __init__(self):
        r"""
        __init__(Axes self) -> Axes


        Wrapper for detector axes units, required for a better representation of detector axes units in python

        C++ includes: IUnitConverter.h

        """
        _libBornAgainDevice.Axes_swiginit(self, _libBornAgainDevice.new_Axes())
    __swig_destroy__ = _libBornAgainDevice.delete_Axes

# Register Axes in _libBornAgainDevice:
_libBornAgainDevice.Axes_swigregister(Axes)

class IUnitConverter(libBornAgainBase.ICloneable):
    r"""


    Interface to provide axis translations to different units for simulation output

    C++ includes: IUnitConverter.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainDevice.delete_IUnitConverter

    def clone(self):
        r"""
        clone(IUnitConverter self) -> IUnitConverter
        virtual IUnitConverter* IUnitConverter::clone() const =0

        """
        return _libBornAgainDevice.IUnitConverter_clone(self)

    def dimension(self):
        r"""
        dimension(IUnitConverter self) -> size_t
        virtual size_t IUnitConverter::dimension() const =0

        """
        return _libBornAgainDevice.IUnitConverter_dimension(self)

    def calculateMin(self, i_axis, units_type):
        r"""
        calculateMin(IUnitConverter self, size_t i_axis, Axes::Units units_type) -> double
        virtual double IUnitConverter::calculateMin(size_t i_axis, Axes::Units units_type) const =0

        """
        return _libBornAgainDevice.IUnitConverter_calculateMin(self, i_axis, units_type)

    def calculateMax(self, i_axis, units_type):
        r"""
        calculateMax(IUnitConverter self, size_t i_axis, Axes::Units units_type) -> double
        virtual double IUnitConverter::calculateMax(size_t i_axis, Axes::Units units_type) const =0

        """
        return _libBornAgainDevice.IUnitConverter_calculateMax(self, i_axis, units_type)

    def axisSize(self, i_axis):
        r"""
        axisSize(IUnitConverter self, size_t i_axis) -> size_t
        virtual size_t IUnitConverter::axisSize(size_t i_axis) const =0

        """
        return _libBornAgainDevice.IUnitConverter_axisSize(self, i_axis)

    def axisName(self, *args):
        r"""
        axisName(IUnitConverter self, size_t i_axis, Axes::Units units_type=Axes::Units::DEFAULT) -> std::string
        std::string IUnitConverter::axisName(size_t i_axis, Axes::Units units_type=Axes::Units::DEFAULT) const

        """
        return _libBornAgainDevice.IUnitConverter_axisName(self, *args)

    def availableUnits(self):
        r"""
        availableUnits(IUnitConverter self) -> std::vector< Axes::Units,std::allocator< Axes::Units > >
        virtual std::vector<Axes::Units> IUnitConverter::availableUnits() const =0

        """
        return _libBornAgainDevice.IUnitConverter_availableUnits(self)

    def defaultUnits(self):
        r"""
        defaultUnits(IUnitConverter self) -> Axes::Units
        virtual Axes::Units IUnitConverter::defaultUnits() const =0

        """
        return _libBornAgainDevice.IUnitConverter_defaultUnits(self)

    def substituteDefaultUnits(self, units):
        r"""
        substituteDefaultUnits(IUnitConverter self, Axes::Units units) -> Axes::Units
        Axes::Units IUnitConverter::substituteDefaultUnits(Axes::Units units) const

        """
        return _libBornAgainDevice.IUnitConverter_substituteDefaultUnits(self, units)

# Register IUnitConverter in _libBornAgainDevice:
_libBornAgainDevice.IUnitConverter_swigregister(IUnitConverter)
cvar = _libBornAgainDevice.cvar
axisUnitLabel = cvar.axisUnitLabel

class DetectorMask(object):
    r"""


    Collection of detector masks.

    C++ includes: DetectorMask.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(DetectorMask self) -> DetectorMask
        __init__(DetectorMask self, DetectorMask other) -> DetectorMask
        DetectorMask::DetectorMask(const DetectorMask &other)

        """
        _libBornAgainDevice.DetectorMask_swiginit(self, _libBornAgainDevice.new_DetectorMask(*args))

    def addMask(self, shape, mask_value):
        r"""
        addMask(DetectorMask self, IShape2D shape, bool mask_value)
        void DetectorMask::addMask(const IShape2D &shape, bool mask_value)

        Add mask to the stack of detector masks. The value "true" means that the area will be excluded from the analysis.

        Parameters:
        -----------

        shape: 
        The shape of mask.

        mask_value: 
        The value of mask 

        """
        return _libBornAgainDevice.DetectorMask_addMask(self, shape, mask_value)

    def initMaskData(self, *args):
        r"""
        initMaskData(DetectorMask self, IDetector2D detector)
        initMaskData(DetectorMask self, IntensityData data)
        void DetectorMask::initMaskData(const OutputData< double > &data)

        """
        return _libBornAgainDevice.DetectorMask_initMaskData(self, *args)

    def isMasked(self, index):
        r"""
        isMasked(DetectorMask self, size_t index) -> bool
        bool DetectorMask::isMasked(size_t index) const

        """
        return _libBornAgainDevice.DetectorMask_isMasked(self, index)

    def getMaskData(self):
        r"""
        getMaskData(DetectorMask self) -> OutputData< bool > const *
        const OutputData<bool>* DetectorMask::getMaskData() const

        """
        return _libBornAgainDevice.DetectorMask_getMaskData(self)

    def createHistogram(self):
        r"""
        createHistogram(DetectorMask self) -> Histogram2D
        Histogram2D * DetectorMask::createHistogram() const

        """
        return _libBornAgainDevice.DetectorMask_createHistogram(self)

    def hasMasks(self):
        r"""
        hasMasks(DetectorMask self) -> bool
        bool DetectorMask::hasMasks() const

        returns true if has masks 

        """
        return _libBornAgainDevice.DetectorMask_hasMasks(self)

    def numberOfMaskedChannels(self):
        r"""
        numberOfMaskedChannels(DetectorMask self) -> int
        int DetectorMask::numberOfMaskedChannels() const

        """
        return _libBornAgainDevice.DetectorMask_numberOfMaskedChannels(self)

    def numberOfMasks(self):
        r"""
        numberOfMasks(DetectorMask self) -> size_t
        size_t DetectorMask::numberOfMasks() const

        """
        return _libBornAgainDevice.DetectorMask_numberOfMasks(self)

    def getMaskShape(self, mask_index, mask_value):
        r"""
        getMaskShape(DetectorMask self, size_t mask_index, bool & mask_value) -> IShape2D
        const IShape2D * DetectorMask::getMaskShape(size_t mask_index, bool &mask_value) const

        """
        return _libBornAgainDevice.DetectorMask_getMaskShape(self, mask_index, mask_value)
    __swig_destroy__ = _libBornAgainDevice.delete_DetectorMask

# Register DetectorMask in _libBornAgainDevice:
_libBornAgainDevice.DetectorMask_swigregister(DetectorMask)

class IDetector(libBornAgainBase.ICloneable, libBornAgainParam.INode):
    r"""


    Abstract detector interface.

    C++ includes: IDetector.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        r"""
        clone(IDetector self) -> IDetector
        IDetector* IDetector::clone() const override=0

        """
        return _libBornAgainDevice.IDetector_clone(self)
    __swig_destroy__ = _libBornAgainDevice.delete_IDetector

    def init(self, arg2):
        r"""
        init(IDetector self, Beam arg2)
        virtual void IDetector::init(const Beam &)

        Inits detector with the beam settings. 

        """
        return _libBornAgainDevice.IDetector_init(self, arg2)

    def addAxis(self, axis):
        r"""
        addAxis(IDetector self, IAxis axis)
        void IDetector::addAxis(const IAxis &axis)

        """
        return _libBornAgainDevice.IDetector_addAxis(self, axis)

    def setAnalyzerProperties(self, direction, efficiency, total_transmission):
        r"""
        setAnalyzerProperties(IDetector self, kvector_t direction, double efficiency, double total_transmission)
        void IDetector::setAnalyzerProperties(const kvector_t direction, double efficiency, double total_transmission)

        Sets the polarization analyzer characteristics of the detector. 

        """
        return _libBornAgainDevice.IDetector_setAnalyzerProperties(self, direction, efficiency, total_transmission)

    def setDetectorResolution(self, p_detector_resolution):
        r"""
        setDetectorResolution(IDetector self, IDetectorResolution p_detector_resolution)
        void IDetector::setDetectorResolution(const IDetectorResolution &p_detector_resolution)

        Sets the detector resolution. 

        """
        return _libBornAgainDevice.IDetector_setDetectorResolution(self, p_detector_resolution)

    def setResolutionFunction(self, resFunc):
        r"""
        setResolutionFunction(IDetector self, IResolutionFunction2D resFunc)
        void IDetector::setResolutionFunction(const IResolutionFunction2D &resFunc)

        """
        return _libBornAgainDevice.IDetector_setResolutionFunction(self, resFunc)

    def resetRegionOfInterest(self):
        r"""
        resetRegionOfInterest(IDetector self)
        virtual void IDetector::resetRegionOfInterest()=0

        Resets region of interest making whole detector plane available for the simulation. 

        """
        return _libBornAgainDevice.IDetector_resetRegionOfInterest(self)

    def detectorMask(self):
        r"""
        detectorMask(IDetector self) -> DetectorMask
        virtual const DetectorMask* IDetector::detectorMask() const =0

        Returns detector masks container. 

        """
        return _libBornAgainDevice.IDetector_detectorMask(self)

    def getChildren(self):
        r"""
        getChildren(IDetector self) -> std::vector< INode const *,std::allocator< INode const * > >
        std::vector< const INode * > IDetector::getChildren() const override

        """
        return _libBornAgainDevice.IDetector_getChildren(self)

    def iterate(self, func, visit_masks=False):
        r"""
        iterate(IDetector self, std::function< void (IDetector::const_iterator) > func, bool visit_masks=False)
        void IDetector::iterate(std::function< void(const_iterator)> func, bool visit_masks=false) const

        """
        return _libBornAgainDevice.IDetector_iterate(self, func, visit_masks)

    def axis(self, index):
        r"""
        axis(IDetector self, size_t index) -> IAxis
        const IAxis & IDetector::axis(size_t index) const

        """
        return _libBornAgainDevice.IDetector_axis(self, index)

    def dimension(self):
        r"""
        dimension(IDetector self) -> size_t
        size_t IDetector::dimension() const

        Returns actual dimensionality of the detector (number of defined axes) 

        """
        return _libBornAgainDevice.IDetector_dimension(self)

    def axisBinIndex(self, index, selected_axis):
        r"""
        axisBinIndex(IDetector self, size_t index, size_t selected_axis) -> size_t
        size_t IDetector::axisBinIndex(size_t index, size_t selected_axis) const

        Calculate axis index for given global index. 

        """
        return _libBornAgainDevice.IDetector_axisBinIndex(self, index, selected_axis)

    def totalSize(self):
        r"""
        totalSize(IDetector self) -> size_t
        size_t IDetector::totalSize() const

        Returns total number of pixels. 

        """
        return _libBornAgainDevice.IDetector_totalSize(self)

    def applyDetectorResolution(self, p_intensity_map):
        r"""
        applyDetectorResolution(IDetector self, IntensityData p_intensity_map)
        void IDetector::applyDetectorResolution(OutputData< double > *p_intensity_map) const

        Applies the detector resolution to the given intensity maps. 

        """
        return _libBornAgainDevice.IDetector_applyDetectorResolution(self, p_intensity_map)

    def detectorResolution(self):
        r"""
        detectorResolution(IDetector self) -> IDetectorResolution
        const IDetectorResolution * IDetector::detectorResolution() const

        Returns a pointer to detector resolution object. 

        """
        return _libBornAgainDevice.IDetector_detectorResolution(self)

    def detectionProperties(self):
        r"""
        detectionProperties(IDetector self) -> DetectionProperties const &
        const DetectionProperties& IDetector::detectionProperties() const

        Returns detection properties. 

        """
        return _libBornAgainDevice.IDetector_detectionProperties(self)

    def createDetectorIntensity(self, elements):
        r"""
        createDetectorIntensity(IDetector self, std::vector< SimulationElement,std::allocator< SimulationElement > > const & elements) -> IntensityData
        OutputData< double > * IDetector::createDetectorIntensity(const std::vector< SimulationElement > &elements) const

        Returns new intensity map with detector resolution applied. Map will be cropped to ROI if ROI is present. 

        """
        return _libBornAgainDevice.IDetector_createDetectorIntensity(self, elements)

    def defaultAxesUnits(self):
        r"""
        defaultAxesUnits(IDetector self) -> Axes::Units
        virtual Axes::Units IDetector::defaultAxesUnits() const

        Return default axes units. 

        """
        return _libBornAgainDevice.IDetector_defaultAxesUnits(self)

    def numberOfSimulationElements(self):
        r"""
        numberOfSimulationElements(IDetector self) -> size_t
        size_t IDetector::numberOfSimulationElements() const

        Returns number of simulation elements. 

        """
        return _libBornAgainDevice.IDetector_numberOfSimulationElements(self)

    def regionOfInterest(self):
        r"""
        regionOfInterest(IDetector self) -> RegionOfInterest const *
        virtual const RegionOfInterest* IDetector::regionOfInterest() const =0

        Returns region of interest if exists. 

        """
        return _libBornAgainDevice.IDetector_regionOfInterest(self)

# Register IDetector in _libBornAgainDevice:
_libBornAgainDevice.IDetector_swigregister(IDetector)

class IDetector2D(IDetector):
    r"""


    Abstract 2D detector interface.

    C++ includes: IDetector2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        r"""
        clone(IDetector2D self) -> IDetector2D
        IDetector2D* IDetector2D::clone() const override=0

        """
        return _libBornAgainDevice.IDetector2D_clone(self)
    __swig_destroy__ = _libBornAgainDevice.delete_IDetector2D

    def setDetectorParameters(self, n_x, x_min, x_max, n_y, y_min, y_max):
        r"""
        setDetectorParameters(IDetector2D self, size_t n_x, double x_min, double x_max, size_t n_y, double y_min, double y_max)
        void IDetector2D::setDetectorParameters(size_t n_x, double x_min, double x_max, size_t n_y, double y_min, double y_max)

        Sets detector parameters using angle ranges. 

        """
        return _libBornAgainDevice.IDetector2D_setDetectorParameters(self, n_x, x_min, x_max, n_y, y_min, y_max)

    def detectorMask(self):
        r"""
        detectorMask(IDetector2D self) -> DetectorMask
        const DetectorMask * IDetector2D::detectorMask() const override

        Returns detector masks container. 

        """
        return _libBornAgainDevice.IDetector2D_detectorMask(self)

    def addMask(self, shape, mask_value=True):
        r"""
        addMask(IDetector2D self, IShape2D shape, bool mask_value=True)
        void IDetector2D::addMask(const IShape2D &shape, bool mask_value=true)

        Adds mask of given shape to the stack of detector masks. The mask value 'true' means that the channel will be excluded from the simulation. The mask which is added last has priority.

        Parameters:
        -----------

        shape: 
        The shape of mask ( Rectangle,  Polygon,  Line,  Ellipse)

        mask_value: 
        The value of mask 

        """
        return _libBornAgainDevice.IDetector2D_addMask(self, shape, mask_value)

    def maskAll(self):
        r"""
        maskAll(IDetector2D self)
        void IDetector2D::maskAll()

        Put the mask for all detector channels (i.e. exclude whole detector from the analysis) 

        """
        return _libBornAgainDevice.IDetector2D_maskAll(self)

    def regionOfInterest(self):
        r"""
        regionOfInterest(IDetector2D self) -> RegionOfInterest const *
        const RegionOfInterest * IDetector2D::regionOfInterest() const override

        Returns region of interest if exists. 

        """
        return _libBornAgainDevice.IDetector2D_regionOfInterest(self)

    def setRegionOfInterest(self, xlow, ylow, xup, yup):
        r"""
        setRegionOfInterest(IDetector2D self, double xlow, double ylow, double xup, double yup)
        void IDetector2D::setRegionOfInterest(double xlow, double ylow, double xup, double yup)

        Sets rectangular region of interest with lower left and upper right corners defined. 

        """
        return _libBornAgainDevice.IDetector2D_setRegionOfInterest(self, xlow, ylow, xup, yup)

    def resetRegionOfInterest(self):
        r"""
        resetRegionOfInterest(IDetector2D self)
        void IDetector2D::resetRegionOfInterest() override

        Resets region of interest making whole detector plane available for the simulation. 

        """
        return _libBornAgainDevice.IDetector2D_resetRegionOfInterest(self)

    def active_indices(self):
        r"""
        active_indices(IDetector2D self) -> std::vector< size_t,std::allocator< size_t > >
        std::vector< size_t > IDetector2D::active_indices() const

        Returns vector of unmasked detector indices. 

        """
        return _libBornAgainDevice.IDetector2D_active_indices(self)

    def createPixel(self, index):
        r"""
        createPixel(IDetector2D self, size_t index) -> IPixel *
        virtual IPixel* IDetector2D::createPixel(size_t index) const =0

        Creates an IPixel for the given  OutputData object and index. 

        """
        return _libBornAgainDevice.IDetector2D_createPixel(self, index)

    def indexOfSpecular(self, beam):
        r"""
        indexOfSpecular(IDetector2D self, Beam beam) -> size_t
        virtual size_t IDetector2D::indexOfSpecular(const Beam &beam) const =0

        Returns index of pixel that contains the specular wavevector. If no pixel contains this specular wavevector, the number of pixels is returned. This corresponds to an overflow index. 

        """
        return _libBornAgainDevice.IDetector2D_indexOfSpecular(self, beam)

# Register IDetector2D in _libBornAgainDevice:
_libBornAgainDevice.IDetector2D_swigregister(IDetector2D)

class RectangularDetector(IDetector2D):
    r"""


    A flat rectangular detector with axes and resolution function.

    C++ includes: RectangularDetector.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    GENERIC = _libBornAgainDevice.RectangularDetector_GENERIC
    
    PERPENDICULAR_TO_SAMPLE = _libBornAgainDevice.RectangularDetector_PERPENDICULAR_TO_SAMPLE
    
    PERPENDICULAR_TO_DIRECT_BEAM = _libBornAgainDevice.RectangularDetector_PERPENDICULAR_TO_DIRECT_BEAM
    
    PERPENDICULAR_TO_REFLECTED_BEAM = _libBornAgainDevice.RectangularDetector_PERPENDICULAR_TO_REFLECTED_BEAM
    
    PERPENDICULAR_TO_REFLECTED_BEAM_DPOS = _libBornAgainDevice.RectangularDetector_PERPENDICULAR_TO_REFLECTED_BEAM_DPOS
    

    def __init__(self, *args):
        r"""
        __init__(RectangularDetector self, size_t nxbins, double width, size_t nybins, double height) -> RectangularDetector
        __init__(RectangularDetector self, RectangularDetector other) -> RectangularDetector
        RectangularDetector::RectangularDetector(const RectangularDetector &other)

        """
        _libBornAgainDevice.RectangularDetector_swiginit(self, _libBornAgainDevice.new_RectangularDetector(*args))

    def clone(self):
        r"""
        clone(RectangularDetector self) -> RectangularDetector
        RectangularDetector * RectangularDetector::clone() const override

        """
        return _libBornAgainDevice.RectangularDetector_clone(self)

    def accept(self, visitor):
        r"""
        accept(RectangularDetector self, INodeVisitor * visitor)
        void RectangularDetector::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainDevice.RectangularDetector_accept(self, visitor)
    __swig_destroy__ = _libBornAgainDevice.delete_RectangularDetector

    def init(self, beam):
        r"""
        init(RectangularDetector self, Beam beam)
        void RectangularDetector::init(const Beam &beam) override

        Inits detector with the beam settings. 

        """
        return _libBornAgainDevice.RectangularDetector_init(self, beam)

    def setPosition(self, *args):
        r"""
        setPosition(RectangularDetector self, kvector_t normal_to_detector, double u0, double v0, kvector_t direction=kvector_t(0.0, -1.0, 0.0))
        void RectangularDetector::setPosition(const kvector_t normal_to_detector, double u0, double v0, const kvector_t direction=kvector_t(0.0, -1.0, 0.0))

        """
        return _libBornAgainDevice.RectangularDetector_setPosition(self, *args)

    def setPerpendicularToSampleX(self, distance, u0, v0):
        r"""
        setPerpendicularToSampleX(RectangularDetector self, double distance, double u0, double v0)
        void RectangularDetector::setPerpendicularToSampleX(double distance, double u0, double v0)

        """
        return _libBornAgainDevice.RectangularDetector_setPerpendicularToSampleX(self, distance, u0, v0)

    def setPerpendicularToDirectBeam(self, distance, u0, v0):
        r"""
        setPerpendicularToDirectBeam(RectangularDetector self, double distance, double u0, double v0)
        void RectangularDetector::setPerpendicularToDirectBeam(double distance, double u0, double v0)

        """
        return _libBornAgainDevice.RectangularDetector_setPerpendicularToDirectBeam(self, distance, u0, v0)

    def setPerpendicularToReflectedBeam(self, distance, u0=0.0, v0=0.0):
        r"""
        setPerpendicularToReflectedBeam(RectangularDetector self, double distance, double u0=0.0, double v0=0.0)
        void RectangularDetector::setPerpendicularToReflectedBeam(double distance, double u0=0.0, double v0=0.0)

        """
        return _libBornAgainDevice.RectangularDetector_setPerpendicularToReflectedBeam(self, distance, u0, v0)

    def setDirectBeamPosition(self, u0, v0):
        r"""
        setDirectBeamPosition(RectangularDetector self, double u0, double v0)
        void RectangularDetector::setDirectBeamPosition(double u0, double v0)

        """
        return _libBornAgainDevice.RectangularDetector_setDirectBeamPosition(self, u0, v0)

    def getWidth(self):
        r"""
        getWidth(RectangularDetector self) -> double
        double RectangularDetector::getWidth() const

        """
        return _libBornAgainDevice.RectangularDetector_getWidth(self)

    def getHeight(self):
        r"""
        getHeight(RectangularDetector self) -> double
        double RectangularDetector::getHeight() const

        """
        return _libBornAgainDevice.RectangularDetector_getHeight(self)

    def getNbinsX(self):
        r"""
        getNbinsX(RectangularDetector self) -> size_t
        size_t RectangularDetector::getNbinsX() const

        """
        return _libBornAgainDevice.RectangularDetector_getNbinsX(self)

    def getNbinsY(self):
        r"""
        getNbinsY(RectangularDetector self) -> size_t
        size_t RectangularDetector::getNbinsY() const

        """
        return _libBornAgainDevice.RectangularDetector_getNbinsY(self)

    def getNormalVector(self):
        r"""
        getNormalVector(RectangularDetector self) -> kvector_t
        kvector_t RectangularDetector::getNormalVector() const

        """
        return _libBornAgainDevice.RectangularDetector_getNormalVector(self)

    def getU0(self):
        r"""
        getU0(RectangularDetector self) -> double
        double RectangularDetector::getU0() const

        """
        return _libBornAgainDevice.RectangularDetector_getU0(self)

    def getV0(self):
        r"""
        getV0(RectangularDetector self) -> double
        double RectangularDetector::getV0() const

        """
        return _libBornAgainDevice.RectangularDetector_getV0(self)

    def getDirectionVector(self):
        r"""
        getDirectionVector(RectangularDetector self) -> kvector_t
        kvector_t RectangularDetector::getDirectionVector() const

        """
        return _libBornAgainDevice.RectangularDetector_getDirectionVector(self)

    def getDistance(self):
        r"""
        getDistance(RectangularDetector self) -> double
        double RectangularDetector::getDistance() const

        """
        return _libBornAgainDevice.RectangularDetector_getDistance(self)

    def getDirectBeamU0(self):
        r"""
        getDirectBeamU0(RectangularDetector self) -> double
        double RectangularDetector::getDirectBeamU0() const

        """
        return _libBornAgainDevice.RectangularDetector_getDirectBeamU0(self)

    def getDirectBeamV0(self):
        r"""
        getDirectBeamV0(RectangularDetector self) -> double
        double RectangularDetector::getDirectBeamV0() const

        """
        return _libBornAgainDevice.RectangularDetector_getDirectBeamV0(self)

    def getDetectorArrangment(self):
        r"""
        getDetectorArrangment(RectangularDetector self) -> RectangularDetector::EDetectorArrangement
        RectangularDetector::EDetectorArrangement RectangularDetector::getDetectorArrangment() const

        """
        return _libBornAgainDevice.RectangularDetector_getDetectorArrangment(self)

    def defaultAxesUnits(self):
        r"""
        defaultAxesUnits(RectangularDetector self) -> Axes::Units
        Axes::Units RectangularDetector::defaultAxesUnits() const override

        return default axes units 

        """
        return _libBornAgainDevice.RectangularDetector_defaultAxesUnits(self)

    def regionOfInterestPixel(self):
        r"""
        regionOfInterestPixel(RectangularDetector self) -> RectangularPixel *
        RectangularPixel * RectangularDetector::regionOfInterestPixel() const

        """
        return _libBornAgainDevice.RectangularDetector_regionOfInterestPixel(self)

# Register RectangularDetector in _libBornAgainDevice:
_libBornAgainDevice.RectangularDetector_swigregister(RectangularDetector)

class SphericalDetector(IDetector2D):
    r"""


    A spherical detector with axes and resolution function.

    C++ includes: SphericalDetector.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SphericalDetector self) -> SphericalDetector
        __init__(SphericalDetector self, size_t n_phi, double phi_min, double phi_max, size_t n_alpha, double alpha_min, double alpha_max) -> SphericalDetector
        __init__(SphericalDetector self, size_t n_bin, double width, double phi, double alpha) -> SphericalDetector
        __init__(SphericalDetector self, SphericalDetector other) -> SphericalDetector
        SphericalDetector::SphericalDetector(const SphericalDetector &other)

        """
        _libBornAgainDevice.SphericalDetector_swiginit(self, _libBornAgainDevice.new_SphericalDetector(*args))

    def clone(self):
        r"""
        clone(SphericalDetector self) -> SphericalDetector
        SphericalDetector * SphericalDetector::clone() const override

        """
        return _libBornAgainDevice.SphericalDetector_clone(self)

    def accept(self, visitor):
        r"""
        accept(SphericalDetector self, INodeVisitor * visitor)
        void SphericalDetector::accept(INodeVisitor *visitor) const override

        """
        return _libBornAgainDevice.SphericalDetector_accept(self, visitor)
    __swig_destroy__ = _libBornAgainDevice.delete_SphericalDetector

    def defaultAxesUnits(self):
        r"""
        defaultAxesUnits(SphericalDetector self) -> Axes::Units
        Axes::Units SphericalDetector::defaultAxesUnits() const override

        return default axes units 

        """
        return _libBornAgainDevice.SphericalDetector_defaultAxesUnits(self)

# Register SphericalDetector in _libBornAgainDevice:
_libBornAgainDevice.SphericalDetector_swigregister(SphericalDetector)

class IsGISAXSDetector(SphericalDetector):
    r"""


    A spherical detector used for validation with IsGISAXS results.

    C++ includes: IsGISAXSDetector.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(IsGISAXSDetector self) -> IsGISAXSDetector
        __init__(IsGISAXSDetector self, size_t n_phi, double phi_min, double phi_max, size_t n_alpha, double alpha_min, double alpha_max) -> IsGISAXSDetector
        __init__(IsGISAXSDetector self, IsGISAXSDetector other) -> IsGISAXSDetector
        IsGISAXSDetector::IsGISAXSDetector(const IsGISAXSDetector &other)

        """
        _libBornAgainDevice.IsGISAXSDetector_swiginit(self, _libBornAgainDevice.new_IsGISAXSDetector(*args))

    def clone(self):
        r"""
        clone(IsGISAXSDetector self) -> IsGISAXSDetector
        IsGISAXSDetector * IsGISAXSDetector::clone() const override

        """
        return _libBornAgainDevice.IsGISAXSDetector_clone(self)

    def accept(self, visitor):
        r"""
        accept(IsGISAXSDetector self, INodeVisitor * visitor)
        void IsGISAXSDetector::accept(INodeVisitor *visitor) const final

        """
        return _libBornAgainDevice.IsGISAXSDetector_accept(self, visitor)
    __swig_destroy__ = _libBornAgainDevice.delete_IsGISAXSDetector

# Register IsGISAXSDetector in _libBornAgainDevice:
_libBornAgainDevice.IsGISAXSDetector_swigregister(IsGISAXSDetector)


def FindPeaks(*args):
    r"""
    FindPeaks(Histogram2D hist, double sigma=2, std::string const & option={}, double threshold=0.05) -> vector_pvacuum_double_t
    std::vector< std::pair< double, double > > HistoUtils::FindPeaks(const Histogram2D &hist, double sigma=2, const std::string &option={}, double threshold=0.05)

    Returns vector of peak center coordinates, for peaks in given histogram. 

    """
    return _libBornAgainDevice.FindPeaks(*args)

def RelativeDifference(dat, ref):
    r"""
    RelativeDifference(SimulationResult dat, SimulationResult ref) -> double
    double HistoUtils::RelativeDifference(const SimulationResult &dat, const SimulationResult &ref)

    Returns sum of relative differences between each pair of elements: (a, b) -> 2*abs(a - b)/(a + b) ( and zero if a-b=0 )

    Returns sum of relative differences between each pair of elements: (a, b) -> 2*abs(a - b)/(|a| + |b|) ( and zero if a=b=0 within epsilon ) 

    """
    return _libBornAgainDevice.RelativeDifference(dat, ref)

def getRelativeDifference(dat, ref):
    r"""
    getRelativeDifference(IHistogram dat, IHistogram ref) -> double
    double HistoUtils::getRelativeDifference(const IHistogram &dat, const IHistogram &ref)

    """
    return _libBornAgainDevice.getRelativeDifference(dat, ref)
class IHistogram(object):
    r"""


    Base class for 1D and 2D histograms holding values of double type.

    C++ includes: IHistogram.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    INTEGRAL = _libBornAgainDevice.IHistogram_INTEGRAL
    
    AVERAGE = _libBornAgainDevice.IHistogram_AVERAGE
    
    STANDARD_ERROR = _libBornAgainDevice.IHistogram_STANDARD_ERROR
    
    NENTRIES = _libBornAgainDevice.IHistogram_NENTRIES
    
    __swig_destroy__ = _libBornAgainDevice.delete_IHistogram

    def clone(self):
        r"""
        clone(IHistogram self) -> IHistogram
        virtual IHistogram* IHistogram::clone() const =0

        """
        return _libBornAgainDevice.IHistogram_clone(self)

    def rank(self):
        r"""
        rank(IHistogram self) -> size_t
        virtual size_t IHistogram::rank() const =0

        Returns number of histogram dimensions. 

        """
        return _libBornAgainDevice.IHistogram_rank(self)

    def getTotalNumberOfBins(self):
        r"""
        getTotalNumberOfBins(IHistogram self) -> size_t
        size_t IHistogram::getTotalNumberOfBins() const

        Returns total number of histogram bins. For 2D histograms the result will be the product of bin numbers along X and Y axes. 

        """
        return _libBornAgainDevice.IHistogram_getTotalNumberOfBins(self)

    def xAxis(self):
        r"""
        xAxis(IHistogram self) -> IAxis
        const IAxis & IHistogram::xAxis() const

        returns x-axis 

        """
        return _libBornAgainDevice.IHistogram_xAxis(self)

    def yAxis(self):
        r"""
        yAxis(IHistogram self) -> IAxis
        const IAxis & IHistogram::yAxis() const

        returns y-axis for 2D histograms 

        """
        return _libBornAgainDevice.IHistogram_yAxis(self)

    def getXmin(self):
        r"""
        getXmin(IHistogram self) -> double
        double IHistogram::getXmin() const

        Returns x-axis min (lower edge of first bin). 

        """
        return _libBornAgainDevice.IHistogram_getXmin(self)

    def getXmax(self):
        r"""
        getXmax(IHistogram self) -> double
        double IHistogram::getXmax() const

        Returns x-axis max (upper edge of last bin). 

        """
        return _libBornAgainDevice.IHistogram_getXmax(self)

    def getNbinsX(self):
        r"""
        getNbinsX(IHistogram self) -> size_t
        size_t IHistogram::getNbinsX() const

        Returns number of bins on x-axis. 

        """
        return _libBornAgainDevice.IHistogram_getNbinsX(self)

    def getYmin(self):
        r"""
        getYmin(IHistogram self) -> double
        double IHistogram::getYmin() const

        Returns y-axis min (lower edge of first bin) for 2D histograms. 

        """
        return _libBornAgainDevice.IHistogram_getYmin(self)

    def getYmax(self):
        r"""
        getYmax(IHistogram self) -> double
        double IHistogram::getYmax() const

        Returns y-axis max (upper edge of last bin) for 2D histograms. 

        """
        return _libBornAgainDevice.IHistogram_getYmax(self)

    def getNbinsY(self):
        r"""
        getNbinsY(IHistogram self) -> size_t
        size_t IHistogram::getNbinsY() const

        Returns number of bins on y-axis. 

        """
        return _libBornAgainDevice.IHistogram_getNbinsY(self)

    def getGlobalBin(self, binx, biny=0):
        r"""
        getGlobalBin(IHistogram self, size_t binx, size_t biny=0) -> size_t
        size_t IHistogram::getGlobalBin(size_t binx, size_t biny=0) const

        Returns global bin index for given axes indices. For 1D, just returns binx. 

        """
        return _libBornAgainDevice.IHistogram_getGlobalBin(self, binx, biny)

    def findGlobalBin(self, x, y):
        r"""
        findGlobalBin(IHistogram self, double x, double y) -> size_t
        size_t IHistogram::findGlobalBin(double x, double y) const

        Returns closest global bin index for given axes coordinates. 

        """
        return _libBornAgainDevice.IHistogram_findGlobalBin(self, x, y)

    def xAxisIndex(self, i):
        r"""
        xAxisIndex(IHistogram self, size_t i) -> size_t
        size_t IHistogram::xAxisIndex(size_t i) const

        Returns x-axis index for global bin index i. 

        """
        return _libBornAgainDevice.IHistogram_xAxisIndex(self, i)

    def yAxisIndex(self, i):
        r"""
        yAxisIndex(IHistogram self, size_t i) -> size_t
        size_t IHistogram::yAxisIndex(size_t i) const

        Returns y-axis index for global bin index i. 

        """
        return _libBornAgainDevice.IHistogram_yAxisIndex(self, i)

    def xAxisValue(self, i):
        r"""
        xAxisValue(IHistogram self, size_t i) -> double
        double IHistogram::xAxisValue(size_t i)

        Returns the center of bin i of the x axis. 

        """
        return _libBornAgainDevice.IHistogram_xAxisValue(self, i)

    def yAxisValue(self, i):
        r"""
        yAxisValue(IHistogram self, size_t i) -> double
        double IHistogram::yAxisValue(size_t i)

        Returns the center of bin i of the y axis. 

        """
        return _libBornAgainDevice.IHistogram_yAxisValue(self, i)

    def getData(self, *args):
        r"""
        getData(IHistogram self) -> OutputData< CumulativeValue > const
        getData(IHistogram self) -> OutputData< CumulativeValue > &
        OutputData< CumulativeValue > & IHistogram::getData()

        """
        return _libBornAgainDevice.IHistogram_getData(self, *args)

    def binContent(self, *args):
        r"""
        binContent(IHistogram self, size_t i) -> double
        binContent(IHistogram self, size_t binx, size_t biny) -> double
        double IHistogram::binContent(size_t binx, size_t biny) const

        Returns content (accumulated value) of the 2D histogram bin. 

        """
        return _libBornAgainDevice.IHistogram_binContent(self, *args)

    def setBinContent(self, i, value):
        r"""
        setBinContent(IHistogram self, size_t i, double value)
        void IHistogram::setBinContent(size_t i, double value)

        Sets content of the bin corresponding to the globalbin number. 

        """
        return _libBornAgainDevice.IHistogram_setBinContent(self, i, value)

    def addBinContent(self, i, value):
        r"""
        addBinContent(IHistogram self, size_t i, double value)
        void IHistogram::addBinContent(size_t i, double value)

        Add the value to the bin. 

        """
        return _libBornAgainDevice.IHistogram_addBinContent(self, i, value)

    def binError(self, *args):
        r"""
        binError(IHistogram self, size_t i) -> double
        binError(IHistogram self, size_t binx, size_t biny) -> double
        double IHistogram::binError(size_t binx, size_t biny) const

        Returns error of the bin with given indices (for 2D histograms). 

        """
        return _libBornAgainDevice.IHistogram_binError(self, *args)

    def binAverage(self, *args):
        r"""
        binAverage(IHistogram self, size_t i) -> double
        binAverage(IHistogram self, size_t binx, size_t biny) -> double
        double IHistogram::binAverage(size_t binx, size_t biny) const

        Returns average value of the bin with given indices (for 2D histograms). 

        """
        return _libBornAgainDevice.IHistogram_binAverage(self, *args)

    def binNumberOfEntries(self, *args):
        r"""
        binNumberOfEntries(IHistogram self, size_t i) -> int
        binNumberOfEntries(IHistogram self, size_t binx, size_t biny) -> int
        int IHistogram::binNumberOfEntries(size_t binx, size_t biny) const

        Returns number of entries in the bin with given indices (for 2D histograms). 

        """
        return _libBornAgainDevice.IHistogram_binNumberOfEntries(self, *args)

    def getMaximum(self):
        r"""
        getMaximum(IHistogram self) -> double
        double IHistogram::getMaximum() const

        Returns histogram maximum value (maximum of  binContent() over all bins) 

        """
        return _libBornAgainDevice.IHistogram_getMaximum(self)

    def getMaximumBinIndex(self):
        r"""
        getMaximumBinIndex(IHistogram self) -> size_t
        size_t IHistogram::getMaximumBinIndex() const

        Returns globalbin index with maximum content. 

        """
        return _libBornAgainDevice.IHistogram_getMaximumBinIndex(self)

    def getMinimum(self):
        r"""
        getMinimum(IHistogram self) -> double
        double IHistogram::getMinimum() const

        Returns histogram minimum value (minimum of  binContent() over all bins) 

        """
        return _libBornAgainDevice.IHistogram_getMinimum(self)

    def getMinimumBinIndex(self):
        r"""
        getMinimumBinIndex(IHistogram self) -> size_t
        size_t IHistogram::getMinimumBinIndex() const

        Returns globalbin index with minimum content. 

        """
        return _libBornAgainDevice.IHistogram_getMinimumBinIndex(self)

    def scale(self, value):
        r"""
        scale(IHistogram self, double value)
        void IHistogram::scale(double value)

        Multiply this histogram (every bin content value) by a constant. 

        """
        return _libBornAgainDevice.IHistogram_scale(self, value)

    def integral(self):
        r"""
        integral(IHistogram self) -> double
        double IHistogram::integral() const

        Returns integral of bins content (computed as a sum of all bin content). 

        """
        return _libBornAgainDevice.IHistogram_integral(self)

    def array(self, *args):
        r"""
        array(IHistogram self, IHistogram::DataType dataType=DataType::INTEGRAL) -> PyObject
        PyObject * IHistogram::array(DataType dataType=DataType::INTEGRAL) const

        Returns numpy array with bin content (accumulated values). 

        """
        return _libBornAgainDevice.IHistogram_array(self, *args)

    def getArrayObsolete(self, *args):
        r"""
        getArrayObsolete(IHistogram self, IHistogram::DataType dataType=DataType::INTEGRAL) -> PyObject
        PyObject * IHistogram::getArray(DataType dataType=DataType::INTEGRAL) const

        Deprecated
        Use  array() instead. 

        """
        return _libBornAgainDevice.IHistogram_getArrayObsolete(self, *args)

    def reset(self):
        r"""
        reset(IHistogram self)
        void IHistogram::reset()

        Reset histogram content (axes remains) 

        """
        return _libBornAgainDevice.IHistogram_reset(self)

    @staticmethod
    def createHistogram(source):
        r"""createHistogram(IntensityData source) -> IHistogram"""
        return _libBornAgainDevice.IHistogram_createHistogram(source)

    @staticmethod
    def createFrom(*args):
        r"""
        createFrom(std::string const & filename) -> IHistogram
        createFrom(vdouble2d_t data) -> IHistogram
        """
        return _libBornAgainDevice.IHistogram_createFrom(*args)

    def createOutputData(self, *args):
        r"""
        createOutputData(IHistogram self, IHistogram::DataType dataType=DataType::INTEGRAL) -> IntensityData
        OutputData< double > * IHistogram::createOutputData(DataType dataType=DataType::INTEGRAL) const

        creates new  OutputData with histogram's shape and values corresponding to DataType

        creates new  OutputData with histogram's shape and put there values corresponding to DataType 

        """
        return _libBornAgainDevice.IHistogram_createOutputData(self, *args)

    def hasSameShape(self, other):
        r"""
        hasSameShape(IHistogram self, IHistogram other) -> bool
        bool IHistogram::hasSameShape(const IHistogram &other) const

        Returns true if objects a) have same dimensions b) bin boundaries of axes coincide. 

        """
        return _libBornAgainDevice.IHistogram_hasSameShape(self, other)

    def hasSameDimensions(self, other):
        r"""
        hasSameDimensions(IHistogram self, IHistogram other) -> bool
        bool IHistogram::hasSameDimensions(const IHistogram &other) const

        Returns true if object have same rank and number of axes bins. 

        """
        return _libBornAgainDevice.IHistogram_hasSameDimensions(self, other)

    def __iadd__(self, right):
        r"""__iadd__(IHistogram self, IHistogram right) -> IHistogram"""
        return _libBornAgainDevice.IHistogram___iadd__(self, right)

    def relativeDifferenceHistogram(self, rhs):
        r"""
        relativeDifferenceHistogram(IHistogram self, IHistogram rhs) -> IHistogram
        IHistogram * IHistogram::relativeDifferenceHistogram(const IHistogram &rhs)

        returns histogram representing relative difference of two histograms. 

        """
        return _libBornAgainDevice.IHistogram_relativeDifferenceHistogram(self, rhs)

    def save(self, filename):
        r"""
        save(IHistogram self, std::string const & filename)
        void IHistogram::save(const std::string &filename)

        Saves histogram in file Following formats are available: *.txt, *.tif, *.int (*.txt.gz, *.tif.gz, *.int.gz) 

        """
        return _libBornAgainDevice.IHistogram_save(self, filename)

    def load(self, filename):
        r"""
        load(IHistogram self, std::string const & filename)
        void IHistogram::load(const std::string &filename)

        Loads histogram from file, the shape of array in file should match Following formats are available: *.txt, *.tif, *.int (*.txt.gz, *.tif.gz, *.int.gz) Only bin content will be loaded, histogram axes remain the same. 

        """
        return _libBornAgainDevice.IHistogram_load(self, filename)

    @deprecated("Deprecated. Use array() instead.")
    def getArray(self):
        return self.getArrayObsolete()


# Register IHistogram in _libBornAgainDevice:
_libBornAgainDevice.IHistogram_swigregister(IHistogram)

def IHistogram_createHistogram(source):
    r"""IHistogram_createHistogram(IntensityData source) -> IHistogram"""
    return _libBornAgainDevice.IHistogram_createHistogram(source)

def IHistogram_createFrom(*args):
    r"""
    IHistogram_createFrom(std::string const & filename) -> IHistogram
    IHistogram_createFrom(vdouble2d_t data) -> IHistogram
    """
    return _libBornAgainDevice.IHistogram_createFrom(*args)

class Histogram1D(IHistogram):
    r"""


    One dimensional histogram.

    C++ includes: Histogram1D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Histogram1D self, int nbinsx, double xlow, double xup) -> Histogram1D
        __init__(Histogram1D self, int nbinsx, vdouble1d_t xbins) -> Histogram1D
        __init__(Histogram1D self, IAxis axis) -> Histogram1D
        __init__(Histogram1D self, IntensityData data) -> Histogram1D
        Histogram1D::Histogram1D(const OutputData< double > &data)

        Constructor for 1D histograms from basic  OutputData object. 

        """
        _libBornAgainDevice.Histogram1D_swiginit(self, _libBornAgainDevice.new_Histogram1D(*args))

    def clone(self):
        r"""
        clone(Histogram1D self) -> Histogram1D
        Histogram1D * Histogram1D::clone() const

        Returns clone of other histogram. 

        """
        return _libBornAgainDevice.Histogram1D_clone(self)

    def rank(self):
        r"""
        rank(Histogram1D self) -> size_t
        size_t Histogram1D::rank() const

        Returns the number of histogram dimensions. 

        """
        return _libBornAgainDevice.Histogram1D_rank(self)

    def fill(self, x, weight=1.0):
        r"""
        fill(Histogram1D self, double x, double weight=1.0) -> int
        int Histogram1D::fill(double x, double weight=1.0)

        Increment bin with abscissa x with a weight. 

        """
        return _libBornAgainDevice.Histogram1D_fill(self, x, weight)

    def binCenters(self):
        r"""
        binCenters(Histogram1D self) -> vdouble1d_t
        std::vector< double > Histogram1D::binCenters() const

        returns vector of histogram bin centers 

        """
        return _libBornAgainDevice.Histogram1D_binCenters(self)

    def binValues(self):
        r"""
        binValues(Histogram1D self) -> vdouble1d_t
        std::vector< double > Histogram1D::binValues() const

        returns vector of bin content (the value accumulated by bins) 

        """
        return _libBornAgainDevice.Histogram1D_binValues(self)

    def binErrors(self):
        r"""
        binErrors(Histogram1D self) -> vdouble1d_t
        std::vector< double > Histogram1D::binErrors() const

        returns vector of bin errors 

        """
        return _libBornAgainDevice.Histogram1D_binErrors(self)

    def binCentersNumpy(self):
        r"""
        binCentersNumpy(Histogram1D self) -> PyObject *
        PyObject * Histogram1D::binCentersNumpy() const

        """
        return _libBornAgainDevice.Histogram1D_binCentersNumpy(self)

    def binValuesNumpy(self):
        r"""
        binValuesNumpy(Histogram1D self) -> PyObject *
        PyObject * Histogram1D::binValuesNumpy() const

        """
        return _libBornAgainDevice.Histogram1D_binValuesNumpy(self)

    def binErrorsNumpy(self):
        r"""
        binErrorsNumpy(Histogram1D self) -> PyObject *
        PyObject * Histogram1D::binErrorsNumpy() const

        """
        return _libBornAgainDevice.Histogram1D_binErrorsNumpy(self)

    def crop(self, xmin, xmax):
        r"""
        crop(Histogram1D self, double xmin, double xmax) -> Histogram1D
        Histogram1D * Histogram1D::crop(double xmin, double xmax)

        Creates new histogram by applying crop on axis. 

        """
        return _libBornAgainDevice.Histogram1D_crop(self, xmin, xmax)
    __swig_destroy__ = _libBornAgainDevice.delete_Histogram1D

# Register Histogram1D in _libBornAgainDevice:
_libBornAgainDevice.Histogram1D_swigregister(Histogram1D)

class Histogram2D(IHistogram):
    r"""


    Two dimensional histogram.

    C++ includes: Histogram2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Histogram2D self, int nbinsx, double xlow, double xup, int nbinsy, double ylow, double yup) -> Histogram2D
        __init__(Histogram2D self, int nbinsx, vdouble1d_t xbins, int nbinsy, vdouble1d_t ybins) -> Histogram2D
        __init__(Histogram2D self, IAxis axis_x, IAxis axis_y) -> Histogram2D
        __init__(Histogram2D self, IntensityData data) -> Histogram2D
        __init__(Histogram2D self, vdouble2d_t data) -> Histogram2D
        Histogram2D::Histogram2D(std::vector< std::vector< double >> data)

        Constructor for 2D histograms from numpy array (thanks to swig) 

        """
        _libBornAgainDevice.Histogram2D_swiginit(self, _libBornAgainDevice.new_Histogram2D(*args))

    def clone(self):
        r"""
        clone(Histogram2D self) -> Histogram2D
        Histogram2D * Histogram2D::clone() const

        Returns clone of other histogram. 

        """
        return _libBornAgainDevice.Histogram2D_clone(self)

    def rank(self):
        r"""
        rank(Histogram2D self) -> size_t
        size_t Histogram2D::rank() const

        Returns the number of histogram dimensions. 

        """
        return _libBornAgainDevice.Histogram2D_rank(self)

    def fill(self, x, y, weight=1.0):
        r"""
        fill(Histogram2D self, double x, double y, double weight=1.0) -> int
        int Histogram2D::fill(double x, double y, double weight=1.0)

        Increment bin with abscissa x and ordinate y with a weight. 

        """
        return _libBornAgainDevice.Histogram2D_fill(self, x, y, weight)

    def projectionX(self, *args):
        r"""
        projectionX(Histogram2D self) -> Histogram1D
        projectionX(Histogram2D self, double yvalue) -> Histogram1D
        projectionX(Histogram2D self, double ylow, double yup) -> Histogram1D
        Histogram1D * Histogram2D::projectionX(double ylow, double yup)

        Project a 2D histogram into 1D histogram along X. The projection is made from all y-bins corresponding to ordinate between ylow and yup.

        Parameters:
        -----------

        ylow: 
        lower edje on y-axis

        yup: 
        upper edje on y-axis 

        """
        return _libBornAgainDevice.Histogram2D_projectionX(self, *args)

    def projectionY(self, *args):
        r"""
        projectionY(Histogram2D self) -> Histogram1D
        projectionY(Histogram2D self, double xvalue) -> Histogram1D
        projectionY(Histogram2D self, double xlow, double xup) -> Histogram1D
        Histogram1D * Histogram2D::projectionY(double xlow, double xup)

        Project a 2D histogram into 1D histogram along Y. The projection is made from all x-bins corresponding to abscissa between xlow and xup.

        Parameters:
        -----------

        xlow: 
        lower edje on x-axis

        xup: 
        upper edje on x-axis 

        """
        return _libBornAgainDevice.Histogram2D_projectionY(self, *args)

    def crop(self, xmin, ymin, xmax, ymax):
        r"""
        crop(Histogram2D self, double xmin, double ymin, double xmax, double ymax) -> Histogram2D
        Histogram2D * Histogram2D::crop(double xmin, double ymin, double xmax, double ymax)

        Creates new histogram by applying rectangular clip. 

        """
        return _libBornAgainDevice.Histogram2D_crop(self, xmin, ymin, xmax, ymax)

    def setContent(self, data):
        r"""
        setContent(Histogram2D self, vdouble2d_t data)
        void Histogram2D::setContent(const std::vector< std::vector< double >> &data)

        Sets the values in histograms channels from numpy array,. 

        """
        return _libBornAgainDevice.Histogram2D_setContent(self, data)

    def addContent(self, data):
        r"""
        addContent(Histogram2D self, vdouble2d_t data)
        void Histogram2D::addContent(const std::vector< std::vector< double >> &data)

        Add to values in histograms channels from numpy array,. 

        """
        return _libBornAgainDevice.Histogram2D_addContent(self, data)
    __swig_destroy__ = _libBornAgainDevice.delete_Histogram2D

# Register Histogram2D in _libBornAgainDevice:
_libBornAgainDevice.Histogram2D_swigregister(Histogram2D)

class IntensityDataIOFactory(object):
    r"""


    Provides users with possibility to read and write IntensityData from/to files in different format. Type of the file will be deduced from file name. *.txt - ASCII file with 2D array [nrow][ncol], layout as in numpy. *.int - BornAgain internal ASCII format. *.tif - 32-bits tiff file. If file name ends with "*.gz" or "*.bz2" the file will be zipped on the fly using appropriate algorithm.

    Usage:

    C++ includes: IntensityDataIOFactory.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def readOutputData(file_name):
        r"""readOutputData(std::string const & file_name) -> IntensityData"""
        return _libBornAgainDevice.IntensityDataIOFactory_readOutputData(file_name)

    @staticmethod
    def readReflectometryData(file_name):
        r"""readReflectometryData(std::string const & file_name) -> IntensityData"""
        return _libBornAgainDevice.IntensityDataIOFactory_readReflectometryData(file_name)

    @staticmethod
    def readIntensityData(file_name):
        r"""readIntensityData(std::string const & file_name) -> IHistogram"""
        return _libBornAgainDevice.IntensityDataIOFactory_readIntensityData(file_name)

    @staticmethod
    def writeOutputData(data, file_name):
        r"""writeOutputData(IntensityData data, std::string const & file_name)"""
        return _libBornAgainDevice.IntensityDataIOFactory_writeOutputData(data, file_name)

    @staticmethod
    def writeIntensityData(histogram, file_name):
        r"""writeIntensityData(IHistogram histogram, std::string const & file_name)"""
        return _libBornAgainDevice.IntensityDataIOFactory_writeIntensityData(histogram, file_name)

    @staticmethod
    def writeSimulationResult(result, file_name):
        r"""writeSimulationResult(SimulationResult result, std::string const & file_name)"""
        return _libBornAgainDevice.IntensityDataIOFactory_writeSimulationResult(result, file_name)

    def __init__(self):
        r"""
        __init__(IntensityDataIOFactory self) -> IntensityDataIOFactory


        Provides users with possibility to read and write IntensityData from/to files in different format. Type of the file will be deduced from file name. *.txt - ASCII file with 2D array [nrow][ncol], layout as in numpy. *.int - BornAgain internal ASCII format. *.tif - 32-bits tiff file. If file name ends with "*.gz" or "*.bz2" the file will be zipped on the fly using appropriate algorithm.

        Usage:

        C++ includes: IntensityDataIOFactory.h

        """
        _libBornAgainDevice.IntensityDataIOFactory_swiginit(self, _libBornAgainDevice.new_IntensityDataIOFactory())
    __swig_destroy__ = _libBornAgainDevice.delete_IntensityDataIOFactory

# Register IntensityDataIOFactory in _libBornAgainDevice:
_libBornAgainDevice.IntensityDataIOFactory_swigregister(IntensityDataIOFactory)

def IntensityDataIOFactory_readOutputData(file_name):
    r"""IntensityDataIOFactory_readOutputData(std::string const & file_name) -> IntensityData"""
    return _libBornAgainDevice.IntensityDataIOFactory_readOutputData(file_name)

def IntensityDataIOFactory_readReflectometryData(file_name):
    r"""IntensityDataIOFactory_readReflectometryData(std::string const & file_name) -> IntensityData"""
    return _libBornAgainDevice.IntensityDataIOFactory_readReflectometryData(file_name)

def IntensityDataIOFactory_readIntensityData(file_name):
    r"""IntensityDataIOFactory_readIntensityData(std::string const & file_name) -> IHistogram"""
    return _libBornAgainDevice.IntensityDataIOFactory_readIntensityData(file_name)

def IntensityDataIOFactory_writeOutputData(data, file_name):
    r"""IntensityDataIOFactory_writeOutputData(IntensityData data, std::string const & file_name)"""
    return _libBornAgainDevice.IntensityDataIOFactory_writeOutputData(data, file_name)

def IntensityDataIOFactory_writeIntensityData(histogram, file_name):
    r"""IntensityDataIOFactory_writeIntensityData(IHistogram histogram, std::string const & file_name)"""
    return _libBornAgainDevice.IntensityDataIOFactory_writeIntensityData(histogram, file_name)

def IntensityDataIOFactory_writeSimulationResult(result, file_name):
    r"""IntensityDataIOFactory_writeSimulationResult(SimulationResult result, std::string const & file_name)"""
    return _libBornAgainDevice.IntensityDataIOFactory_writeSimulationResult(result, file_name)

class AxisInfo(object):
    r"""


    Information about an axis in specific units. Can be used for plotting.

    C++ includes: SimulationResult.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_name = property(_libBornAgainDevice.AxisInfo_m_name_get, _libBornAgainDevice.AxisInfo_m_name_set, doc=r"""m_name : std::string""")
    m_min = property(_libBornAgainDevice.AxisInfo_m_min_get, _libBornAgainDevice.AxisInfo_m_min_set, doc=r"""m_min : double""")
    m_max = property(_libBornAgainDevice.AxisInfo_m_max_get, _libBornAgainDevice.AxisInfo_m_max_set, doc=r"""m_max : double""")

    def __init__(self):
        r"""
        __init__(AxisInfo self) -> AxisInfo


        Information about an axis in specific units. Can be used for plotting.

        C++ includes: SimulationResult.h

        """
        _libBornAgainDevice.AxisInfo_swiginit(self, _libBornAgainDevice.new_AxisInfo())
    __swig_destroy__ = _libBornAgainDevice.delete_AxisInfo

# Register AxisInfo in _libBornAgainDevice:
_libBornAgainDevice.AxisInfo_swigregister(AxisInfo)

class SimulationResult(object):
    r"""


    Wrapper around OutputData<double> that also provides unit conversions.

    C++ includes: SimulationResult.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SimulationResult self) -> SimulationResult
        __init__(SimulationResult self, IntensityData data, IUnitConverter unit_converter) -> SimulationResult
        __init__(SimulationResult self, SimulationResult other) -> SimulationResult
        __init__(SimulationResult self, SimulationResult other) -> SimulationResult
        SimulationResult::SimulationResult(SimulationResult &&other)

        """
        _libBornAgainDevice.SimulationResult_swiginit(self, _libBornAgainDevice.new_SimulationResult(*args))

    def histogram2d(self, *args):
        r"""
        histogram2d(SimulationResult self, Axes::Units units=Axes::Units::DEFAULT) -> Histogram2D
        Histogram2D * SimulationResult::histogram2d(Axes::Units units=Axes::Units::DEFAULT) const

        """
        return _libBornAgainDevice.SimulationResult_histogram2d(self, *args)

    def axisInfo(self, *args):
        r"""
        axisInfo(SimulationResult self, Axes::Units units=Axes::Units::DEFAULT) -> std::vector< AxisInfo,std::allocator< AxisInfo > >
        std::vector< AxisInfo > SimulationResult::axisInfo(Axes::Units units=Axes::Units::DEFAULT) const

        Provide  AxisInfo for each axis and the given units. 

        """
        return _libBornAgainDevice.SimulationResult_axisInfo(self, *args)

    def converter(self):
        r"""
        converter(SimulationResult self) -> IUnitConverter
        const IUnitConverter & SimulationResult::converter() const

        Returns underlying unit converter. 

        """
        return _libBornAgainDevice.SimulationResult_converter(self)

    def size(self):
        r"""
        size(SimulationResult self) -> size_t
        size_t SimulationResult::size() const

        """
        return _libBornAgainDevice.SimulationResult_size(self)

    def max(self):
        r"""
        max(SimulationResult self) -> double
        double SimulationResult::max() const

        """
        return _libBornAgainDevice.SimulationResult_max(self)

    def empty(self):
        r"""
        empty(SimulationResult self) -> bool
        bool SimulationResult::empty() const

        """
        return _libBornAgainDevice.SimulationResult_empty(self)

    def array(self, *args):
        r"""
        array(SimulationResult self, Axes::Units units=Axes::Units::DEFAULT) -> PyObject
        PyObject * SimulationResult::array(Axes::Units units=Axes::Units::DEFAULT) const

        returns intensity data as Python numpy array 

        """
        return _libBornAgainDevice.SimulationResult_array(self, *args)

    def axis(self, *args):
        r"""
        axis(SimulationResult self, Axes::Units units=Axes::Units::DEFAULT) -> vdouble1d_t
        axis(SimulationResult self, size_t i_axis, Axes::Units units=Axes::Units::DEFAULT) -> vdouble1d_t
        std::vector< double > SimulationResult::axis(size_t i_axis, Axes::Units units=Axes::Units::DEFAULT) const

        Returns axis coordinates as a numpy array. With no parameters given returns coordinates of x-axis in default units. 

        """
        return _libBornAgainDevice.SimulationResult_axis(self, *args)

    def __getitem__(self, i):
        r"""__getitem__(SimulationResult self, unsigned int i) -> double"""
        return _libBornAgainDevice.SimulationResult___getitem__(self, i)

    def __setitem__(self, i, value):
        r"""__setitem__(SimulationResult self, unsigned int i, double value) -> double"""
        return _libBornAgainDevice.SimulationResult___setitem__(self, i, value)
    __swig_destroy__ = _libBornAgainDevice.delete_SimulationResult

# Register SimulationResult in _libBornAgainDevice:
_libBornAgainDevice.SimulationResult_swigregister(SimulationResult)


def ScanRelativeResolution(distribution, rel_dev):
    """
    Creates a scan resolution from the given distribution and
    relative deviation values (that is, the ratios of standard
    deviations and means).
    :param distribution: bornagain.IRangedDistribution object
    :param rel_dev: either single-valued or a numpy array.
                    In the latter case should coinside in
                    size with later used mean values array.
    :return: bornagain.ScanResolution object
    """
    return ScanResolution_scanRelativeResolution(distribution, rel_dev)

def ScanAbsoluteResolution(distribution, std_dev):
    """
    Creates a scan resolution from the given distribution and
    standard deviation values.
    :param distribution: bornagain.IRangedDistribution object
    :param std_dev: either single-valued or a numpy array.
                    In the latter case should coinside in
                    size with later used mean values array.
    :return: bornagain.ScanResolution object
    """
    return ScanResolution_scanAbsoluteResolution(distribution, std_dev)


