# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_libBornAgainFit')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_libBornAgainFit')
    _libBornAgainFit = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libBornAgainFit', [dirname(__file__)])
        except ImportError:
            import _libBornAgainFit
            return _libBornAgainFit
        try:
            _mod = imp.load_module('_libBornAgainFit', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _libBornAgainFit = swig_import_helper()
    del swig_import_helper
else:
    import _libBornAgainFit
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainFit.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainFit.SwigPyIterator_value(self)


    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _libBornAgainFit.SwigPyIterator_incr(self, n)


    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _libBornAgainFit.SwigPyIterator_decr(self, n)


    def distance(self, x):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _libBornAgainFit.SwigPyIterator_distance(self, x)


    def equal(self, x):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainFit.SwigPyIterator_equal(self, x)


    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator_copy(self)


    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainFit.SwigPyIterator_next(self)


    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainFit.SwigPyIterator___next__(self)


    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainFit.SwigPyIterator_previous(self)


    def advance(self, n):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator_advance(self, n)


    def __eq__(self, x):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainFit.SwigPyIterator___eq__(self, x)


    def __ne__(self, x):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainFit.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator___isub__(self, n)


    def __add__(self, n):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator___add__(self, n)


    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _libBornAgainFit.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _libBornAgainFit.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _libBornAgainFit.SHARED_PTR_DISOWN
class vdouble1d_t(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vdouble1d_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vdouble1d_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vdouble1d_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vdouble1d_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vdouble1d_t self) -> bool"""
        return _libBornAgainFit.vdouble1d_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vdouble1d_t self) -> bool"""
        return _libBornAgainFit.vdouble1d_t___bool__(self)


    def __len__(self):
        """__len__(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainFit.vdouble1d_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> vdouble1d_t"""
        return _libBornAgainFit.vdouble1d_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, vdouble1d_t v)
        """
        return _libBornAgainFit.vdouble1d_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _libBornAgainFit.vdouble1d_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vdouble1d_t self, std::vector< double >::difference_type i)
        __delitem__(vdouble1d_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vdouble1d_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vdouble1d_t self, PySliceObject * slice) -> vdouble1d_t
        __getitem__(vdouble1d_t self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _libBornAgainFit.vdouble1d_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vdouble1d_t self, PySliceObject * slice, vdouble1d_t v)
        __setitem__(vdouble1d_t self, PySliceObject * slice)
        __setitem__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _libBornAgainFit.vdouble1d_t___setitem__(self, *args)


    def pop(self):
        """pop(vdouble1d_t self) -> std::vector< double >::value_type"""
        return _libBornAgainFit.vdouble1d_t_pop(self)


    def append(self, x):
        """append(vdouble1d_t self, std::vector< double >::value_type const & x)"""
        return _libBornAgainFit.vdouble1d_t_append(self, x)


    def empty(self):
        """empty(vdouble1d_t self) -> bool"""
        return _libBornAgainFit.vdouble1d_t_empty(self)


    def size(self):
        """size(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainFit.vdouble1d_t_size(self)


    def swap(self, v):
        """swap(vdouble1d_t self, vdouble1d_t v)"""
        return _libBornAgainFit.vdouble1d_t_swap(self, v)


    def begin(self):
        """begin(vdouble1d_t self) -> std::vector< double >::iterator"""
        return _libBornAgainFit.vdouble1d_t_begin(self)


    def end(self):
        """end(vdouble1d_t self) -> std::vector< double >::iterator"""
        return _libBornAgainFit.vdouble1d_t_end(self)


    def rbegin(self):
        """rbegin(vdouble1d_t self) -> std::vector< double >::reverse_iterator"""
        return _libBornAgainFit.vdouble1d_t_rbegin(self)


    def rend(self):
        """rend(vdouble1d_t self) -> std::vector< double >::reverse_iterator"""
        return _libBornAgainFit.vdouble1d_t_rend(self)


    def clear(self):
        """clear(vdouble1d_t self)"""
        return _libBornAgainFit.vdouble1d_t_clear(self)


    def get_allocator(self):
        """get_allocator(vdouble1d_t self) -> std::vector< double >::allocator_type"""
        return _libBornAgainFit.vdouble1d_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vdouble1d_t self)"""
        return _libBornAgainFit.vdouble1d_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vdouble1d_t self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(vdouble1d_t self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _libBornAgainFit.vdouble1d_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> vdouble1d_t
        __init__(std::vector<(double)> self, vdouble1d_t arg2) -> vdouble1d_t
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> vdouble1d_t
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> vdouble1d_t
        """
        this = _libBornAgainFit.new_vdouble1d_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vdouble1d_t self, std::vector< double >::value_type const & x)"""
        return _libBornAgainFit.vdouble1d_t_push_back(self, x)


    def front(self):
        """front(vdouble1d_t self) -> std::vector< double >::value_type const &"""
        return _libBornAgainFit.vdouble1d_t_front(self)


    def back(self):
        """back(vdouble1d_t self) -> std::vector< double >::value_type const &"""
        return _libBornAgainFit.vdouble1d_t_back(self)


    def assign(self, n, x):
        """assign(vdouble1d_t self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _libBornAgainFit.vdouble1d_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vdouble1d_t self, std::vector< double >::size_type new_size)
        resize(vdouble1d_t self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _libBornAgainFit.vdouble1d_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vdouble1d_t self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(vdouble1d_t self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _libBornAgainFit.vdouble1d_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vdouble1d_t self, std::vector< double >::size_type n)"""
        return _libBornAgainFit.vdouble1d_t_reserve(self, n)


    def capacity(self):
        """capacity(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainFit.vdouble1d_t_capacity(self)

    __swig_destroy__ = _libBornAgainFit.delete_vdouble1d_t
    __del__ = lambda self: None
vdouble1d_t_swigregister = _libBornAgainFit.vdouble1d_t_swigregister
vdouble1d_t_swigregister(vdouble1d_t)

class vdouble2d_t(_object):
    """Proxy of C++ std::vector<(std::vector<(double)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vdouble2d_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vdouble2d_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vdouble2d_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vdouble2d_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vdouble2d_t self) -> bool"""
        return _libBornAgainFit.vdouble2d_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vdouble2d_t self) -> bool"""
        return _libBornAgainFit.vdouble2d_t___bool__(self)


    def __len__(self):
        """__len__(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainFit.vdouble2d_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> vdouble2d_t"""
        return _libBornAgainFit.vdouble2d_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        __setslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, vdouble2d_t v)
        """
        return _libBornAgainFit.vdouble2d_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _libBornAgainFit.vdouble2d_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(vdouble2d_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vdouble2d_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vdouble2d_t self, PySliceObject * slice) -> vdouble2d_t
        __getitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i) -> vdouble1d_t
        """
        return _libBornAgainFit.vdouble2d_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vdouble2d_t self, PySliceObject * slice, vdouble2d_t v)
        __setitem__(vdouble2d_t self, PySliceObject * slice)
        __setitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, vdouble1d_t x)
        """
        return _libBornAgainFit.vdouble2d_t___setitem__(self, *args)


    def pop(self):
        """pop(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainFit.vdouble2d_t_pop(self)


    def append(self, x):
        """append(vdouble2d_t self, vdouble1d_t x)"""
        return _libBornAgainFit.vdouble2d_t_append(self, x)


    def empty(self):
        """empty(vdouble2d_t self) -> bool"""
        return _libBornAgainFit.vdouble2d_t_empty(self)


    def size(self):
        """size(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainFit.vdouble2d_t_size(self)


    def swap(self, v):
        """swap(vdouble2d_t self, vdouble2d_t v)"""
        return _libBornAgainFit.vdouble2d_t_swap(self, v)


    def begin(self):
        """begin(vdouble2d_t self) -> std::vector< std::vector< double > >::iterator"""
        return _libBornAgainFit.vdouble2d_t_begin(self)


    def end(self):
        """end(vdouble2d_t self) -> std::vector< std::vector< double > >::iterator"""
        return _libBornAgainFit.vdouble2d_t_end(self)


    def rbegin(self):
        """rbegin(vdouble2d_t self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _libBornAgainFit.vdouble2d_t_rbegin(self)


    def rend(self):
        """rend(vdouble2d_t self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _libBornAgainFit.vdouble2d_t_rend(self)


    def clear(self):
        """clear(vdouble2d_t self)"""
        return _libBornAgainFit.vdouble2d_t_clear(self)


    def get_allocator(self):
        """get_allocator(vdouble2d_t self) -> std::vector< std::vector< double > >::allocator_type"""
        return _libBornAgainFit.vdouble2d_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vdouble2d_t self)"""
        return _libBornAgainFit.vdouble2d_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos) -> std::vector< std::vector< double > >::iterator
        erase(vdouble2d_t self, std::vector< std::vector< double > >::iterator first, std::vector< std::vector< double > >::iterator last) -> std::vector< std::vector< double > >::iterator
        """
        return _libBornAgainFit.vdouble2d_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(double)>)> self) -> vdouble2d_t
        __init__(std::vector<(std::vector<(double)>)> self, vdouble2d_t arg2) -> vdouble2d_t
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size) -> vdouble2d_t
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size, vdouble1d_t value) -> vdouble2d_t
        """
        this = _libBornAgainFit.new_vdouble2d_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vdouble2d_t self, vdouble1d_t x)"""
        return _libBornAgainFit.vdouble2d_t_push_back(self, x)


    def front(self):
        """front(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainFit.vdouble2d_t_front(self)


    def back(self):
        """back(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainFit.vdouble2d_t_back(self)


    def assign(self, n, x):
        """assign(vdouble2d_t self, std::vector< std::vector< double > >::size_type n, vdouble1d_t x)"""
        return _libBornAgainFit.vdouble2d_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vdouble2d_t self, std::vector< std::vector< double > >::size_type new_size)
        resize(vdouble2d_t self, std::vector< std::vector< double > >::size_type new_size, vdouble1d_t x)
        """
        return _libBornAgainFit.vdouble2d_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos, vdouble1d_t x) -> std::vector< std::vector< double > >::iterator
        insert(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos, std::vector< std::vector< double > >::size_type n, vdouble1d_t x)
        """
        return _libBornAgainFit.vdouble2d_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vdouble2d_t self, std::vector< std::vector< double > >::size_type n)"""
        return _libBornAgainFit.vdouble2d_t_reserve(self, n)


    def capacity(self):
        """capacity(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainFit.vdouble2d_t_capacity(self)

    __swig_destroy__ = _libBornAgainFit.delete_vdouble2d_t
    __del__ = lambda self: None
vdouble2d_t_swigregister = _libBornAgainFit.vdouble2d_t_swigregister
vdouble2d_t_swigregister(vdouble2d_t)

class vector_integer_t(_object):
    """Proxy of C++ std::vector<(int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_integer_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_integer_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_integer_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vector_integer_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_integer_t self) -> bool"""
        return _libBornAgainFit.vector_integer_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_integer_t self) -> bool"""
        return _libBornAgainFit.vector_integer_t___bool__(self)


    def __len__(self):
        """__len__(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainFit.vector_integer_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> vector_integer_t"""
        return _libBornAgainFit.vector_integer_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, vector_integer_t v)
        """
        return _libBornAgainFit.vector_integer_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _libBornAgainFit.vector_integer_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_integer_t self, std::vector< int >::difference_type i)
        __delitem__(vector_integer_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vector_integer_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_integer_t self, PySliceObject * slice) -> vector_integer_t
        __getitem__(vector_integer_t self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _libBornAgainFit.vector_integer_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_integer_t self, PySliceObject * slice, vector_integer_t v)
        __setitem__(vector_integer_t self, PySliceObject * slice)
        __setitem__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _libBornAgainFit.vector_integer_t___setitem__(self, *args)


    def pop(self):
        """pop(vector_integer_t self) -> std::vector< int >::value_type"""
        return _libBornAgainFit.vector_integer_t_pop(self)


    def append(self, x):
        """append(vector_integer_t self, std::vector< int >::value_type const & x)"""
        return _libBornAgainFit.vector_integer_t_append(self, x)


    def empty(self):
        """empty(vector_integer_t self) -> bool"""
        return _libBornAgainFit.vector_integer_t_empty(self)


    def size(self):
        """size(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainFit.vector_integer_t_size(self)


    def swap(self, v):
        """swap(vector_integer_t self, vector_integer_t v)"""
        return _libBornAgainFit.vector_integer_t_swap(self, v)


    def begin(self):
        """begin(vector_integer_t self) -> std::vector< int >::iterator"""
        return _libBornAgainFit.vector_integer_t_begin(self)


    def end(self):
        """end(vector_integer_t self) -> std::vector< int >::iterator"""
        return _libBornAgainFit.vector_integer_t_end(self)


    def rbegin(self):
        """rbegin(vector_integer_t self) -> std::vector< int >::reverse_iterator"""
        return _libBornAgainFit.vector_integer_t_rbegin(self)


    def rend(self):
        """rend(vector_integer_t self) -> std::vector< int >::reverse_iterator"""
        return _libBornAgainFit.vector_integer_t_rend(self)


    def clear(self):
        """clear(vector_integer_t self)"""
        return _libBornAgainFit.vector_integer_t_clear(self)


    def get_allocator(self):
        """get_allocator(vector_integer_t self) -> std::vector< int >::allocator_type"""
        return _libBornAgainFit.vector_integer_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_integer_t self)"""
        return _libBornAgainFit.vector_integer_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_integer_t self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(vector_integer_t self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _libBornAgainFit.vector_integer_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int)> self) -> vector_integer_t
        __init__(std::vector<(int)> self, vector_integer_t arg2) -> vector_integer_t
        __init__(std::vector<(int)> self, std::vector< int >::size_type size) -> vector_integer_t
        __init__(std::vector<(int)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> vector_integer_t
        """
        this = _libBornAgainFit.new_vector_integer_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_integer_t self, std::vector< int >::value_type const & x)"""
        return _libBornAgainFit.vector_integer_t_push_back(self, x)


    def front(self):
        """front(vector_integer_t self) -> std::vector< int >::value_type const &"""
        return _libBornAgainFit.vector_integer_t_front(self)


    def back(self):
        """back(vector_integer_t self) -> std::vector< int >::value_type const &"""
        return _libBornAgainFit.vector_integer_t_back(self)


    def assign(self, n, x):
        """assign(vector_integer_t self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _libBornAgainFit.vector_integer_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_integer_t self, std::vector< int >::size_type new_size)
        resize(vector_integer_t self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _libBornAgainFit.vector_integer_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_integer_t self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(vector_integer_t self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _libBornAgainFit.vector_integer_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_integer_t self, std::vector< int >::size_type n)"""
        return _libBornAgainFit.vector_integer_t_reserve(self, n)


    def capacity(self):
        """capacity(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainFit.vector_integer_t_capacity(self)

    __swig_destroy__ = _libBornAgainFit.delete_vector_integer_t
    __del__ = lambda self: None
vector_integer_t_swigregister = _libBornAgainFit.vector_integer_t_swigregister
vector_integer_t_swigregister(vector_integer_t)

class vector_longinteger_t(_object):
    """Proxy of C++ std::vector<(unsigned long)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_longinteger_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_longinteger_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_longinteger_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vector_longinteger_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_longinteger_t self) -> bool"""
        return _libBornAgainFit.vector_longinteger_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_longinteger_t self) -> bool"""
        return _libBornAgainFit.vector_longinteger_t___bool__(self)


    def __len__(self):
        """__len__(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainFit.vector_longinteger_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> vector_longinteger_t"""
        return _libBornAgainFit.vector_longinteger_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)
        __setslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, vector_longinteger_t v)
        """
        return _libBornAgainFit.vector_longinteger_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)"""
        return _libBornAgainFit.vector_longinteger_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i)
        __delitem__(vector_longinteger_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vector_longinteger_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_longinteger_t self, PySliceObject * slice) -> vector_longinteger_t
        __getitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &
        """
        return _libBornAgainFit.vector_longinteger_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_longinteger_t self, PySliceObject * slice, vector_longinteger_t v)
        __setitem__(vector_longinteger_t self, PySliceObject * slice)
        __setitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainFit.vector_longinteger_t___setitem__(self, *args)


    def pop(self):
        """pop(vector_longinteger_t self) -> std::vector< unsigned long >::value_type"""
        return _libBornAgainFit.vector_longinteger_t_pop(self)


    def append(self, x):
        """append(vector_longinteger_t self, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainFit.vector_longinteger_t_append(self, x)


    def empty(self):
        """empty(vector_longinteger_t self) -> bool"""
        return _libBornAgainFit.vector_longinteger_t_empty(self)


    def size(self):
        """size(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainFit.vector_longinteger_t_size(self)


    def swap(self, v):
        """swap(vector_longinteger_t self, vector_longinteger_t v)"""
        return _libBornAgainFit.vector_longinteger_t_swap(self, v)


    def begin(self):
        """begin(vector_longinteger_t self) -> std::vector< unsigned long >::iterator"""
        return _libBornAgainFit.vector_longinteger_t_begin(self)


    def end(self):
        """end(vector_longinteger_t self) -> std::vector< unsigned long >::iterator"""
        return _libBornAgainFit.vector_longinteger_t_end(self)


    def rbegin(self):
        """rbegin(vector_longinteger_t self) -> std::vector< unsigned long >::reverse_iterator"""
        return _libBornAgainFit.vector_longinteger_t_rbegin(self)


    def rend(self):
        """rend(vector_longinteger_t self) -> std::vector< unsigned long >::reverse_iterator"""
        return _libBornAgainFit.vector_longinteger_t_rend(self)


    def clear(self):
        """clear(vector_longinteger_t self)"""
        return _libBornAgainFit.vector_longinteger_t_clear(self)


    def get_allocator(self):
        """get_allocator(vector_longinteger_t self) -> std::vector< unsigned long >::allocator_type"""
        return _libBornAgainFit.vector_longinteger_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_longinteger_t self)"""
        return _libBornAgainFit.vector_longinteger_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_longinteger_t self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(vector_longinteger_t self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator
        """
        return _libBornAgainFit.vector_longinteger_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned long)> self) -> vector_longinteger_t
        __init__(std::vector<(unsigned long)> self, vector_longinteger_t arg2) -> vector_longinteger_t
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size) -> vector_longinteger_t
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> vector_longinteger_t
        """
        this = _libBornAgainFit.new_vector_longinteger_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_longinteger_t self, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainFit.vector_longinteger_t_push_back(self, x)


    def front(self):
        """front(vector_longinteger_t self) -> std::vector< unsigned long >::value_type const &"""
        return _libBornAgainFit.vector_longinteger_t_front(self)


    def back(self):
        """back(vector_longinteger_t self) -> std::vector< unsigned long >::value_type const &"""
        return _libBornAgainFit.vector_longinteger_t_back(self)


    def assign(self, n, x):
        """assign(vector_longinteger_t self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainFit.vector_longinteger_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_longinteger_t self, std::vector< unsigned long >::size_type new_size)
        resize(vector_longinteger_t self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainFit.vector_longinteger_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_longinteger_t self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(vector_longinteger_t self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainFit.vector_longinteger_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_longinteger_t self, std::vector< unsigned long >::size_type n)"""
        return _libBornAgainFit.vector_longinteger_t_reserve(self, n)


    def capacity(self):
        """capacity(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainFit.vector_longinteger_t_capacity(self)

    __swig_destroy__ = _libBornAgainFit.delete_vector_longinteger_t
    __del__ = lambda self: None
vector_longinteger_t_swigregister = _libBornAgainFit.vector_longinteger_t_swigregister
vector_longinteger_t_swigregister(vector_longinteger_t)

class vector_complex_t(_object):
    """Proxy of C++ std::vector<(std::complex<(double)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_complex_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_complex_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_complex_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vector_complex_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_complex_t self) -> bool"""
        return _libBornAgainFit.vector_complex_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_complex_t self) -> bool"""
        return _libBornAgainFit.vector_complex_t___bool__(self)


    def __len__(self):
        """__len__(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainFit.vector_complex_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j) -> vector_complex_t"""
        return _libBornAgainFit.vector_complex_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)
        __setslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j, vector_complex_t v)
        """
        return _libBornAgainFit.vector_complex_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)"""
        return _libBornAgainFit.vector_complex_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i)
        __delitem__(vector_complex_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vector_complex_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_complex_t self, PySliceObject * slice) -> vector_complex_t
        __getitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i) -> std::vector< std::complex< double > >::value_type const &
        """
        return _libBornAgainFit.vector_complex_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_complex_t self, PySliceObject * slice, vector_complex_t v)
        __setitem__(vector_complex_t self, PySliceObject * slice)
        __setitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainFit.vector_complex_t___setitem__(self, *args)


    def pop(self):
        """pop(vector_complex_t self) -> std::vector< std::complex< double > >::value_type"""
        return _libBornAgainFit.vector_complex_t_pop(self)


    def append(self, x):
        """append(vector_complex_t self, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainFit.vector_complex_t_append(self, x)


    def empty(self):
        """empty(vector_complex_t self) -> bool"""
        return _libBornAgainFit.vector_complex_t_empty(self)


    def size(self):
        """size(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainFit.vector_complex_t_size(self)


    def swap(self, v):
        """swap(vector_complex_t self, vector_complex_t v)"""
        return _libBornAgainFit.vector_complex_t_swap(self, v)


    def begin(self):
        """begin(vector_complex_t self) -> std::vector< std::complex< double > >::iterator"""
        return _libBornAgainFit.vector_complex_t_begin(self)


    def end(self):
        """end(vector_complex_t self) -> std::vector< std::complex< double > >::iterator"""
        return _libBornAgainFit.vector_complex_t_end(self)


    def rbegin(self):
        """rbegin(vector_complex_t self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _libBornAgainFit.vector_complex_t_rbegin(self)


    def rend(self):
        """rend(vector_complex_t self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _libBornAgainFit.vector_complex_t_rend(self)


    def clear(self):
        """clear(vector_complex_t self)"""
        return _libBornAgainFit.vector_complex_t_clear(self)


    def get_allocator(self):
        """get_allocator(vector_complex_t self) -> std::vector< std::complex< double > >::allocator_type"""
        return _libBornAgainFit.vector_complex_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_complex_t self)"""
        return _libBornAgainFit.vector_complex_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_complex_t self, std::vector< std::complex< double > >::iterator pos) -> std::vector< std::complex< double > >::iterator
        erase(vector_complex_t self, std::vector< std::complex< double > >::iterator first, std::vector< std::complex< double > >::iterator last) -> std::vector< std::complex< double > >::iterator
        """
        return _libBornAgainFit.vector_complex_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::complex<(double)>)> self) -> vector_complex_t
        __init__(std::vector<(std::complex<(double)>)> self, vector_complex_t arg2) -> vector_complex_t
        __init__(std::vector<(std::complex<(double)>)> self, std::vector< std::complex< double > >::size_type size) -> vector_complex_t
        __init__(std::vector<(std::complex<(double)>)> self, std::vector< std::complex< double > >::size_type size, std::vector< std::complex< double > >::value_type const & value) -> vector_complex_t
        """
        this = _libBornAgainFit.new_vector_complex_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_complex_t self, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainFit.vector_complex_t_push_back(self, x)


    def front(self):
        """front(vector_complex_t self) -> std::vector< std::complex< double > >::value_type const &"""
        return _libBornAgainFit.vector_complex_t_front(self)


    def back(self):
        """back(vector_complex_t self) -> std::vector< std::complex< double > >::value_type const &"""
        return _libBornAgainFit.vector_complex_t_back(self)


    def assign(self, n, x):
        """assign(vector_complex_t self, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainFit.vector_complex_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_complex_t self, std::vector< std::complex< double > >::size_type new_size)
        resize(vector_complex_t self, std::vector< std::complex< double > >::size_type new_size, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainFit.vector_complex_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_complex_t self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::value_type const & x) -> std::vector< std::complex< double > >::iterator
        insert(vector_complex_t self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainFit.vector_complex_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_complex_t self, std::vector< std::complex< double > >::size_type n)"""
        return _libBornAgainFit.vector_complex_t_reserve(self, n)


    def capacity(self):
        """capacity(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainFit.vector_complex_t_capacity(self)

    __swig_destroy__ = _libBornAgainFit.delete_vector_complex_t
    __del__ = lambda self: None
vector_complex_t_swigregister = _libBornAgainFit.vector_complex_t_swigregister
vector_complex_t_swigregister(vector_complex_t)

class vector_string_t(_object):
    """Proxy of C++ std::vector<(std::string)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_string_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_string_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_string_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vector_string_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_string_t self) -> bool"""
        return _libBornAgainFit.vector_string_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_string_t self) -> bool"""
        return _libBornAgainFit.vector_string_t___bool__(self)


    def __len__(self):
        """__len__(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainFit.vector_string_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> vector_string_t"""
        return _libBornAgainFit.vector_string_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, vector_string_t v)
        """
        return _libBornAgainFit.vector_string_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _libBornAgainFit.vector_string_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_string_t self, std::vector< std::string >::difference_type i)
        __delitem__(vector_string_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vector_string_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_string_t self, PySliceObject * slice) -> vector_string_t
        __getitem__(vector_string_t self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _libBornAgainFit.vector_string_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_string_t self, PySliceObject * slice, vector_string_t v)
        __setitem__(vector_string_t self, PySliceObject * slice)
        __setitem__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainFit.vector_string_t___setitem__(self, *args)


    def pop(self):
        """pop(vector_string_t self) -> std::vector< std::string >::value_type"""
        return _libBornAgainFit.vector_string_t_pop(self)


    def append(self, x):
        """append(vector_string_t self, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainFit.vector_string_t_append(self, x)


    def empty(self):
        """empty(vector_string_t self) -> bool"""
        return _libBornAgainFit.vector_string_t_empty(self)


    def size(self):
        """size(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainFit.vector_string_t_size(self)


    def swap(self, v):
        """swap(vector_string_t self, vector_string_t v)"""
        return _libBornAgainFit.vector_string_t_swap(self, v)


    def begin(self):
        """begin(vector_string_t self) -> std::vector< std::string >::iterator"""
        return _libBornAgainFit.vector_string_t_begin(self)


    def end(self):
        """end(vector_string_t self) -> std::vector< std::string >::iterator"""
        return _libBornAgainFit.vector_string_t_end(self)


    def rbegin(self):
        """rbegin(vector_string_t self) -> std::vector< std::string >::reverse_iterator"""
        return _libBornAgainFit.vector_string_t_rbegin(self)


    def rend(self):
        """rend(vector_string_t self) -> std::vector< std::string >::reverse_iterator"""
        return _libBornAgainFit.vector_string_t_rend(self)


    def clear(self):
        """clear(vector_string_t self)"""
        return _libBornAgainFit.vector_string_t_clear(self)


    def get_allocator(self):
        """get_allocator(vector_string_t self) -> std::vector< std::string >::allocator_type"""
        return _libBornAgainFit.vector_string_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_string_t self)"""
        return _libBornAgainFit.vector_string_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_string_t self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(vector_string_t self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _libBornAgainFit.vector_string_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::string)> self) -> vector_string_t
        __init__(std::vector<(std::string)> self, vector_string_t arg2) -> vector_string_t
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> vector_string_t
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vector_string_t
        """
        this = _libBornAgainFit.new_vector_string_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_string_t self, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainFit.vector_string_t_push_back(self, x)


    def front(self):
        """front(vector_string_t self) -> std::vector< std::string >::value_type const &"""
        return _libBornAgainFit.vector_string_t_front(self)


    def back(self):
        """back(vector_string_t self) -> std::vector< std::string >::value_type const &"""
        return _libBornAgainFit.vector_string_t_back(self)


    def assign(self, n, x):
        """assign(vector_string_t self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainFit.vector_string_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_string_t self, std::vector< std::string >::size_type new_size)
        resize(vector_string_t self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainFit.vector_string_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_string_t self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(vector_string_t self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainFit.vector_string_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_string_t self, std::vector< std::string >::size_type n)"""
        return _libBornAgainFit.vector_string_t_reserve(self, n)


    def capacity(self):
        """capacity(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainFit.vector_string_t_capacity(self)

    __swig_destroy__ = _libBornAgainFit.delete_vector_string_t
    __del__ = lambda self: None
vector_string_t_swigregister = _libBornAgainFit.vector_string_t_swigregister
vector_string_t_swigregister(vector_string_t)

class RealLimits(_object):
    """


    Limits for a real fit parameter.

    C++ includes: RealLimits.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RealLimits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RealLimits, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(RealLimits self) -> RealLimits

        RealLimits::RealLimits()

        """
        this = _libBornAgainFit.new_RealLimits()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def hasLowerLimit(self):
        """
        hasLowerLimit(RealLimits self) -> bool

        bool RealLimits::hasLowerLimit() const

        if has lower limit 

        """
        return _libBornAgainFit.RealLimits_hasLowerLimit(self)


    def lowerLimit(self):
        """lowerLimit(RealLimits self) -> double"""
        return _libBornAgainFit.RealLimits_lowerLimit(self)


    def setLowerLimit(self, value):
        """
        setLowerLimit(RealLimits self, double value)

        void RealLimits::setLowerLimit(double value)

        Sets lower limit. 

        """
        return _libBornAgainFit.RealLimits_setLowerLimit(self, value)


    def removeLowerLimit(self):
        """
        removeLowerLimit(RealLimits self)

        void RealLimits::removeLowerLimit()

        remove lower limit 

        """
        return _libBornAgainFit.RealLimits_removeLowerLimit(self)


    def hasUpperLimit(self):
        """
        hasUpperLimit(RealLimits self) -> bool

        bool RealLimits::hasUpperLimit() const

        if has upper limit 

        """
        return _libBornAgainFit.RealLimits_hasUpperLimit(self)


    def upperLimit(self):
        """upperLimit(RealLimits self) -> double"""
        return _libBornAgainFit.RealLimits_upperLimit(self)


    def setUpperLimit(self, value):
        """
        setUpperLimit(RealLimits self, double value)

        void RealLimits::setUpperLimit(double value)

        Sets upper limit. 

        """
        return _libBornAgainFit.RealLimits_setUpperLimit(self, value)


    def removeUpperLimit(self):
        """
        removeUpperLimit(RealLimits self)

        void RealLimits::removeUpperLimit()

        remove upper limit 

        """
        return _libBornAgainFit.RealLimits_removeUpperLimit(self)


    def hasLowerAndUpperLimits(self):
        """
        hasLowerAndUpperLimits(RealLimits self) -> bool

        bool RealLimits::hasLowerAndUpperLimits() const

        if has lower and upper limit 

        """
        return _libBornAgainFit.RealLimits_hasLowerAndUpperLimits(self)


    def setLimits(self, xmin, xmax):
        """
        setLimits(RealLimits self, double xmin, double xmax)

        void RealLimits::setLimits(double xmin, double xmax)

        Sets lower and upper limits. 

        """
        return _libBornAgainFit.RealLimits_setLimits(self, xmin, xmax)


    def removeLimits(self):
        """
        removeLimits(RealLimits self)

        void RealLimits::removeLimits()

        remove limits 

        """
        return _libBornAgainFit.RealLimits_removeLimits(self)


    def isInRange(self, value):
        """
        isInRange(RealLimits self, double value) -> bool

        bool RealLimits::isInRange(double value) const

        returns true if proposed value is in limits range 

        """
        return _libBornAgainFit.RealLimits_isInRange(self, value)


    def lowerLimited(bound_value):
        """lowerLimited(double bound_value) -> RealLimits"""
        return _libBornAgainFit.RealLimits_lowerLimited(bound_value)

    lowerLimited = staticmethod(lowerLimited)

    def positive():
        """positive() -> RealLimits"""
        return _libBornAgainFit.RealLimits_positive()

    positive = staticmethod(positive)

    def nonnegative():
        """nonnegative() -> RealLimits"""
        return _libBornAgainFit.RealLimits_nonnegative()

    nonnegative = staticmethod(nonnegative)

    def upperLimited(bound_value):
        """upperLimited(double bound_value) -> RealLimits"""
        return _libBornAgainFit.RealLimits_upperLimited(bound_value)

    upperLimited = staticmethod(upperLimited)

    def limited(left_bound_value, right_bound_value):
        """limited(double left_bound_value, double right_bound_value) -> RealLimits"""
        return _libBornAgainFit.RealLimits_limited(left_bound_value, right_bound_value)

    limited = staticmethod(limited)

    def limitless():
        """limitless() -> RealLimits"""
        return _libBornAgainFit.RealLimits_limitless()

    limitless = staticmethod(limitless)

    def toString(self):
        """
        toString(RealLimits self) -> std::string

        std::string RealLimits::toString() const 

        """
        return _libBornAgainFit.RealLimits_toString(self)


    def __eq__(self, other):
        """__eq__(RealLimits self, RealLimits other) -> bool"""
        return _libBornAgainFit.RealLimits___eq__(self, other)


    def __ne__(self, other):
        """__ne__(RealLimits self, RealLimits other) -> bool"""
        return _libBornAgainFit.RealLimits___ne__(self, other)


    def isLimitless(self):
        """
        isLimitless(RealLimits self) -> bool

        bool RealLimits::isLimitless() const 

        """
        return _libBornAgainFit.RealLimits_isLimitless(self)


    def isPositive(self):
        """
        isPositive(RealLimits self) -> bool

        bool RealLimits::isPositive() const 

        """
        return _libBornAgainFit.RealLimits_isPositive(self)


    def isNonnegative(self):
        """
        isNonnegative(RealLimits self) -> bool

        bool RealLimits::isNonnegative() const 

        """
        return _libBornAgainFit.RealLimits_isNonnegative(self)


    def isLowerLimited(self):
        """
        isLowerLimited(RealLimits self) -> bool

        bool RealLimits::isLowerLimited() const 

        """
        return _libBornAgainFit.RealLimits_isLowerLimited(self)


    def isUpperLimited(self):
        """
        isUpperLimited(RealLimits self) -> bool

        bool RealLimits::isUpperLimited() const 

        """
        return _libBornAgainFit.RealLimits_isUpperLimited(self)


    def isLimited(self):
        """
        isLimited(RealLimits self) -> bool

        bool RealLimits::isLimited() const 

        """
        return _libBornAgainFit.RealLimits_isLimited(self)

    __swig_destroy__ = _libBornAgainFit.delete_RealLimits
    __del__ = lambda self: None
RealLimits_swigregister = _libBornAgainFit.RealLimits_swigregister
RealLimits_swigregister(RealLimits)

def RealLimits_lowerLimited(bound_value):
    """RealLimits_lowerLimited(double bound_value) -> RealLimits"""
    return _libBornAgainFit.RealLimits_lowerLimited(bound_value)

def RealLimits_positive():
    """RealLimits_positive() -> RealLimits"""
    return _libBornAgainFit.RealLimits_positive()

def RealLimits_nonnegative():
    """RealLimits_nonnegative() -> RealLimits"""
    return _libBornAgainFit.RealLimits_nonnegative()

def RealLimits_upperLimited(bound_value):
    """RealLimits_upperLimited(double bound_value) -> RealLimits"""
    return _libBornAgainFit.RealLimits_upperLimited(bound_value)

def RealLimits_limited(left_bound_value, right_bound_value):
    """RealLimits_limited(double left_bound_value, double right_bound_value) -> RealLimits"""
    return _libBornAgainFit.RealLimits_limited(left_bound_value, right_bound_value)

def RealLimits_limitless():
    """RealLimits_limitless() -> RealLimits"""
    return _libBornAgainFit.RealLimits_limitless()

class AttLimits(_object):
    """


    Attributes and limits of a fit parameter, and coupling between these properties.

    C++ includes: AttLimits.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttLimits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttLimits, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(AttLimits self) -> AttLimits

        AttLimits::AttLimits()

        """
        this = _libBornAgainFit.new_AttLimits()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def limitless():
        """limitless() -> AttLimits"""
        return _libBornAgainFit.AttLimits_limitless()

    limitless = staticmethod(limitless)

    def lowerLimited(bound_value):
        """lowerLimited(double bound_value) -> AttLimits"""
        return _libBornAgainFit.AttLimits_lowerLimited(bound_value)

    lowerLimited = staticmethod(lowerLimited)

    def positive():
        """positive() -> AttLimits"""
        return _libBornAgainFit.AttLimits_positive()

    positive = staticmethod(positive)

    def nonnegative():
        """nonnegative() -> AttLimits"""
        return _libBornAgainFit.AttLimits_nonnegative()

    nonnegative = staticmethod(nonnegative)

    def upperLimited(bound_value):
        """upperLimited(double bound_value) -> AttLimits"""
        return _libBornAgainFit.AttLimits_upperLimited(bound_value)

    upperLimited = staticmethod(upperLimited)

    def limited(left_bound_value, right_bound_value):
        """limited(double left_bound_value, double right_bound_value) -> AttLimits"""
        return _libBornAgainFit.AttLimits_limited(left_bound_value, right_bound_value)

    limited = staticmethod(limited)

    def fixed():
        """fixed() -> AttLimits"""
        return _libBornAgainFit.AttLimits_fixed()

    fixed = staticmethod(fixed)

    def isFixed(self):
        """
        isFixed(AttLimits self) -> bool

        bool AttLimits::isFixed() const 

        """
        return _libBornAgainFit.AttLimits_isFixed(self)


    def isLimited(self):
        """
        isLimited(AttLimits self) -> bool

        bool AttLimits::isLimited() const 

        """
        return _libBornAgainFit.AttLimits_isLimited(self)


    def isUpperLimited(self):
        """
        isUpperLimited(AttLimits self) -> bool

        bool AttLimits::isUpperLimited() const 

        """
        return _libBornAgainFit.AttLimits_isUpperLimited(self)


    def isLowerLimited(self):
        """
        isLowerLimited(AttLimits self) -> bool

        bool AttLimits::isLowerLimited() const 

        """
        return _libBornAgainFit.AttLimits_isLowerLimited(self)


    def isLimitless(self):
        """
        isLimitless(AttLimits self) -> bool

        bool AttLimits::isLimitless() const 

        """
        return _libBornAgainFit.AttLimits_isLimitless(self)


    def lowerLimit(self):
        """
        lowerLimit(AttLimits self) -> double

        double AttLimits::lowerLimit() const 

        """
        return _libBornAgainFit.AttLimits_lowerLimit(self)


    def upperLimit(self):
        """
        upperLimit(AttLimits self) -> double

        double AttLimits::upperLimit() const 

        """
        return _libBornAgainFit.AttLimits_upperLimit(self)


    def setFixed(self, isFixed):
        """
        setFixed(AttLimits self, bool isFixed)

        void AttLimits::setFixed(bool isFixed)

        """
        return _libBornAgainFit.AttLimits_setFixed(self, isFixed)


    def __eq__(self, other):
        """__eq__(AttLimits self, AttLimits other) -> bool"""
        return _libBornAgainFit.AttLimits___eq__(self, other)


    def __ne__(self, other):
        """__ne__(AttLimits self, AttLimits other) -> bool"""
        return _libBornAgainFit.AttLimits___ne__(self, other)


    def toString(self):
        """
        toString(AttLimits self) -> std::string

        std::string AttLimits::toString() const 

        """
        return _libBornAgainFit.AttLimits_toString(self)

    __swig_destroy__ = _libBornAgainFit.delete_AttLimits
    __del__ = lambda self: None
AttLimits_swigregister = _libBornAgainFit.AttLimits_swigregister
AttLimits_swigregister(AttLimits)

def AttLimits_limitless():
    """AttLimits_limitless() -> AttLimits"""
    return _libBornAgainFit.AttLimits_limitless()

def AttLimits_lowerLimited(bound_value):
    """AttLimits_lowerLimited(double bound_value) -> AttLimits"""
    return _libBornAgainFit.AttLimits_lowerLimited(bound_value)

def AttLimits_positive():
    """AttLimits_positive() -> AttLimits"""
    return _libBornAgainFit.AttLimits_positive()

def AttLimits_nonnegative():
    """AttLimits_nonnegative() -> AttLimits"""
    return _libBornAgainFit.AttLimits_nonnegative()

def AttLimits_upperLimited(bound_value):
    """AttLimits_upperLimited(double bound_value) -> AttLimits"""
    return _libBornAgainFit.AttLimits_upperLimited(bound_value)

def AttLimits_limited(left_bound_value, right_bound_value):
    """AttLimits_limited(double left_bound_value, double right_bound_value) -> AttLimits"""
    return _libBornAgainFit.AttLimits_limited(left_bound_value, right_bound_value)

def AttLimits_fixed():
    """AttLimits_fixed() -> AttLimits"""
    return _libBornAgainFit.AttLimits_fixed()

class Parameter(_object):
    """


    A fittable parameter with value, error, step, and limits.

    C++ includes: Parameter.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parameter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Parameter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Fit::Parameter self) -> Parameter
        __init__(Fit::Parameter self, std::string const & name, double value, AttLimits limits, double step=0.0) -> Parameter
        __init__(Fit::Parameter self, std::string const & name, double value, AttLimits limits) -> Parameter
        __init__(Fit::Parameter self, std::string const & name, double value) -> Parameter

        Parameter::Parameter(const std::string &name, double value, const AttLimits &limits=AttLimits::limitless(), double step=0.0)

        Fit parameter constructor.

        Parameters:
        -----------

        name: 
        unique name of fit parameters

        value: 
        starting value of fit parameter

        limits: 
        fit parameter limits

        step: 
        initial step of fit parameter during the minimization, will be calculated automatically, if zero. 

        """
        this = _libBornAgainFit.new_Parameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self):
        """
        name(Parameter self) -> std::string

        std::string Parameter::name() const 

        """
        return _libBornAgainFit.Parameter_name(self)


    def startValue(self):
        """
        startValue(Parameter self) -> double

        double Parameter::startValue() const 

        """
        return _libBornAgainFit.Parameter_startValue(self)


    def limits(self):
        """
        limits(Parameter self) -> AttLimits

        AttLimits Parameter::limits() const 

        """
        return _libBornAgainFit.Parameter_limits(self)


    def value(self):
        """
        value(Parameter self) -> double

        double Parameter::value() const 

        """
        return _libBornAgainFit.Parameter_value(self)


    def setValue(self, value):
        """
        setValue(Parameter self, double value)

        void Parameter::setValue(double value)

        """
        return _libBornAgainFit.Parameter_setValue(self, value)


    def step(self):
        """
        step(Parameter self) -> double

        double Parameter::step() const 

        """
        return _libBornAgainFit.Parameter_step(self)


    def error(self):
        """
        error(Parameter self) -> double

        double Parameter::error() const 

        """
        return _libBornAgainFit.Parameter_error(self)


    def setError(self, value):
        """
        setError(Parameter self, double value)

        void Parameter::setError(double value)

        """
        return _libBornAgainFit.Parameter_setError(self, value)


    __swig_getmethods__["value"] = value
    __swig_setmethods__["value"] = setValue
    if _newclass: value = property(value, setValue)

    __swig_destroy__ = _libBornAgainFit.delete_Parameter
    __del__ = lambda self: None
Parameter_swigregister = _libBornAgainFit.Parameter_swigregister
Parameter_swigregister(Parameter)

class Parameters(_object):
    """


    A collection of fit parameters.

    C++ includes: Parameters.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Parameters, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(Fit::Parameters self) -> Parameters

        Fit::Parameters::Parameters()=default

        """
        this = _libBornAgainFit.new_Parameters()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def add(self, par):
        """
        add(Parameters self, Parameter par)

        void Parameters::add(const Parameter &par)

        """
        return _libBornAgainFit.Parameters_add(self, par)


    def begin(self, *args):
        """
        begin(Parameters self) -> Fit::Parameters::const_iterator
        begin(Parameters self) -> Fit::Parameters::iterator

        Parameters::iterator Parameters::begin()

        """
        return _libBornAgainFit.Parameters_begin(self, *args)


    def end(self, *args):
        """
        end(Parameters self) -> Fit::Parameters::const_iterator
        end(Parameters self) -> Fit::Parameters::iterator

        Parameters::iterator Parameters::end()

        """
        return _libBornAgainFit.Parameters_end(self, *args)


    def size(self):
        """
        size(Parameters self) -> size_t

        size_t Parameters::size() const 

        """
        return _libBornAgainFit.Parameters_size(self)


    def values(self):
        """
        values(Parameters self) -> vdouble1d_t

        std::vector< double > Parameters::values() const 

        """
        return _libBornAgainFit.Parameters_values(self)


    def setValues(self, values):
        """
        setValues(Parameters self, vdouble1d_t values)

        void Parameters::setValues(const std::vector< double > &values)

        """
        return _libBornAgainFit.Parameters_setValues(self, values)


    def errors(self):
        """
        errors(Parameters self) -> vdouble1d_t

        std::vector< double > Parameters::errors() const 

        """
        return _libBornAgainFit.Parameters_errors(self)


    def setErrors(self, errors):
        """
        setErrors(Parameters self, vdouble1d_t errors)

        void Parameters::setErrors(const std::vector< double > &errors)

        """
        return _libBornAgainFit.Parameters_setErrors(self, errors)


    def correlationMatrix(self):
        """correlationMatrix(Parameters self) -> vdouble2d_t"""
        return _libBornAgainFit.Parameters_correlationMatrix(self)


    def setCorrelationMatrix(self, matrix):
        """setCorrelationMatrix(Parameters self, vdouble2d_t matrix)"""
        return _libBornAgainFit.Parameters_setCorrelationMatrix(self, matrix)


    def __getitem__(self, *args):
        """
        __getitem__(Parameters self, std::string name) -> Parameter
        __getitem__(Parameters self, size_t index) -> Parameter
        """
        return _libBornAgainFit.Parameters___getitem__(self, *args)


    def __iter__(self):
        return ParametersIterator(self)

    __swig_destroy__ = _libBornAgainFit.delete_Parameters
    __del__ = lambda self: None
Parameters_swigregister = _libBornAgainFit.Parameters_swigregister
Parameters_swigregister(Parameters)

class IMinimizer(_object):
    """


    Pure virtual interface for all kind minimizers.

    C++ includes: IMinimizer.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMinimizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IMinimizer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainFit.delete_IMinimizer
    __del__ = lambda self: None

    def minimizerName(self):
        """
        minimizerName(IMinimizer self) -> std::string

        virtual std::string IMinimizer::minimizerName() const =0

        return name of the minimizer 

        """
        return _libBornAgainFit.IMinimizer_minimizerName(self)


    def algorithmName(self):
        """
        algorithmName(IMinimizer self) -> std::string

        virtual std::string IMinimizer::algorithmName() const =0

        return name of the minimization algorithm 

        """
        return _libBornAgainFit.IMinimizer_algorithmName(self)


    def minimize_scalar(self, arg2, arg3):
        """
        minimize_scalar(IMinimizer self, fcn_scalar_t arg2, Parameters arg3) -> MinimizerResult

        Fit::MinimizerResult IMinimizer::minimize_scalar(fcn_scalar_t, Fit::Parameters)

        """
        return _libBornAgainFit.IMinimizer_minimize_scalar(self, arg2, arg3)


    def minimize_residual(self, arg2, arg3):
        """
        minimize_residual(IMinimizer self, fcn_residual_t arg2, Parameters arg3) -> MinimizerResult

        Fit::MinimizerResult IMinimizer::minimize_residual(fcn_residual_t, Fit::Parameters)

        """
        return _libBornAgainFit.IMinimizer_minimize_residual(self, arg2, arg3)


    def clear(self):
        """
        clear(IMinimizer self)

        virtual void IMinimizer::clear()

        clear resources (parameters) for consecutives minimizations 

        """
        return _libBornAgainFit.IMinimizer_clear(self)


    def minValue(self):
        """
        minValue(IMinimizer self) -> double

        double IMinimizer::minValue() const

        Returns minimum function value. 

        """
        return _libBornAgainFit.IMinimizer_minValue(self)


    def setOptions(self, options):
        """
        setOptions(IMinimizer self, std::string const & options)

        void IMinimizer::setOptions(const std::string &options)

        Sets option string to the minimizer. 

        """
        return _libBornAgainFit.IMinimizer_setOptions(self, options)

IMinimizer_swigregister = _libBornAgainFit.IMinimizer_swigregister
IMinimizer_swigregister(IMinimizer)

class MinimizerCatalogue(_object):
    """


    Hard-coded information about all minimizers available.

    C++ includes: MinimizerCatalogue.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinimizerCatalogue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinimizerCatalogue, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(MinimizerCatalogue self) -> MinimizerCatalogue

        MinimizerCatalogue::MinimizerCatalogue()

        """
        this = _libBornAgainFit.new_MinimizerCatalogue()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def toString(self):
        """
        toString(MinimizerCatalogue self) -> std::string

        std::string MinimizerCatalogue::toString() const

        Returns multiline string representing catalogue content. 

        """
        return _libBornAgainFit.MinimizerCatalogue_toString(self)


    def minimizerNames(self):
        """
        minimizerNames(MinimizerCatalogue self) -> vector_string_t

        std::vector< std::string > MinimizerCatalogue::minimizerNames() const 

        """
        return _libBornAgainFit.MinimizerCatalogue_minimizerNames(self)


    def algorithmNames(self, minimizerName):
        """
        algorithmNames(MinimizerCatalogue self, std::string const & minimizerName) -> vector_string_t

        std::vector< std::string > MinimizerCatalogue::algorithmNames(const std::string &minimizerName) const

        Returns list of algorithms defined for the minimizer with a given name. 

        """
        return _libBornAgainFit.MinimizerCatalogue_algorithmNames(self, minimizerName)


    def algorithmDescriptions(self, minimizerName):
        """
        algorithmDescriptions(MinimizerCatalogue self, std::string const & minimizerName) -> vector_string_t

        std::vector< std::string > MinimizerCatalogue::algorithmDescriptions(const std::string &minimizerName) const

        Returns list of algorithm's descriptions for the minimizer with a given name . 

        """
        return _libBornAgainFit.MinimizerCatalogue_algorithmDescriptions(self, minimizerName)


    def minimizerInfo(self, minimizerName):
        """
        minimizerInfo(MinimizerCatalogue self, std::string const & minimizerName) -> MinimizerInfo const &

        const MinimizerInfo & MinimizerCatalogue::minimizerInfo(const std::string &minimizerName) const

        Returns info for minimizer with given name. 

        """
        return _libBornAgainFit.MinimizerCatalogue_minimizerInfo(self, minimizerName)

    __swig_destroy__ = _libBornAgainFit.delete_MinimizerCatalogue
    __del__ = lambda self: None
MinimizerCatalogue_swigregister = _libBornAgainFit.MinimizerCatalogue_swigregister
MinimizerCatalogue_swigregister(MinimizerCatalogue)

class MinimizerFactory(_object):
    """


    Factory to create minimizers.

    C++ includes: MinimizerFactory.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinimizerFactory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinimizerFactory, name)
    __repr__ = _swig_repr

    def createMinimizer(*args):
        """
        createMinimizer(std::string const & minimizerName, std::string const & algorithmType, std::string const & optionString) -> IMinimizer
        createMinimizer(std::string const & minimizerName, std::string const & algorithmType) -> IMinimizer
        createMinimizer(std::string const & minimizerName) -> IMinimizer
        """
        return _libBornAgainFit.MinimizerFactory_createMinimizer(*args)

    createMinimizer = staticmethod(createMinimizer)

    def printCatalogue():
        """printCatalogue()"""
        return _libBornAgainFit.MinimizerFactory_printCatalogue()

    printCatalogue = staticmethod(printCatalogue)

    def catalogueToString():
        """catalogueToString() -> std::string"""
        return _libBornAgainFit.MinimizerFactory_catalogueToString()

    catalogueToString = staticmethod(catalogueToString)

    def catalogueDetailsToString():
        """catalogueDetailsToString() -> std::string"""
        return _libBornAgainFit.MinimizerFactory_catalogueDetailsToString()

    catalogueDetailsToString = staticmethod(catalogueDetailsToString)

    def catalogue():
        """catalogue() -> MinimizerCatalogue"""
        return _libBornAgainFit.MinimizerFactory_catalogue()

    catalogue = staticmethod(catalogue)

    def __init__(self):
        """
        __init__(MinimizerFactory self) -> MinimizerFactory



        Factory to create minimizers.

        C++ includes: MinimizerFactory.h

        """
        this = _libBornAgainFit.new_MinimizerFactory()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainFit.delete_MinimizerFactory
    __del__ = lambda self: None
MinimizerFactory_swigregister = _libBornAgainFit.MinimizerFactory_swigregister
MinimizerFactory_swigregister(MinimizerFactory)

def MinimizerFactory_createMinimizer(*args):
    """
    createMinimizer(std::string const & minimizerName, std::string const & algorithmType, std::string const & optionString) -> IMinimizer
    createMinimizer(std::string const & minimizerName, std::string const & algorithmType) -> IMinimizer
    MinimizerFactory_createMinimizer(std::string const & minimizerName) -> IMinimizer
    """
    return _libBornAgainFit.MinimizerFactory_createMinimizer(*args)

def MinimizerFactory_printCatalogue():
    """MinimizerFactory_printCatalogue()"""
    return _libBornAgainFit.MinimizerFactory_printCatalogue()

def MinimizerFactory_catalogueToString():
    """MinimizerFactory_catalogueToString() -> std::string"""
    return _libBornAgainFit.MinimizerFactory_catalogueToString()

def MinimizerFactory_catalogueDetailsToString():
    """MinimizerFactory_catalogueDetailsToString() -> std::string"""
    return _libBornAgainFit.MinimizerFactory_catalogueDetailsToString()

def MinimizerFactory_catalogue():
    """MinimizerFactory_catalogue() -> MinimizerCatalogue"""
    return _libBornAgainFit.MinimizerFactory_catalogue()

class PyCallback(_object):
    """


    Base class to wrap Python callable and pass it to C++. Used in swig interface file, intended to be overloaded from Python.

    C++ includes: PyCallback.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyCallback, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyCallback, name)
    __repr__ = _swig_repr
    SCALAR = _libBornAgainFit.PyCallback_SCALAR
    RESIDUAL = _libBornAgainFit.PyCallback_RESIDUAL

    def __init__(self, *args):
        """
        __init__(PyCallback self, PyCallback::CallbackType callback_type) -> PyCallback
        __init__(PyCallback self) -> PyCallback

        PyCallback::PyCallback(CallbackType callback_type=SCALAR)

        """
        if self.__class__ == PyCallback:
            _self = None
        else:
            _self = self
        this = _libBornAgainFit.new_PyCallback(_self, *args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainFit.delete_PyCallback
    __del__ = lambda self: None

    def callback_type(self):
        """
        callback_type(PyCallback self) -> PyCallback::CallbackType

        PyCallback::CallbackType PyCallback::callback_type() const 

        """
        return _libBornAgainFit.PyCallback_callback_type(self)


    def call_scalar(self, pars):
        """
        call_scalar(PyCallback self, Parameters pars) -> double

        double PyCallback::call_scalar(Fit::Parameters pars)

        Call Python callable and returns its result. Intended to be overloaded in Python.

        Parameters:
        -----------

        pars: 
        Fit parameters object (intentionally passed by value).

        value of objective function. 

        """
        return _libBornAgainFit.PyCallback_call_scalar(self, pars)


    def call_residuals(self, arg0):
        """
        call_residuals(PyCallback self, Parameters arg0) -> vdouble1d_t

        std::vector< double > PyCallback::call_residuals(Fit::Parameters)

        Call Python callable and returns its result. Intended to be overloaded in Python.

        Parameters:
        -----------

        pars: 
        Fit parameters object (intentionally passed by value).

        vector of residuals 

        """
        return _libBornAgainFit.PyCallback_call_residuals(self, arg0)

    def __disown__(self):
        self.this.disown()
        _libBornAgainFit.disown_PyCallback(self)
        return weakref_proxy(self)
PyCallback_swigregister = _libBornAgainFit.PyCallback_swigregister
PyCallback_swigregister(PyCallback)

class MinimizerResult(_object):
    """


    Result of minimization round.

    C++ includes: MinimizerResult.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinimizerResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinimizerResult, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(Fit::MinimizerResult self) -> MinimizerResult

        MinimizerResult::MinimizerResult()

        """
        this = _libBornAgainFit.new_MinimizerResult()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setParameters(self, parameters):
        """
        setParameters(MinimizerResult self, Parameters parameters)

        void MinimizerResult::setParameters(const Parameters &parameters)

        """
        return _libBornAgainFit.MinimizerResult_setParameters(self, parameters)


    def parameters(self):
        """
        parameters(MinimizerResult self) -> Parameters

        Parameters MinimizerResult::parameters() const 

        """
        return _libBornAgainFit.MinimizerResult_parameters(self)


    def setMinValue(self, value):
        """
        setMinValue(MinimizerResult self, double value)

        void MinimizerResult::setMinValue(double value)

        """
        return _libBornAgainFit.MinimizerResult_setMinValue(self, value)


    def minValue(self):
        """
        minValue(MinimizerResult self) -> double

        double MinimizerResult::minValue() const

        Minimum value of objective function found by minimizer. 

        """
        return _libBornAgainFit.MinimizerResult_minValue(self)


    def toString(self):
        """
        toString(MinimizerResult self) -> std::string

        std::string MinimizerResult::toString() const

        Returns multi-line string representing minimization results. 

        """
        return _libBornAgainFit.MinimizerResult_toString(self)


    def setReport(self, value):
        """
        setReport(MinimizerResult self, std::string const & value)

        void MinimizerResult::setReport(const std::string &value)

        """
        return _libBornAgainFit.MinimizerResult_setReport(self, value)


    def setDuration(self, value):
        """
        setDuration(MinimizerResult self, double value)

        void MinimizerResult::setDuration(double value)

        """
        return _libBornAgainFit.MinimizerResult_setDuration(self, value)


    def setNumberOfCalls(self, value):
        """
        setNumberOfCalls(MinimizerResult self, int value)

        void MinimizerResult::setNumberOfCalls(int value)

        """
        return _libBornAgainFit.MinimizerResult_setNumberOfCalls(self, value)


    def setNumberOfGradientCalls(self, value):
        """
        setNumberOfGradientCalls(MinimizerResult self, int value)

        void MinimizerResult::setNumberOfGradientCalls(int value)

        """
        return _libBornAgainFit.MinimizerResult_setNumberOfGradientCalls(self, value)

    __swig_destroy__ = _libBornAgainFit.delete_MinimizerResult
    __del__ = lambda self: None
MinimizerResult_swigregister = _libBornAgainFit.MinimizerResult_swigregister
MinimizerResult_swigregister(MinimizerResult)

class Minimizer(_object):
    """


    A main class to run fitting.

    C++ includes: Minimizer.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Minimizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Minimizer, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(Fit::Minimizer self) -> Minimizer

        Minimizer::Minimizer()

        """
        this = _libBornAgainFit.new_Minimizer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainFit.delete_Minimizer
    __del__ = lambda self: None

    def setMinimizer(self, *args):
        """
        setMinimizer(Minimizer self, std::string const & minimizerName, std::string const & algorithmName, std::string const & options)
        setMinimizer(Minimizer self, std::string const & minimizerName, std::string const & algorithmName)
        setMinimizer(Minimizer self, std::string const & minimizerName)
        setMinimizer(Minimizer self, IMinimizer minimizer)

        void Minimizer::setMinimizer(const std::string &minimizerName, const std::string &algorithmName="", const std::string &options="")

        """
        return _libBornAgainFit.Minimizer_setMinimizer(self, *args)


    def minimize_cpp(self, callback, parameters):
        """
        minimize_cpp(Minimizer self, PyCallback callback, Parameters parameters) -> MinimizerResult

        MinimizerResult Minimizer::minimize(PyCallback &callback, const Parameters &parameters)

        Finds minimum of user objective function (to be called from Python). 

        """
        return _libBornAgainFit.Minimizer_minimize_cpp(self, callback, parameters)


    def minimize(self, callback, pars):
        if not callable(callback):
            raise Exception("Not a Python callable")

    # single call to callback to check return type
        result = callback(pars)

        if isinstance(result, float):
            wrp = CallableWrapper(callback, PyCallback.SCALAR)
            return self.minimize_cpp(wrp, pars)
        elif hasattr(result, '__len__'):
            wrp = CallableWrapper(callback, PyCallback.RESIDUAL)
            return self.minimize_cpp(wrp, pars)
        else:
            raise Exception("Wrong callable type")


Minimizer_swigregister = _libBornAgainFit.Minimizer_swigregister
Minimizer_swigregister(Minimizer)


class ParametersIterator(object):

    def __init__(self, parameters):
        self.parameters = parameters
        self.index = -1

    def __iter__(self):
        return self

    def next(self):
        self.index += 1
        if self.index < self.parameters.size():
            return self.parameters[self.index]
        else:
            raise StopIteration

    def __next__(self):
        return self.next()


class CallableWrapper(PyCallback):
    def __init__(self, f, callable_type):
        super(CallableWrapper, self).__init__(callable_type)
        self.f_ = f
    def call_scalar(self, obj):
        return self.f_(obj)
    def call_residuals(self, obj):
        return self.f_(obj)


# This file is compatible with both classic and new-style classes.

